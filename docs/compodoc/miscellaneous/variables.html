<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Infisical Server Helper docs</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
        <link rel="stylesheet" href="../styles/material.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">Infisical Server Helper docs</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content miscellaneous-variables">
                   <div class="content-data">


















<ol class="breadcrumb">
  <li class="breadcrumb-item">Miscellaneous</li>
  <li class="breadcrumb-item">Variables</li>
</ol>

<section data-compodoc="block-index">
    <h3 id="index">Index</h3>
    <table class="table table-sm table-bordered index-table">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <ul class="index-list">
                        <li>
                            <a href="#ApiStatusGet400ResponseStatusCodeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiStatusGet400ResponseStatusCodeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiStatusGet401ResponseStatusCodeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiStatusGet401ResponseStatusCodeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiStatusGet403ResponseStatusCodeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiStatusGet403ResponseStatusCodeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiStatusGet404ResponseStatusCodeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiStatusGet404ResponseStatusCodeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiStatusGet422ResponseStatusCodeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiStatusGet422ResponseStatusCodeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiStatusGet500ResponseStatusCodeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiStatusGet500ResponseStatusCodeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AccessApprovalsPoliciesGet200ResponseApprovalsInnerApproversInnerTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AccessApprovalsPoliciesGet200ResponseApprovalsInnerApproversInnerTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AccessApprovalsPoliciesPolicyIdGet200ResponseApprovalApproversInnerTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AccessApprovalsPoliciesPolicyIdGet200ResponseApprovalApproversInnerTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AccessApprovalsPoliciesPolicyIdPatchRequestEnforcementLevelEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AccessApprovalsPoliciesPolicyIdPatchRequestEnforcementLevelEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AccessApprovalsPoliciesPostRequestEnforcementLevelEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AccessApprovalsPoliciesPostRequestEnforcementLevelEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AccessApprovalsRequestsRequestIdReviewPostRequestStatusEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AccessApprovalsRequestsRequestIdReviewPostRequestStatusEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AdditionalPrivilegeIdentityPatchRequestPrivilegeDetailsTemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AdditionalPrivilegeIdentityPatchRequestPrivilegeDetailsTemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPermissionsInnerActionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPermissionsInnerActionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPermissionsInnerSubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPermissionsInnerSubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPrivilegePermissionActionsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPrivilegePermissionActionsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPrivilegePermissionSubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPrivilegePermissionSubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AdditionalPrivilegeIdentityTemporaryPostRequestTemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AdditionalPrivilegeIdentityTemporaryPostRequestTemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AdminConfigPatchRequestEnabledLoginMethodsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AdminConfigPatchRequestEnabledLoginMethodsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AdminEncryptionStrategiesGet200ResponseStrategiesInnerStrategyEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AdminEncryptionStrategiesGet200ResponseStrategiesInnerStrategyEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AdminEncryptionStrategiesPatchRequestStrategyEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AdminEncryptionStrategiesPatchRequestStrategyEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAwsAvailableGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAwsAvailableGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAwsConnectionIdKmsKeysGetDestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAwsConnectionIdKmsKeysGetDestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAwsConnectionIdKmsKeysGetRegionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAwsConnectionIdKmsKeysGetRegionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAwsGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAwsGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAwsGet200ResponseAppConnectionsInnerMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAwsGet200ResponseAppConnectionsInnerMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAwsPostRequestAllOfAnyOf1MethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAwsPostRequestAllOfAnyOf1MethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAwsPostRequestAllOfAnyOfMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAwsPostRequestAllOfAnyOfMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAwsPostRequestMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAwsPostRequestMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAzureAppConfigurationAvailableGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAzureAppConfigurationAvailableGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAzureAppConfigurationGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAzureAppConfigurationGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAzureAppConfigurationGet200ResponseAppConnectionsInnerMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAzureAppConfigurationGet200ResponseAppConnectionsInnerMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAzureAppConfigurationPostRequestAllOfAnyOfMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAzureAppConfigurationPostRequestAllOfAnyOfMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAzureAppConfigurationPostRequestMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAzureAppConfigurationPostRequestMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAzureKeyVaultAvailableGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAzureKeyVaultAvailableGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAzureKeyVaultGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAzureKeyVaultGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAzureKeyVaultGet200ResponseAppConnectionsInnerMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAzureKeyVaultGet200ResponseAppConnectionsInnerMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAzureKeyVaultPostRequestAllOfAnyOfMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAzureKeyVaultPostRequestAllOfAnyOfMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsAzureKeyVaultPostRequestMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsAzureKeyVaultPostRequestMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsDatabricksAvailableGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsDatabricksAvailableGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsDatabricksGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsDatabricksGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsDatabricksGet200ResponseAppConnectionsInnerMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsDatabricksGet200ResponseAppConnectionsInnerMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsDatabricksPostRequestAllOfAnyOfMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsDatabricksPostRequestAllOfAnyOfMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsDatabricksPostRequestMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsDatabricksPostRequestMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGcpAvailableGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGcpAvailableGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGcpGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGcpGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGcpGet200ResponseAppConnectionsInnerMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGcpGet200ResponseAppConnectionsInnerMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGcpPostRequestAllOfAnyOfMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGcpPostRequestAllOfAnyOfMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGcpPostRequestMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGcpPostRequestMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf1AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf1AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf1MethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf1MethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf2AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf2AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf2MethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf2MethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf3AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf3AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf3MethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf3MethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf4AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf4AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf4MethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf4MethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf5AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf5AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf5MethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf5MethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf6AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf6AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf6MethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf6MethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf7AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf7AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf7MethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf7MethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf8AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf8AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf8MethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf8MethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOfAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOfAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOfMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOfMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGithubAvailableGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGithubAvailableGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGithubGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGithubGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGithubGet200ResponseAppConnectionsInnerMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGithubGet200ResponseAppConnectionsInnerMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGithubPostRequestAllOfAnyOf1MethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGithubPostRequestAllOfAnyOf1MethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGithubPostRequestAllOfAnyOfMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGithubPostRequestAllOfAnyOfMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsGithubPostRequestMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsGithubPostRequestMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsHumanitecAvailableGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsHumanitecAvailableGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsHumanitecGet200ResponseAppConnectionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsHumanitecGet200ResponseAppConnectionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsHumanitecGet200ResponseAppConnectionsInnerMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsHumanitecGet200ResponseAppConnectionsInnerMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsHumanitecPostRequestAllOfAnyOfMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsHumanitecPostRequestAllOfAnyOfMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsHumanitecPostRequestMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsHumanitecPostRequestMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1MethodsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1MethodsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1NameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1NameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2MethodsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2MethodsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2NameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2NameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3MethodsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3MethodsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3NameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3NameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4MethodsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4MethodsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4NameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4NameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5MethodsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5MethodsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5NameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5NameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6AppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6AppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6MethodsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6MethodsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6NameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6NameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfMethodsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfMethodsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfNameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfNameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAppEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAppEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerMethodsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerMethodsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerNameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerNameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AuthCheckAuthPost200ResponseMessageEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AuthCheckAuthPost200ResponseMessageEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestAnyOf1ConfigurationTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestAnyOf1ConfigurationTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestAnyOfConfigurationTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestAnyOfConfigurationTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestConfigurationTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestConfigurationTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestAnyOf1ConfigurationTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestAnyOf1ConfigurationTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestAnyOfConfigurationTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestAnyOfConfigurationTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestConfigurationTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestConfigurationTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200ResponseTokenTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200ResponseTokenTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DashboardAccessibleSecretsGetFilterByActionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DashboardAccessibleSecretsGetFilterByActionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DashboardSecretsDetailsGetOrderByEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DashboardSecretsDetailsGetOrderByEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DashboardSecretsDetailsGetOrderDirectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DashboardSecretsDetailsGetOrderDirectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DashboardSecretsOverviewGetOrderByEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DashboardSecretsOverviewGetOrderByEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DashboardSecretsOverviewGetOrderDirectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DashboardSecretsOverviewGetOrderDirectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf10TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf10TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf11TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf11TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsAnyOf1CredentialTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsAnyOf1CredentialTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsAnyOfCredentialTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsAnyOfCredentialTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsCredentialTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsCredentialTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf12TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf12TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf13TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf13TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAlgorithmEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAlgorithmEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOf1AlgorithmEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOf1AlgorithmEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOf1ConfigTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOf1ConfigTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOfConfigTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOfConfigTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsConfigTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsConfigTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf14TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf14TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf1TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf1TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf2TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf2TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf3TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf3TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf4TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf4TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf5TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf5TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf6TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf6TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf7TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf7TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthAnyOf1TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthAnyOf1TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthAnyOfTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthAnyOfTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf8TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf8TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf9TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf9TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOfInputsClientEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOfInputsClientEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOfTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderAnyOfTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1DynamicSecretsPostRequestProviderTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1DynamicSecretsPostRequestProviderTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsGcpKeysPostRequestAnyOf1AuthMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsGcpKeysPostRequestAnyOf1AuthMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsGcpKeysPostRequestAnyOfAuthMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsGcpKeysPostRequestAnyOfAuthMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsGcpKeysPostRequestAnyOfCredentialTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsGcpKeysPostRequestAnyOfCredentialTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsGcpKeysPostRequestAuthMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsGcpKeysPostRequestAuthMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsIdPatchRequestProviderAnyOf1TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsIdPatchRequestProviderAnyOf1TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsIdPatchRequestProviderAnyOfTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsIdPatchRequestProviderAnyOfTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsIdPatchRequestProviderTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsIdPatchRequestProviderTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsPostRequestProviderAnyOf1InputsCredentialTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsPostRequestProviderAnyOf1InputsCredentialTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsPostRequestProviderAnyOf1TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsPostRequestProviderAnyOf1TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialAnyOf1TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialAnyOf1TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialAnyOfTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialAnyOfTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsPostRequestProviderAnyOfTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsPostRequestProviderAnyOfTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1ExternalKmsPostRequestProviderTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1ExternalKmsPostRequestProviderTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1GroupsIdUsersGetFilterEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1GroupsIdUsersGetFilterEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGetScopeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGetScopeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1IntegrationAuthIntegrationAuthIdPatchRequestIntegrationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1IntegrationAuthIntegrationAuthIdPatchRequestIntegrationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1IntegrationIntegrationIdDeleteShouldDeleteIntegrationSecretsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1IntegrationIntegrationIdDeleteShouldDeleteIntegrationSecretsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1IntegrationIntegrationIdPatchRequestMetadataMappingBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1IntegrationIntegrationIdPatchRequestMetadataMappingBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1IntegrationIntegrationIdPatchRequestMetadataMetadataSyncModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1IntegrationIntegrationIdPatchRequestMetadataMetadataSyncModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1IntegrationPostRequestMetadataMappingBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1IntegrationPostRequestMetadataMappingBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1IntegrationPostRequestMetadataMetadataSyncModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1IntegrationPostRequestMetadataMetadataSyncModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1KmipClientsGetOrderByEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1KmipClientsGetOrderByEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1KmipClientsGetOrderDirectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1KmipClientsGetOrderDirectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1KmipClientsIdCertificatesPostRequestKeyAlgorithmEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1KmipClientsIdCertificatesPostRequestKeyAlgorithmEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1KmipClientsIdPatchRequestPermissionsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1KmipClientsIdPatchRequestPermissionsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1KmipClientsPostRequestPermissionsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1KmipClientsPostRequestPermissionsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1KmipPostRequestCaKeyAlgorithmEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1KmipPostRequestCaKeyAlgorithmEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1KmipServerRegistrationPostRequestKeyAlgorithmEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1KmipServerRegistrationPostRequestKeyAlgorithmEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1KmipSpecCreatePostRequestAlgorithmEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1KmipSpecCreatePostRequestAlgorithmEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1KmipSpecRegisterPostRequestAlgorithmEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1KmipSpecRegisterPostRequestAlgorithmEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1KmsKeysGetOrderByEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1KmsKeysGetOrderByEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1KmsKeysGetOrderDirectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1KmsKeysGetOrderDirectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1KmsKeysPostRequestEncryptionAlgorithmEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1KmsKeysPostRequestEncryptionAlgorithmEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1OrganizationAuditLogsGetActorTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1OrganizationAuditLogsGetActorTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1OrganizationAuditLogsGetUserAgentTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1OrganizationAuditLogsGetUserAgentTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1OrganizationOrganizationIdPatchRequestSelectedMfaMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1OrganizationOrganizationIdPatchRequestSelectedMfaMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1OrganizationsOrganizationIdPlansTableGetBillingCycleEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1OrganizationsOrganizationIdPlansTableGetBillingCycleEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PasswordEmailPasswordResetVerifyPost200ResponseUserEncryptionVersionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PasswordEmailPasswordResetVerifyPost200ResponseUserEncryptionVersionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCaCaIdIssueCertificatePostRequestExtendedKeyUsagesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCaCaIdIssueCertificatePostRequestExtendedKeyUsagesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCaCaIdIssueCertificatePostRequestKeyUsagesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCaCaIdIssueCertificatePostRequestKeyUsagesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCaCaIdPatchRequestStatusEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCaCaIdPatchRequestStatusEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCaCaIdRenewPostRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCaCaIdRenewPostRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCaCaIdSignCertificatePostRequestExtendedKeyUsagesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCaCaIdSignCertificatePostRequestExtendedKeyUsagesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCaCaIdSignCertificatePostRequestKeyUsagesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCaCaIdSignCertificatePostRequestKeyUsagesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCaPostRequestKeyAlgorithmEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCaPostRequestKeyAlgorithmEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCaPostRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCaPostRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCertificatesIssueCertificatePostRequestExtendedKeyUsagesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCertificatesIssueCertificatePostRequestExtendedKeyUsagesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCertificatesIssueCertificatePostRequestKeyUsagesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCertificatesIssueCertificatePostRequestKeyUsagesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCertificatesSerialNumberRevokePostRequestRevocationReasonEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCertificatesSerialNumberRevokePostRequestRevocationReasonEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCertificatesSignCertificatePostRequestExtendedKeyUsagesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCertificatesSignCertificatePostRequestExtendedKeyUsagesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCertificatesSignCertificatePostRequestKeyUsagesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCertificatesSignCertificatePostRequestKeyUsagesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequestExtendedKeyUsagesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequestExtendedKeyUsagesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequestKeyUsagesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequestKeyUsagesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCertificateTemplatesPostRequestExtendedKeyUsagesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCertificateTemplatesPostRequestExtendedKeyUsagesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCertificateTemplatesPostRequestKeyUsagesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCertificateTemplatesPostRequestKeyUsagesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete200ResponseTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete200ResponseTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCollectionsCollectionIdItemsGet200ResponseCollectionItemsInnerTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCollectionsCollectionIdItemsGet200ResponseCollectionItemsInnerTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCollectionsCollectionIdItemsGetTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCollectionsCollectionIdItemsGetTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCollectionsCollectionIdItemsPost200ResponseTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCollectionsCollectionIdItemsPost200ResponseTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1PkiCollectionsCollectionIdItemsPostRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1PkiCollectionsCollectionIdItemsPostRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretApprovalRequestsGetStatusEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretApprovalRequestsGetStatusEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretApprovalRequestsIdReviewPostRequestStatusEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretApprovalRequestsIdReviewPostRequestStatusEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretApprovalRequestsIdStatusPostRequestStatusEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretApprovalRequestsIdStatusPostRequestStatusEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretApprovalsGet200ResponseApprovalsInnerApproversInnerTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretApprovalsGet200ResponseApprovalsInnerApproversInnerTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretApprovalsPostRequestApproversInnerAnyOf1TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretApprovalsPostRequestApproversInnerAnyOf1TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretApprovalsPostRequestApproversInnerAnyOfTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretApprovalsPostRequestApproversInnerAnyOfTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretApprovalsPostRequestApproversInnerTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretApprovalsPostRequestApproversInnerTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretApprovalsPostRequestEnforcementLevelEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretApprovalsPostRequestEnforcementLevelEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretApprovalsSapIdGet200ResponseApprovalApproversInnerTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretApprovalsSapIdGet200ResponseApprovalApproversInnerTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretApprovalsSapIdPatchRequestEnforcementLevelEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretApprovalsSapIdPatchRequestEnforcementLevelEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretScanningOrganizationOrganizationIdRisksExportGetResolvedStatusEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretScanningOrganizationOrganizationIdRisksExportGetResolvedStatusEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderByEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderByEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderDirectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderDirectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretScanningOrganizationOrganizationIdRisksGetResolvedStatusEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretScanningOrganizationOrganizationIdRisksGetResolvedStatusEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequestStatusEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequestStatusEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSharingRequestsPostRequestAccessTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSharingRequestsPostRequestAccessTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSharingSharedPostRequestAccessTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSharingSharedPostRequestAccessTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretsSecretNameAccessListGet200ResponseGroupsInnerAllowedActionsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretsSecretNameAccessListGet200ResponseGroupsInnerAllowedActionsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsAwsParameterStoreSyncIdDeleteRemoveSecretsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsAwsParameterStoreSyncIdDeleteRemoveSecretsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPostImportBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPostImportBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsAwsSecretsManagerSyncIdDeleteRemoveSecretsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsAwsSecretsManagerSyncIdDeleteRemoveSecretsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPostImportBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPostImportBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsAzureAppConfigurationSyncIdDeleteRemoveSecretsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsAzureAppConfigurationSyncIdDeleteRemoveSecretsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPostImportBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPostImportBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsAzureKeyVaultSyncIdDeleteRemoveSecretsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsAzureKeyVaultSyncIdDeleteRemoveSecretsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPostImportBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPostImportBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsDatabricksSyncIdDeleteRemoveSecretsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsDatabricksSyncIdDeleteRemoveSecretsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsDatabricksSyncIdImportSecretsPostImportBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsDatabricksSyncIdImportSecretsPostImportBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGcpSecretManagerSyncIdDeleteRemoveSecretsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGcpSecretManagerSyncIdDeleteRemoveSecretsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPostImportBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPostImportBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigAllOfAnyOf1MappingBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigAllOfAnyOf1MappingBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigAllOfAnyOfMappingBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigAllOfAnyOfMappingBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigMappingBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigMappingBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigRegionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigRegionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1SyncOptionsInitialSyncBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1SyncOptionsInitialSyncBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOf1ScopeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOf1ScopeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOf2ScopeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOf2ScopeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOfScopeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOfScopeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOfVisibilityEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOfVisibilityEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigScopeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigScopeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigVisibilityEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigVisibilityEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2SyncOptionsInitialSyncBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2SyncOptionsInitialSyncBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3DestinationConfigScopeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3DestinationConfigScopeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3SyncOptionsInitialSyncBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3SyncOptionsInitialSyncBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf4DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf4DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf4SyncOptionsInitialSyncBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf4SyncOptionsInitialSyncBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf5DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf5DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf5SyncOptionsInitialSyncBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf5SyncOptionsInitialSyncBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf6DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf6DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf6SyncOptionsInitialSyncBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf6SyncOptionsInitialSyncBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigAnyOf1ScopeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigAnyOf1ScopeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigAnyOfScopeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigAnyOfScopeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigScopeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigScopeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7SyncOptionsInitialSyncBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7SyncOptionsInitialSyncBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfDestinationConfigRegionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfDestinationConfigRegionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfDestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfDestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfSyncOptionsInitialSyncBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfSyncOptionsInitialSyncBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerDestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerDestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGithubSyncIdDeleteRemoveSecretsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGithubSyncIdDeleteRemoveSecretsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsGithubSyncIdImportSecretsPostImportBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsGithubSyncIdImportSecretsPostImportBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsHumanitecSyncIdDeleteRemoveSecretsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsHumanitecSyncIdDeleteRemoveSecretsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsHumanitecSyncIdImportSecretsPostImportBehaviorEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsHumanitecSyncIdImportSecretsPostImportBehaviorEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1ConnectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1ConnectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1NameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1NameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2ConnectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2ConnectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2NameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2NameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3ConnectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3ConnectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3NameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3NameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4ConnectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4ConnectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4NameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4NameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5ConnectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5ConnectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5NameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5NameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6ConnectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6ConnectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6NameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6NameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7ConnectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7ConnectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7DestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7DestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7NameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7NameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfConnectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfConnectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfDestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfDestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfNameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfNameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerConnectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerConnectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerDestinationEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerDestinationEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerNameEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerNameEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SshCaPostRequestKeyAlgorithmEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SshCaPostRequestKeyAlgorithmEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SshCaSshCaIdPatchRequestStatusEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SshCaSshCaIdPatchRequestStatusEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SshCertificatesIssuePost200ResponseKeyAlgorithmEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SshCertificatesIssuePost200ResponseKeyAlgorithmEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SshCertificatesIssuePostRequestCertTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SshCertificatesIssuePostRequestCertTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SshCertificatesIssuePostRequestKeyAlgorithmEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SshCertificatesIssuePostRequestKeyAlgorithmEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SshCertificatesSignPostRequestCertTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SshCertificatesSignPostRequestCertTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SshCertificateTemplatesCertificateTemplateIdPatchRequestStatusEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SshCertificateTemplatesCertificateTemplateIdPatchRequestStatusEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SsoConfigPatchRequestAuthProviderEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SsoConfigPatchRequestAuthProviderEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SsoConfigPostRequestAuthProviderEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SsoConfigPostRequestAuthProviderEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SsoOidcConfigPatchRequestConfigurationTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SsoOidcConfigPatchRequestConfigurationTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1SsoOidcConfigPostRequestConfigurationTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1SsoOidcConfigPostRequestConfigurationTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf1SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf1SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf2SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf2SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf3SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf3SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf4SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf4SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOfSubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOfSubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerSubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerSubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestTypeAnyOf1TemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1UserProjectAdditionalPrivilegePostRequestTypeAnyOf1TemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestTypeTemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1UserProjectAdditionalPrivilegePostRequestTypeTemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequestTypeAnyOf1TemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequestTypeAnyOf1TemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequestTypeTemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequestTypeTemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WebhooksPostRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WebhooksPostRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceGetIncludeRolesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceGetIncludeRolesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceGetTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceGetTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf10SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf10SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf11SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf11SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf12SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf12SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf13SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf13SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf14SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf14SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf15SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf15SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf16SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf16SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf17SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf17SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf18SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf18SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf19SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf19SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf1SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf1SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf20SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf20SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf21SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf21SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf22SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf22SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf23SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf23SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf24SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf24SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf25SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf25SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf26SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf26SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf27SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf27SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf28SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf28SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf29SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf29SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf2SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf2SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf3SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf3SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf4SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf4SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf5SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf5SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf6SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf6SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf7SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf7SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf8SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf8SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf9SubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf9SubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOfSubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOfSubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerSubjectEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerSubjectEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceWorkspaceIdAuditLogsGetEventTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceWorkspaceIdAuditLogsGetEventTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceWorkspaceIdAuditLogsGetUserAgentTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceWorkspaceIdAuditLogsGetUserAgentTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsAnyOf1TypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsAnyOf1TypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsAnyOfTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsAnyOfTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequestRolesInnerAnyOf1TemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequestRolesInnerAnyOf1TemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequestRolesInnerTemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequestRolesInnerTemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV1WorkspaceWorkspaceIdUsersGetIncludeGroupMembersEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV1WorkspaceWorkspaceIdUsersGetIncludeGroupMembersEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2AuthMfaVerifyPostRequestMfaMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2AuthMfaVerifyPostRequestMfaMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequestTypeAnyOfTemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequestTypeAnyOfTemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequestTypeTemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequestTypeTemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2IdentityProjectAdditionalPrivilegePostRequestTypeAnyOfTemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2IdentityProjectAdditionalPrivilegePostRequestTypeAnyOfTemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2IdentityProjectAdditionalPrivilegePostRequestTypeTemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2IdentityProjectAdditionalPrivilegePostRequestTypeTemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2OrganizationsOrganizationIdWorkspacesGetTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2OrganizationsOrganizationIdWorkspacesGetTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderByEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderByEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderDirectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderDirectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2ServiceTokenPostRequestPermissionsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2ServiceTokenPostRequestPermissionsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2UsersMeAuthMethodsPutRequestAuthMethodsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2UsersMeAuthMethodsPutRequestAuthMethodsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2UsersMeMfaPatchRequestSelectedMfaMethodEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2UsersMeMfaPatchRequestSelectedMfaMethodEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2WorkspacePostRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2WorkspacePostRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderByEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderByEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderDirectionEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderDirectionEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequestRolesInnerAnyOf1TemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequestRolesInnerAnyOf1TemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequestRolesInnerTemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequestRolesInnerTemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequestRolesInnerAnyOf1TemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequestRolesInnerAnyOf1TemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequestRolesInnerTemporaryModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequestRolesInnerTemporaryModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV2WorkspaceSlugCasGetStatusEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV2WorkspaceSlugCasGetStatusEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3AuthSelectOrganizationPostRequestUserAgentEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3AuthSelectOrganizationPostRequestUserAgentEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsBatchDeleteRequestSecretsInnerTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsBatchDeleteRequestSecretsInnerTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsBatchPatchRequestSecretsInnerTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsBatchPatchRequestSecretsInnerTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsBatchRawDeleteRequestSecretsInnerTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsBatchRawDeleteRequestSecretsInnerTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsBatchRawPatchRequestModeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsBatchRawPatchRequestModeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsGetIncludeImportsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsGetIncludeImportsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsGetRecursiveEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsGetRecursiveEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsRawGetExpandSecretReferencesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsRawGetExpandSecretReferencesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsRawGetIncludeImportsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsRawGetIncludeImportsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsRawGetRecursiveEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsRawGetRecursiveEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsRawGetViewSecretValueEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsRawGetViewSecretValueEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsRawSecretNameDeleteRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsRawSecretNameDeleteRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsRawSecretNameGetExpandSecretReferencesEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsRawSecretNameGetExpandSecretReferencesEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsRawSecretNameGetIncludeImportsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsRawSecretNameGetIncludeImportsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsRawSecretNameGetTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsRawSecretNameGetTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsRawSecretNameGetViewSecretValueEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsRawSecretNameGetViewSecretValueEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsRawSecretNamePatchRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsRawSecretNamePatchRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsRawSecretNamePostRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsRawSecretNamePostRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsSecretNameDeleteRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsSecretNameDeleteRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsSecretNameGetIncludeImportsEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsSecretNameGetIncludeImportsEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsSecretNameGetTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsSecretNameGetTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsSecretNamePatchRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsSecretNamePatchRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsSecretNamePostRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsSecretNamePostRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsTagsSecretNameDeleteRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsTagsSecretNameDeleteRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#ApiV3SecretsTagsSecretNamePostRequestTypeEnum" title="src/features/infisical/generated/api.ts" ><b>ApiV3SecretsTagsSecretNamePostRequestTypeEnum</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#appConfig" title="src/app.config.ts" ><b>appConfig</b>&nbsp;&nbsp;&nbsp;(src/.../app.config.ts)</a>
                        </li>
                        <li>
                            <a href="#assertParamExists" title="src/features/infisical/generated/common.ts" ><b>assertParamExists</b>&nbsp;&nbsp;&nbsp;(src/.../common.ts)</a>
                        </li>
                        <li>
                            <a href="#BASE_PATH" title="src/features/infisical/generated/base.ts" ><b>BASE_PATH</b>&nbsp;&nbsp;&nbsp;(src/.../base.ts)</a>
                        </li>
                        <li>
                            <a href="#COLLECTION_FORMATS" title="src/features/infisical/generated/base.ts" ><b>COLLECTION_FORMATS</b>&nbsp;&nbsp;&nbsp;(src/.../base.ts)</a>
                        </li>
                        <li>
                            <a href="#controllers" title="src/features/backup/backup.module.ts" ><b>controllers</b>&nbsp;&nbsp;&nbsp;(src/.../backup.module.ts)</a>
                        </li>
                        <li>
                            <a href="#createRequestFunction" title="src/features/infisical/generated/common.ts" ><b>createRequestFunction</b>&nbsp;&nbsp;&nbsp;(src/.../common.ts)</a>
                        </li>
                        <li>
                            <a href="#DefaultApiAxiosParamCreator" title="src/features/infisical/generated/api.ts" ><b>DefaultApiAxiosParamCreator</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#DefaultApiFactory" title="src/features/infisical/generated/api.ts" ><b>DefaultApiFactory</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#DefaultApiFp" title="src/features/infisical/generated/api.ts" ><b>DefaultApiFp</b>&nbsp;&nbsp;&nbsp;(src/.../api.ts)</a>
                        </li>
                        <li>
                            <a href="#DUMMY_BASE_URL" title="src/features/infisical/generated/common.ts" ><b>DUMMY_BASE_URL</b>&nbsp;&nbsp;&nbsp;(src/.../common.ts)</a>
                        </li>
                        <li>
                            <a href="#envCfg" title="src/config/env-config.ts" ><b>envCfg</b>&nbsp;&nbsp;&nbsp;(src/.../env-config.ts)</a>
                        </li>
                        <li>
                            <a href="#envFilePaths" title="src/main.ts" ><b>envFilePaths</b>&nbsp;&nbsp;&nbsp;(src/.../main.ts)</a>
                        </li>
                        <li>
                            <a href="#filteredImports" title="src/app.module.ts" ><b>filteredImports</b>&nbsp;&nbsp;&nbsp;(src/.../app.module.ts)</a>
                        </li>
                        <li>
                            <a href="#imports" title="src/app.module.ts" ><b>imports</b>&nbsp;&nbsp;&nbsp;(src/.../app.module.ts)</a>
                        </li>
                        <li>
                            <a href="#Joi" title="src/config/env-config.ts" ><b>Joi</b>&nbsp;&nbsp;&nbsp;(src/.../env-config.ts)</a>
                        </li>
                        <li>
                            <a href="#operationServerMap" title="src/features/infisical/generated/base.ts" ><b>operationServerMap</b>&nbsp;&nbsp;&nbsp;(src/.../base.ts)</a>
                        </li>
                        <li>
                            <a href="#providers" title="src/features/backup/backup.module.ts" ><b>providers</b>&nbsp;&nbsp;&nbsp;(src/.../backup.module.ts)</a>
                        </li>
                        <li>
                            <a href="#serializeDataIfNeeded" title="src/features/infisical/generated/common.ts" ><b>serializeDataIfNeeded</b>&nbsp;&nbsp;&nbsp;(src/.../common.ts)</a>
                        </li>
                        <li>
                            <a href="#setApiKeyToObject" title="src/features/infisical/generated/common.ts" ><b>setApiKeyToObject</b>&nbsp;&nbsp;&nbsp;(src/.../common.ts)</a>
                        </li>
                        <li>
                            <a href="#setBasicAuthToObject" title="src/features/infisical/generated/common.ts" ><b>setBasicAuthToObject</b>&nbsp;&nbsp;&nbsp;(src/.../common.ts)</a>
                        </li>
                        <li>
                            <a href="#setBearerAuthToObject" title="src/features/infisical/generated/common.ts" ><b>setBearerAuthToObject</b>&nbsp;&nbsp;&nbsp;(src/.../common.ts)</a>
                        </li>
                        <li>
                            <a href="#setOAuthToObject" title="src/features/infisical/generated/common.ts" ><b>setOAuthToObject</b>&nbsp;&nbsp;&nbsp;(src/.../common.ts)</a>
                        </li>
                        <li>
                            <a href="#setSearchParams" title="src/features/infisical/generated/common.ts" ><b>setSearchParams</b>&nbsp;&nbsp;&nbsp;(src/.../common.ts)</a>
                        </li>
                        <li>
                            <a href="#toPathString" title="src/features/infisical/generated/common.ts" ><b>toPathString</b>&nbsp;&nbsp;&nbsp;(src/.../common.ts)</a>
                        </li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>
</section>

    <h3>src/features/infisical/generated/api.ts</h3>
    <section data-compodoc="block-properties">
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiStatusGet400ResponseStatusCodeEnum"></a>
                    <span class="name">
                        <span ><b>ApiStatusGet400ResponseStatusCodeEnum</b></span>
                        <a href="#ApiStatusGet400ResponseStatusCodeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    NUMBER_400: 400
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiStatusGet401ResponseStatusCodeEnum"></a>
                    <span class="name">
                        <span ><b>ApiStatusGet401ResponseStatusCodeEnum</b></span>
                        <a href="#ApiStatusGet401ResponseStatusCodeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    NUMBER_401: 401
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiStatusGet403ResponseStatusCodeEnum"></a>
                    <span class="name">
                        <span ><b>ApiStatusGet403ResponseStatusCodeEnum</b></span>
                        <a href="#ApiStatusGet403ResponseStatusCodeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    NUMBER_403: 403
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiStatusGet404ResponseStatusCodeEnum"></a>
                    <span class="name">
                        <span ><b>ApiStatusGet404ResponseStatusCodeEnum</b></span>
                        <a href="#ApiStatusGet404ResponseStatusCodeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    NUMBER_404: 404
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiStatusGet422ResponseStatusCodeEnum"></a>
                    <span class="name">
                        <span ><b>ApiStatusGet422ResponseStatusCodeEnum</b></span>
                        <a href="#ApiStatusGet422ResponseStatusCodeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    NUMBER_422: 422
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiStatusGet500ResponseStatusCodeEnum"></a>
                    <span class="name">
                        <span ><b>ApiStatusGet500ResponseStatusCodeEnum</b></span>
                        <a href="#ApiStatusGet500ResponseStatusCodeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    NUMBER_500: 500
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AccessApprovalsPoliciesGet200ResponseApprovalsInnerApproversInnerTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AccessApprovalsPoliciesGet200ResponseApprovalsInnerApproversInnerTypeEnum</b></span>
                        <a href="#ApiV1AccessApprovalsPoliciesGet200ResponseApprovalsInnerApproversInnerTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Group: &#x27;group&#x27;,
    User: &#x27;user&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AccessApprovalsPoliciesPolicyIdGet200ResponseApprovalApproversInnerTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AccessApprovalsPoliciesPolicyIdGet200ResponseApprovalApproversInnerTypeEnum</b></span>
                        <a href="#ApiV1AccessApprovalsPoliciesPolicyIdGet200ResponseApprovalApproversInnerTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Group: &#x27;group&#x27;,
    User: &#x27;user&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AccessApprovalsPoliciesPolicyIdPatchRequestEnforcementLevelEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AccessApprovalsPoliciesPolicyIdPatchRequestEnforcementLevelEnum</b></span>
                        <a href="#ApiV1AccessApprovalsPoliciesPolicyIdPatchRequestEnforcementLevelEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Hard: &#x27;hard&#x27;,
    Soft: &#x27;soft&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AccessApprovalsPoliciesPostRequestEnforcementLevelEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AccessApprovalsPoliciesPostRequestEnforcementLevelEnum</b></span>
                        <a href="#ApiV1AccessApprovalsPoliciesPostRequestEnforcementLevelEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Hard: &#x27;hard&#x27;,
    Soft: &#x27;soft&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AccessApprovalsRequestsRequestIdReviewPostRequestStatusEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AccessApprovalsRequestsRequestIdReviewPostRequestStatusEnum</b></span>
                        <a href="#ApiV1AccessApprovalsRequestsRequestIdReviewPostRequestStatusEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Approved: &#x27;approved&#x27;,
    Rejected: &#x27;rejected&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AdditionalPrivilegeIdentityPatchRequestPrivilegeDetailsTemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AdditionalPrivilegeIdentityPatchRequestPrivilegeDetailsTemporaryModeEnum</b></span>
                        <a href="#ApiV1AdditionalPrivilegeIdentityPatchRequestPrivilegeDetailsTemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPermissionsInnerActionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPermissionsInnerActionEnum</b></span>
                        <a href="#ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPermissionsInnerActionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Read: &#x27;read&#x27;,
    Create: &#x27;create&#x27;,
    Edit: &#x27;edit&#x27;,
    Delete: &#x27;delete&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPermissionsInnerSubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPermissionsInnerSubjectEnum</b></span>
                        <a href="#ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPermissionsInnerSubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Role: &#x27;role&#x27;,
    Member: &#x27;member&#x27;,
    Groups: &#x27;groups&#x27;,
    Settings: &#x27;settings&#x27;,
    Integrations: &#x27;integrations&#x27;,
    Webhooks: &#x27;webhooks&#x27;,
    ServiceTokens: &#x27;service-tokens&#x27;,
    Environments: &#x27;environments&#x27;,
    Tags: &#x27;tags&#x27;,
    AuditLogs: &#x27;audit-logs&#x27;,
    IpAllowlist: &#x27;ip-allowlist&#x27;,
    Workspace: &#x27;workspace&#x27;,
    Secrets: &#x27;secrets&#x27;,
    SecretFolders: &#x27;secret-folders&#x27;,
    SecretImports: &#x27;secret-imports&#x27;,
    DynamicSecrets: &#x27;dynamic-secrets&#x27;,
    SecretRollback: &#x27;secret-rollback&#x27;,
    SecretApproval: &#x27;secret-approval&#x27;,
    SecretRotation: &#x27;secret-rotation&#x27;,
    Identity: &#x27;identity&#x27;,
    CertificateAuthorities: &#x27;certificate-authorities&#x27;,
    Certificates: &#x27;certificates&#x27;,
    CertificateTemplates: &#x27;certificate-templates&#x27;,
    SshCertificateAuthorities: &#x27;ssh-certificate-authorities&#x27;,
    SshCertificates: &#x27;ssh-certificates&#x27;,
    SshCertificateTemplates: &#x27;ssh-certificate-templates&#x27;,
    PkiAlerts: &#x27;pki-alerts&#x27;,
    PkiCollections: &#x27;pki-collections&#x27;,
    Kms: &#x27;kms&#x27;,
    Cmek: &#x27;cmek&#x27;,
    SecretSyncs: &#x27;secret-syncs&#x27;,
    Kmip: &#x27;kmip&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPrivilegePermissionActionsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPrivilegePermissionActionsEnum</b></span>
                        <a href="#ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPrivilegePermissionActionsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Read: &#x27;read&#x27;,
    Create: &#x27;create&#x27;,
    Edit: &#x27;edit&#x27;,
    Delete: &#x27;delete&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPrivilegePermissionSubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPrivilegePermissionSubjectEnum</b></span>
                        <a href="#ApiV1AdditionalPrivilegeIdentityPermanentPostRequestPrivilegePermissionSubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Secrets: &#x27;secrets&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AdditionalPrivilegeIdentityTemporaryPostRequestTemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AdditionalPrivilegeIdentityTemporaryPostRequestTemporaryModeEnum</b></span>
                        <a href="#ApiV1AdditionalPrivilegeIdentityTemporaryPostRequestTemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AdminConfigPatchRequestEnabledLoginMethodsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AdminConfigPatchRequestEnabledLoginMethodsEnum</b></span>
                        <a href="#ApiV1AdminConfigPatchRequestEnabledLoginMethodsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Email: &#x27;email&#x27;,
    Google: &#x27;google&#x27;,
    Github: &#x27;github&#x27;,
    Gitlab: &#x27;gitlab&#x27;,
    Saml: &#x27;saml&#x27;,
    Ldap: &#x27;ldap&#x27;,
    Oidc: &#x27;oidc&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AdminEncryptionStrategiesGet200ResponseStrategiesInnerStrategyEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AdminEncryptionStrategiesGet200ResponseStrategiesInnerStrategyEnum</b></span>
                        <a href="#ApiV1AdminEncryptionStrategiesGet200ResponseStrategiesInnerStrategyEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Software: &#x27;SOFTWARE&#x27;,
    Hsm: &#x27;HSM&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AdminEncryptionStrategiesPatchRequestStrategyEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AdminEncryptionStrategiesPatchRequestStrategyEnum</b></span>
                        <a href="#ApiV1AdminEncryptionStrategiesPatchRequestStrategyEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Software: &#x27;SOFTWARE&#x27;,
    Hsm: &#x27;HSM&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAwsAvailableGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAwsAvailableGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsAwsAvailableGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aws: &#x27;aws&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAwsConnectionIdKmsKeysGetDestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAwsConnectionIdKmsKeysGetDestinationEnum</b></span>
                        <a href="#ApiV1AppConnectionsAwsConnectionIdKmsKeysGetDestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AwsParameterStore: &#x27;aws-parameter-store&#x27;,
    AwsSecretsManager: &#x27;aws-secrets-manager&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAwsConnectionIdKmsKeysGetRegionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAwsConnectionIdKmsKeysGetRegionEnum</b></span>
                        <a href="#ApiV1AppConnectionsAwsConnectionIdKmsKeysGetRegionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    UsEast1: &#x27;us-east-1&#x27;,
    UsEast2: &#x27;us-east-2&#x27;,
    UsWest1: &#x27;us-west-1&#x27;,
    UsWest2: &#x27;us-west-2&#x27;,
    UsGovEast1: &#x27;us-gov-east-1&#x27;,
    UsGovWest1: &#x27;us-gov-west-1&#x27;,
    AfSouth1: &#x27;af-south-1&#x27;,
    ApEast1: &#x27;ap-east-1&#x27;,
    ApSouth1: &#x27;ap-south-1&#x27;,
    ApSouth2: &#x27;ap-south-2&#x27;,
    ApNortheast1: &#x27;ap-northeast-1&#x27;,
    ApNortheast2: &#x27;ap-northeast-2&#x27;,
    ApNortheast3: &#x27;ap-northeast-3&#x27;,
    ApSoutheast1: &#x27;ap-southeast-1&#x27;,
    ApSoutheast2: &#x27;ap-southeast-2&#x27;,
    ApSoutheast3: &#x27;ap-southeast-3&#x27;,
    ApSoutheast4: &#x27;ap-southeast-4&#x27;,
    CaCentral1: &#x27;ca-central-1&#x27;,
    EuCentral1: &#x27;eu-central-1&#x27;,
    EuCentral2: &#x27;eu-central-2&#x27;,
    EuWest1: &#x27;eu-west-1&#x27;,
    EuWest2: &#x27;eu-west-2&#x27;,
    EuWest3: &#x27;eu-west-3&#x27;,
    EuSouth1: &#x27;eu-south-1&#x27;,
    EuSouth2: &#x27;eu-south-2&#x27;,
    EuNorth1: &#x27;eu-north-1&#x27;,
    MeSouth1: &#x27;me-south-1&#x27;,
    MeCentral1: &#x27;me-central-1&#x27;,
    SaEast1: &#x27;sa-east-1&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAwsGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAwsGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsAwsGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aws: &#x27;aws&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAwsGet200ResponseAppConnectionsInnerMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAwsGet200ResponseAppConnectionsInnerMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsAwsGet200ResponseAppConnectionsInnerMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AccessKey: &#x27;access-key&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAwsPostRequestAllOfAnyOf1MethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAwsPostRequestAllOfAnyOf1MethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsAwsPostRequestAllOfAnyOf1MethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AccessKey: &#x27;access-key&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAwsPostRequestAllOfAnyOfMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAwsPostRequestAllOfAnyOfMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsAwsPostRequestAllOfAnyOfMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AssumeRole: &#x27;assume-role&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAwsPostRequestMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAwsPostRequestMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsAwsPostRequestMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AccessKey: &#x27;access-key&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAzureAppConfigurationAvailableGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAzureAppConfigurationAvailableGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsAzureAppConfigurationAvailableGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureAppConfiguration: &#x27;azure-app-configuration&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAzureAppConfigurationGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAzureAppConfigurationGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsAzureAppConfigurationGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureAppConfiguration: &#x27;azure-app-configuration&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAzureAppConfigurationGet200ResponseAppConnectionsInnerMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAzureAppConfigurationGet200ResponseAppConnectionsInnerMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsAzureAppConfigurationGet200ResponseAppConnectionsInnerMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAzureAppConfigurationPostRequestAllOfAnyOfMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAzureAppConfigurationPostRequestAllOfAnyOfMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsAzureAppConfigurationPostRequestAllOfAnyOfMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAzureAppConfigurationPostRequestMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAzureAppConfigurationPostRequestMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsAzureAppConfigurationPostRequestMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAzureKeyVaultAvailableGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAzureKeyVaultAvailableGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsAzureKeyVaultAvailableGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureKeyVault: &#x27;azure-key-vault&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAzureKeyVaultGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAzureKeyVaultGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsAzureKeyVaultGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureKeyVault: &#x27;azure-key-vault&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAzureKeyVaultGet200ResponseAppConnectionsInnerMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAzureKeyVaultGet200ResponseAppConnectionsInnerMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsAzureKeyVaultGet200ResponseAppConnectionsInnerMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAzureKeyVaultPostRequestAllOfAnyOfMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAzureKeyVaultPostRequestAllOfAnyOfMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsAzureKeyVaultPostRequestAllOfAnyOfMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsAzureKeyVaultPostRequestMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsAzureKeyVaultPostRequestMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsAzureKeyVaultPostRequestMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsDatabricksAvailableGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsDatabricksAvailableGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsDatabricksAvailableGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Databricks: &#x27;databricks&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsDatabricksGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsDatabricksGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsDatabricksGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Databricks: &#x27;databricks&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsDatabricksGet200ResponseAppConnectionsInnerMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsDatabricksGet200ResponseAppConnectionsInnerMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsDatabricksGet200ResponseAppConnectionsInnerMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ServicePrincipal: &#x27;service-principal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsDatabricksPostRequestAllOfAnyOfMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsDatabricksPostRequestAllOfAnyOfMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsDatabricksPostRequestAllOfAnyOfMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ServicePrincipal: &#x27;service-principal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsDatabricksPostRequestMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsDatabricksPostRequestMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsDatabricksPostRequestMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ServicePrincipal: &#x27;service-principal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGcpAvailableGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGcpAvailableGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGcpAvailableGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Gcp: &#x27;gcp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGcpGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGcpGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGcpGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Gcp: &#x27;gcp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGcpGet200ResponseAppConnectionsInnerMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGcpGet200ResponseAppConnectionsInnerMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGcpGet200ResponseAppConnectionsInnerMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ServiceAccountImpersonation: &#x27;service-account-impersonation&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGcpPostRequestAllOfAnyOfMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGcpPostRequestAllOfAnyOfMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGcpPostRequestAllOfAnyOfMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ServiceAccountImpersonation: &#x27;service-account-impersonation&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGcpPostRequestMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGcpPostRequestMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGcpPostRequestMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ServiceAccountImpersonation: &#x27;service-account-impersonation&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf1AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf1AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf1AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aws: &#x27;aws&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf1MethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf1MethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf1MethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AccessKey: &#x27;access-key&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf2AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf2AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf2AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Github: &#x27;github&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf2MethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf2MethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf2MethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    GithubApp: &#x27;github-app&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf3AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf3AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf3AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Github: &#x27;github&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf3MethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf3MethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf3MethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf4AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf4AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf4AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Gcp: &#x27;gcp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf4MethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf4MethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf4MethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ServiceAccountImpersonation: &#x27;service-account-impersonation&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf5AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf5AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf5AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureKeyVault: &#x27;azure-key-vault&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf5MethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf5MethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf5MethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf6AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf6AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf6AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureAppConfiguration: &#x27;azure-app-configuration&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf6MethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf6MethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf6MethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf7AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf7AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf7AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Databricks: &#x27;databricks&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf7MethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf7MethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf7MethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ServicePrincipal: &#x27;service-principal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf8AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf8AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf8AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf8MethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf8MethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOf8MethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ApiToken: &#x27;api-token&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOfAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOfAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOfAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aws: &#x27;aws&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOfMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOfMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAnyOfMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AssumeRole: &#x27;assume-role&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGet200ResponseAppConnectionsInnerMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGet200ResponseAppConnectionsInnerMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGet200ResponseAppConnectionsInnerMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ApiToken: &#x27;api-token&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGithubAvailableGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGithubAvailableGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGithubAvailableGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Github: &#x27;github&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGithubGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGithubGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsGithubGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Github: &#x27;github&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGithubGet200ResponseAppConnectionsInnerMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGithubGet200ResponseAppConnectionsInnerMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGithubGet200ResponseAppConnectionsInnerMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGithubPostRequestAllOfAnyOf1MethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGithubPostRequestAllOfAnyOf1MethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGithubPostRequestAllOfAnyOf1MethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGithubPostRequestAllOfAnyOfMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGithubPostRequestAllOfAnyOfMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGithubPostRequestAllOfAnyOfMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    GithubApp: &#x27;github-app&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsGithubPostRequestMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsGithubPostRequestMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsGithubPostRequestMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsHumanitecAvailableGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsHumanitecAvailableGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsHumanitecAvailableGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsHumanitecGet200ResponseAppConnectionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsHumanitecGet200ResponseAppConnectionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsHumanitecGet200ResponseAppConnectionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsHumanitecGet200ResponseAppConnectionsInnerMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsHumanitecGet200ResponseAppConnectionsInnerMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsHumanitecGet200ResponseAppConnectionsInnerMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ApiToken: &#x27;api-token&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsHumanitecPostRequestAllOfAnyOfMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsHumanitecPostRequestAllOfAnyOfMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsHumanitecPostRequestAllOfAnyOfMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ApiToken: &#x27;api-token&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsHumanitecPostRequestMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsHumanitecPostRequestMethodEnum</b></span>
                        <a href="#ApiV1AppConnectionsHumanitecPostRequestMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ApiToken: &#x27;api-token&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Github: &#x27;github&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1MethodsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1MethodsEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1MethodsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;,
    GithubApp: &#x27;github-app&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1NameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1NameEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf1NameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    GitHub: &#x27;GitHub&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Gcp: &#x27;gcp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2MethodsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2MethodsEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2MethodsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ServiceAccountImpersonation: &#x27;service-account-impersonation&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2NameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2NameEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf2NameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Gcp: &#x27;GCP&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureKeyVault: &#x27;azure-key-vault&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3MethodsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3MethodsEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3MethodsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3NameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3NameEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf3NameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureKeyVault: &#x27;Azure Key Vault&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureAppConfiguration: &#x27;azure-app-configuration&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4MethodsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4MethodsEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4MethodsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Oauth: &#x27;oauth&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4NameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4NameEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf4NameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureAppConfiguration: &#x27;Azure App Configuration&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Databricks: &#x27;databricks&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5MethodsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5MethodsEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5MethodsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ServicePrincipal: &#x27;service-principal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5NameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5NameEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf5NameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Databricks: &#x27;Databricks&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6AppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6AppEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6AppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6MethodsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6MethodsEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6MethodsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ApiToken: &#x27;api-token&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6NameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6NameEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOf6NameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;Humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aws: &#x27;aws&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfMethodsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfMethodsEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfMethodsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AssumeRole: &#x27;assume-role&#x27;,
    AccessKey: &#x27;access-key&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfNameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfNameEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAnyOfNameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aws: &#x27;AWS&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAppEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAppEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerAppEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerMethodsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerMethodsEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerMethodsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ApiToken: &#x27;api-token&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerNameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerNameEnum</b></span>
                        <a href="#ApiV1AppConnectionsOptionsGet200ResponseAppConnectionOptionsInnerNameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;Humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AuthCheckAuthPost200ResponseMessageEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AuthCheckAuthPost200ResponseMessageEnum</b></span>
                        <a href="#ApiV1AuthCheckAuthPost200ResponseMessageEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Authenticated: &#x27;Authenticated&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequestTypeEnum</b></span>
                        <a href="#ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Iam: &#x27;iam&#x27;,
    Gce: &#x27;gce&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequestTypeEnum</b></span>
                        <a href="#ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Iam: &#x27;iam&#x27;,
    Gce: &#x27;gce&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestAnyOf1ConfigurationTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestAnyOf1ConfigurationTypeEnum</b></span>
                        <a href="#ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestAnyOf1ConfigurationTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Static: &#x27;static&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestAnyOfConfigurationTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestAnyOfConfigurationTypeEnum</b></span>
                        <a href="#ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestAnyOfConfigurationTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Jwks: &#x27;jwks&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestConfigurationTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestConfigurationTypeEnum</b></span>
                        <a href="#ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequestConfigurationTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Static: &#x27;static&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestAnyOf1ConfigurationTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestAnyOf1ConfigurationTypeEnum</b></span>
                        <a href="#ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestAnyOf1ConfigurationTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Static: &#x27;static&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestAnyOfConfigurationTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestAnyOfConfigurationTypeEnum</b></span>
                        <a href="#ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestAnyOfConfigurationTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Jwks: &#x27;jwks&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestConfigurationTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestConfigurationTypeEnum</b></span>
                        <a href="#ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequestConfigurationTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Static: &#x27;static&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200ResponseTokenTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200ResponseTokenTypeEnum</b></span>
                        <a href="#ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200ResponseTokenTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Bearer: &#x27;Bearer&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DashboardAccessibleSecretsGetFilterByActionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DashboardAccessibleSecretsGetFilterByActionEnum</b></span>
                        <a href="#ApiV1DashboardAccessibleSecretsGetFilterByActionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    DescribeSecret: &#x27;describeSecret&#x27;,
    ReadValue: &#x27;readValue&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DashboardSecretsDetailsGetOrderByEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DashboardSecretsDetailsGetOrderByEnum</b></span>
                        <a href="#ApiV1DashboardSecretsDetailsGetOrderByEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Name: &#x27;name&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DashboardSecretsDetailsGetOrderDirectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DashboardSecretsDetailsGetOrderDirectionEnum</b></span>
                        <a href="#ApiV1DashboardSecretsDetailsGetOrderDirectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Asc: &#x27;asc&#x27;,
    Desc: &#x27;desc&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DashboardSecretsOverviewGetOrderByEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DashboardSecretsOverviewGetOrderByEnum</b></span>
                        <a href="#ApiV1DashboardSecretsOverviewGetOrderByEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Name: &#x27;name&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DashboardSecretsOverviewGetOrderDirectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DashboardSecretsOverviewGetOrderDirectionEnum</b></span>
                        <a href="#ApiV1DashboardSecretsOverviewGetOrderDirectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Asc: &#x27;asc&#x27;,
    Desc: &#x27;desc&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf10TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf10TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf10TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    RabbitMq: &#x27;rabbit-mq&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf11TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf11TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf11TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureEntraId: &#x27;azure-entra-id&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsAnyOf1CredentialTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsAnyOf1CredentialTypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsAnyOf1CredentialTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Static: &#x27;static&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsAnyOfCredentialTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsAnyOfCredentialTypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsAnyOfCredentialTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Dynamic: &#x27;dynamic&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsCredentialTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsCredentialTypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf12InputsCredentialTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Static: &#x27;static&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf12TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf12TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf12TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Ldap: &#x27;ldap&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf13TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf13TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf13TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Snowflake: &#x27;snowflake&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAlgorithmEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAlgorithmEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAlgorithmEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Sha1: &#x27;sha1&#x27;,
    Sha256: &#x27;sha256&#x27;,
    Sha512: &#x27;sha512&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOf1AlgorithmEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOf1AlgorithmEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOf1AlgorithmEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Sha1: &#x27;sha1&#x27;,
    Sha256: &#x27;sha256&#x27;,
    Sha512: &#x27;sha512&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOf1ConfigTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOf1ConfigTypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOf1ConfigTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Manual: &#x27;manual&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOfConfigTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOfConfigTypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsAnyOfConfigTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Url: &#x27;url&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsConfigTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsConfigTypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf14InputsConfigTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Manual: &#x27;manual&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf14TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf14TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf14TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Totp: &#x27;totp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf1TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf1TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf1TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Cassandra: &#x27;cassandra&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf2TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf2TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf2TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SapAse: &#x27;sap-ase&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf3TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf3TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf3TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AwsIam: &#x27;aws-iam&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf4TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf4TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf4TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Redis: &#x27;redis&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf5TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf5TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf5TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SapHana: &#x27;sap-hana&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf6TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf6TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf6TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AwsElasticache: &#x27;aws-elasticache&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf7TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf7TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf7TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    MongoDbAtlas: &#x27;mongo-db-atlas&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthAnyOf1TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthAnyOf1TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthAnyOf1TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ApiKey: &#x27;api-key&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthAnyOfTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthAnyOfTypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthAnyOfTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    User: &#x27;user&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthTypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf8InputsAuthTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    User: &#x27;user&#x27;,
    ApiKey: &#x27;api-key&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf8TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf8TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf8TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ElasticSearch: &#x27;elastic-search&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOf9TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOf9TypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOf9TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    MongoDb: &#x27;mongo-db&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOfInputsClientEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOfInputsClientEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOfInputsClientEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Postgres: &#x27;postgres&#x27;,
    Mysql2: &#x27;mysql2&#x27;,
    Oracledb: &#x27;oracledb&#x27;,
    Mssql: &#x27;mssql&#x27;,
    SapAse: &#x27;sap-ase&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderAnyOfTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderAnyOfTypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderAnyOfTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SqlDatabase: &#x27;sql-database&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1DynamicSecretsPostRequestProviderTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1DynamicSecretsPostRequestProviderTypeEnum</b></span>
                        <a href="#ApiV1DynamicSecretsPostRequestProviderTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SqlDatabase: &#x27;sql-database&#x27;,
    Cassandra: &#x27;cassandra&#x27;,
    SapAse: &#x27;sap-ase&#x27;,
    AwsIam: &#x27;aws-iam&#x27;,
    Redis: &#x27;redis&#x27;,
    SapHana: &#x27;sap-hana&#x27;,
    AwsElasticache: &#x27;aws-elasticache&#x27;,
    MongoDbAtlas: &#x27;mongo-db-atlas&#x27;,
    ElasticSearch: &#x27;elastic-search&#x27;,
    MongoDb: &#x27;mongo-db&#x27;,
    RabbitMq: &#x27;rabbit-mq&#x27;,
    AzureEntraId: &#x27;azure-entra-id&#x27;,
    Ldap: &#x27;ldap&#x27;,
    Snowflake: &#x27;snowflake&#x27;,
    Totp: &#x27;totp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsGcpKeysPostRequestAnyOf1AuthMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsGcpKeysPostRequestAnyOf1AuthMethodEnum</b></span>
                        <a href="#ApiV1ExternalKmsGcpKeysPostRequestAnyOf1AuthMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    KmsId: &#x27;kmsId&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsGcpKeysPostRequestAnyOfAuthMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsGcpKeysPostRequestAnyOfAuthMethodEnum</b></span>
                        <a href="#ApiV1ExternalKmsGcpKeysPostRequestAnyOfAuthMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Credential: &#x27;credential&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsGcpKeysPostRequestAnyOfCredentialTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsGcpKeysPostRequestAnyOfCredentialTypeEnum</b></span>
                        <a href="#ApiV1ExternalKmsGcpKeysPostRequestAnyOfCredentialTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ServiceAccount: &#x27;service_account&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsGcpKeysPostRequestAuthMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsGcpKeysPostRequestAuthMethodEnum</b></span>
                        <a href="#ApiV1ExternalKmsGcpKeysPostRequestAuthMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    KmsId: &#x27;kmsId&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsIdPatchRequestProviderAnyOf1TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsIdPatchRequestProviderAnyOf1TypeEnum</b></span>
                        <a href="#ApiV1ExternalKmsIdPatchRequestProviderAnyOf1TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Gcp: &#x27;gcp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsIdPatchRequestProviderAnyOfTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsIdPatchRequestProviderAnyOfTypeEnum</b></span>
                        <a href="#ApiV1ExternalKmsIdPatchRequestProviderAnyOfTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aws: &#x27;aws&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsIdPatchRequestProviderTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsIdPatchRequestProviderTypeEnum</b></span>
                        <a href="#ApiV1ExternalKmsIdPatchRequestProviderTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aws: &#x27;aws&#x27;,
    Gcp: &#x27;gcp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsPostRequestProviderAnyOf1InputsCredentialTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsPostRequestProviderAnyOf1InputsCredentialTypeEnum</b></span>
                        <a href="#ApiV1ExternalKmsPostRequestProviderAnyOf1InputsCredentialTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ServiceAccount: &#x27;service_account&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsPostRequestProviderAnyOf1TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsPostRequestProviderAnyOf1TypeEnum</b></span>
                        <a href="#ApiV1ExternalKmsPostRequestProviderAnyOf1TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Gcp: &#x27;gcp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialAnyOf1TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialAnyOf1TypeEnum</b></span>
                        <a href="#ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialAnyOf1TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AssumeRole: &#x27;assume-role&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialAnyOfTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialAnyOfTypeEnum</b></span>
                        <a href="#ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialAnyOfTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AccessKey: &#x27;access-key&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialTypeEnum</b></span>
                        <a href="#ApiV1ExternalKmsPostRequestProviderAnyOfInputsCredentialTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AccessKey: &#x27;access-key&#x27;,
    AssumeRole: &#x27;assume-role&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsPostRequestProviderAnyOfTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsPostRequestProviderAnyOfTypeEnum</b></span>
                        <a href="#ApiV1ExternalKmsPostRequestProviderAnyOfTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aws: &#x27;aws&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1ExternalKmsPostRequestProviderTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1ExternalKmsPostRequestProviderTypeEnum</b></span>
                        <a href="#ApiV1ExternalKmsPostRequestProviderTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aws: &#x27;aws&#x27;,
    Gcp: &#x27;gcp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1GroupsIdUsersGetFilterEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1GroupsIdUsersGetFilterEnum</b></span>
                        <a href="#ApiV1GroupsIdUsersGetFilterEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ExistingMembers: &#x27;existingMembers&#x27;,
    NonMembers: &#x27;nonMembers&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGetScopeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGetScopeEnum</b></span>
                        <a href="#ApiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGetScopeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Project: &#x27;project&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1IntegrationAuthIntegrationAuthIdPatchRequestIntegrationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1IntegrationAuthIntegrationAuthIdPatchRequestIntegrationEnum</b></span>
                        <a href="#ApiV1IntegrationAuthIntegrationAuthIdPatchRequestIntegrationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureKeyVault: &#x27;azure-key-vault&#x27;,
    AwsParameterStore: &#x27;aws-parameter-store&#x27;,
    AwsSecretManager: &#x27;aws-secret-manager&#x27;,
    GcpSecretManager: &#x27;gcp-secret-manager&#x27;,
    Heroku: &#x27;heroku&#x27;,
    Vercel: &#x27;vercel&#x27;,
    Netlify: &#x27;netlify&#x27;,
    Github: &#x27;github&#x27;,
    Gitlab: &#x27;gitlab&#x27;,
    Render: &#x27;render&#x27;,
    Railway: &#x27;railway&#x27;,
    Flyio: &#x27;flyio&#x27;,
    LaravelForge: &#x27;laravel-forge&#x27;,
    Circleci: &#x27;circleci&#x27;,
    Databricks: &#x27;databricks&#x27;,
    Travisci: &#x27;travisci&#x27;,
    Teamcity: &#x27;teamcity&#x27;,
    Supabase: &#x27;supabase&#x27;,
    Checkly: &#x27;checkly&#x27;,
    Qovery: &#x27;qovery&#x27;,
    TerraformCloud: &#x27;terraform-cloud&#x27;,
    HashicorpVault: &#x27;hashicorp-vault&#x27;,
    CloudflarePages: &#x27;cloudflare-pages&#x27;,
    CloudflareWorkers: &#x27;cloudflare-workers&#x27;,
    Bitbucket: &#x27;bitbucket&#x27;,
    Codefresh: &#x27;codefresh&#x27;,
    Windmill: &#x27;windmill&#x27;,
    DigitalOceanAppPlatform: &#x27;digital-ocean-app-platform&#x27;,
    Cloud66: &#x27;cloud-66&#x27;,
    Northflank: &#x27;northflank&#x27;,
    HasuraCloud: &#x27;hasura-cloud&#x27;,
    Rundeck: &#x27;rundeck&#x27;,
    AzureDevops: &#x27;azure-devops&#x27;,
    AzureAppConfiguration: &#x27;azure-app-configuration&#x27;,
    OctopusDeploy: &#x27;octopus-deploy&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1IntegrationIntegrationIdDeleteShouldDeleteIntegrationSecretsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1IntegrationIntegrationIdDeleteShouldDeleteIntegrationSecretsEnum</b></span>
                        <a href="#ApiV1IntegrationIntegrationIdDeleteShouldDeleteIntegrationSecretsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1IntegrationIntegrationIdPatchRequestMetadataMappingBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1IntegrationIntegrationIdPatchRequestMetadataMappingBehaviorEnum</b></span>
                        <a href="#ApiV1IntegrationIntegrationIdPatchRequestMetadataMappingBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    OneToOne: &#x27;one-to-one&#x27;,
    ManyToOne: &#x27;many-to-one&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1IntegrationIntegrationIdPatchRequestMetadataMetadataSyncModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1IntegrationIntegrationIdPatchRequestMetadataMetadataSyncModeEnum</b></span>
                        <a href="#ApiV1IntegrationIntegrationIdPatchRequestMetadataMetadataSyncModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Custom: &#x27;custom&#x27;,
    SecretMetadata: &#x27;secret-metadata&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1IntegrationPostRequestMetadataMappingBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1IntegrationPostRequestMetadataMappingBehaviorEnum</b></span>
                        <a href="#ApiV1IntegrationPostRequestMetadataMappingBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    OneToOne: &#x27;one-to-one&#x27;,
    ManyToOne: &#x27;many-to-one&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1IntegrationPostRequestMetadataMetadataSyncModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1IntegrationPostRequestMetadataMetadataSyncModeEnum</b></span>
                        <a href="#ApiV1IntegrationPostRequestMetadataMetadataSyncModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Custom: &#x27;custom&#x27;,
    SecretMetadata: &#x27;secret-metadata&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1KmipClientsGetOrderByEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1KmipClientsGetOrderByEnum</b></span>
                        <a href="#ApiV1KmipClientsGetOrderByEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Name: &#x27;name&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1KmipClientsGetOrderDirectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1KmipClientsGetOrderDirectionEnum</b></span>
                        <a href="#ApiV1KmipClientsGetOrderDirectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Asc: &#x27;asc&#x27;,
    Desc: &#x27;desc&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1KmipClientsIdCertificatesPostRequestKeyAlgorithmEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1KmipClientsIdCertificatesPostRequestKeyAlgorithmEnum</b></span>
                        <a href="#ApiV1KmipClientsIdCertificatesPostRequestKeyAlgorithmEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Rsa2048: &#x27;RSA_2048&#x27;,
    Rsa4096: &#x27;RSA_4096&#x27;,
    EcPrime256v1: &#x27;EC_prime256v1&#x27;,
    EcSecp384r1: &#x27;EC_secp384r1&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1KmipClientsIdPatchRequestPermissionsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1KmipClientsIdPatchRequestPermissionsEnum</b></span>
                        <a href="#ApiV1KmipClientsIdPatchRequestPermissionsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Create: &#x27;create&#x27;,
    Locate: &#x27;locate&#x27;,
    Check: &#x27;check&#x27;,
    Get: &#x27;get&#x27;,
    GetAttributes: &#x27;get-attributes&#x27;,
    Activate: &#x27;activate&#x27;,
    Revoke: &#x27;revoke&#x27;,
    Destroy: &#x27;destroy&#x27;,
    Register: &#x27;register&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1KmipClientsPostRequestPermissionsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1KmipClientsPostRequestPermissionsEnum</b></span>
                        <a href="#ApiV1KmipClientsPostRequestPermissionsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Create: &#x27;create&#x27;,
    Locate: &#x27;locate&#x27;,
    Check: &#x27;check&#x27;,
    Get: &#x27;get&#x27;,
    GetAttributes: &#x27;get-attributes&#x27;,
    Activate: &#x27;activate&#x27;,
    Revoke: &#x27;revoke&#x27;,
    Destroy: &#x27;destroy&#x27;,
    Register: &#x27;register&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1KmipPostRequestCaKeyAlgorithmEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1KmipPostRequestCaKeyAlgorithmEnum</b></span>
                        <a href="#ApiV1KmipPostRequestCaKeyAlgorithmEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Rsa2048: &#x27;RSA_2048&#x27;,
    Rsa4096: &#x27;RSA_4096&#x27;,
    EcPrime256v1: &#x27;EC_prime256v1&#x27;,
    EcSecp384r1: &#x27;EC_secp384r1&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1KmipServerRegistrationPostRequestKeyAlgorithmEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1KmipServerRegistrationPostRequestKeyAlgorithmEnum</b></span>
                        <a href="#ApiV1KmipServerRegistrationPostRequestKeyAlgorithmEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Rsa2048: &#x27;RSA_2048&#x27;,
    Rsa4096: &#x27;RSA_4096&#x27;,
    EcPrime256v1: &#x27;EC_prime256v1&#x27;,
    EcSecp384r1: &#x27;EC_secp384r1&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1KmipSpecCreatePostRequestAlgorithmEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1KmipSpecCreatePostRequestAlgorithmEnum</b></span>
                        <a href="#ApiV1KmipSpecCreatePostRequestAlgorithmEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aes256Gcm: &#x27;aes-256-gcm&#x27;,
    Aes128Gcm: &#x27;aes-128-gcm&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1KmipSpecRegisterPostRequestAlgorithmEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1KmipSpecRegisterPostRequestAlgorithmEnum</b></span>
                        <a href="#ApiV1KmipSpecRegisterPostRequestAlgorithmEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aes256Gcm: &#x27;aes-256-gcm&#x27;,
    Aes128Gcm: &#x27;aes-128-gcm&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1KmsKeysGetOrderByEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1KmsKeysGetOrderByEnum</b></span>
                        <a href="#ApiV1KmsKeysGetOrderByEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Name: &#x27;name&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1KmsKeysGetOrderDirectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1KmsKeysGetOrderDirectionEnum</b></span>
                        <a href="#ApiV1KmsKeysGetOrderDirectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Asc: &#x27;asc&#x27;,
    Desc: &#x27;desc&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1KmsKeysPostRequestEncryptionAlgorithmEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1KmsKeysPostRequestEncryptionAlgorithmEnum</b></span>
                        <a href="#ApiV1KmsKeysPostRequestEncryptionAlgorithmEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aes256Gcm: &#x27;aes-256-gcm&#x27;,
    Aes128Gcm: &#x27;aes-128-gcm&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1OrganizationAuditLogsGetActorTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1OrganizationAuditLogsGetActorTypeEnum</b></span>
                        <a href="#ApiV1OrganizationAuditLogsGetActorTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Platform: &#x27;platform&#x27;,
    KmipClient: &#x27;kmipClient&#x27;,
    User: &#x27;user&#x27;,
    Service: &#x27;service&#x27;,
    Identity: &#x27;identity&#x27;,
    Machine: &#x27;machine&#x27;,
    ScimClient: &#x27;scimClient&#x27;,
    UnknownUser: &#x27;unknownUser&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1OrganizationAuditLogsGetUserAgentTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1OrganizationAuditLogsGetUserAgentTypeEnum</b></span>
                        <a href="#ApiV1OrganizationAuditLogsGetUserAgentTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Web: &#x27;web&#x27;,
    Cli: &#x27;cli&#x27;,
    K8Operator: &#x27;k8-operator&#x27;,
    Terraform: &#x27;terraform&#x27;,
    Other: &#x27;other&#x27;,
    InfisicalPythonSdk: &#x27;InfisicalPythonSDK&#x27;,
    InfisicalNodeSdk: &#x27;InfisicalNodeSDK&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1OrganizationOrganizationIdPatchRequestSelectedMfaMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1OrganizationOrganizationIdPatchRequestSelectedMfaMethodEnum</b></span>
                        <a href="#ApiV1OrganizationOrganizationIdPatchRequestSelectedMfaMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Email: &#x27;email&#x27;,
    Totp: &#x27;totp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1OrganizationsOrganizationIdPlansTableGetBillingCycleEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1OrganizationsOrganizationIdPlansTableGetBillingCycleEnum</b></span>
                        <a href="#ApiV1OrganizationsOrganizationIdPlansTableGetBillingCycleEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Monthly: &#x27;monthly&#x27;,
    Yearly: &#x27;yearly&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PasswordEmailPasswordResetVerifyPost200ResponseUserEncryptionVersionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PasswordEmailPasswordResetVerifyPost200ResponseUserEncryptionVersionEnum</b></span>
                        <a href="#ApiV1PasswordEmailPasswordResetVerifyPost200ResponseUserEncryptionVersionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    NUMBER_1: 1,
    NUMBER_2: 2
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCaCaIdIssueCertificatePostRequestExtendedKeyUsagesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCaCaIdIssueCertificatePostRequestExtendedKeyUsagesEnum</b></span>
                        <a href="#ApiV1PkiCaCaIdIssueCertificatePostRequestExtendedKeyUsagesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ClientAuth: &#x27;clientAuth&#x27;,
    ServerAuth: &#x27;serverAuth&#x27;,
    CodeSigning: &#x27;codeSigning&#x27;,
    EmailProtection: &#x27;emailProtection&#x27;,
    TimeStamping: &#x27;timeStamping&#x27;,
    OcspSigning: &#x27;ocspSigning&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCaCaIdIssueCertificatePostRequestKeyUsagesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCaCaIdIssueCertificatePostRequestKeyUsagesEnum</b></span>
                        <a href="#ApiV1PkiCaCaIdIssueCertificatePostRequestKeyUsagesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    DigitalSignature: &#x27;digitalSignature&#x27;,
    KeyEncipherment: &#x27;keyEncipherment&#x27;,
    NonRepudiation: &#x27;nonRepudiation&#x27;,
    DataEncipherment: &#x27;dataEncipherment&#x27;,
    KeyAgreement: &#x27;keyAgreement&#x27;,
    KeyCertSign: &#x27;keyCertSign&#x27;,
    CRlSign: &#x27;cRLSign&#x27;,
    EncipherOnly: &#x27;encipherOnly&#x27;,
    DecipherOnly: &#x27;decipherOnly&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCaCaIdPatchRequestStatusEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCaCaIdPatchRequestStatusEnum</b></span>
                        <a href="#ApiV1PkiCaCaIdPatchRequestStatusEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Active: &#x27;active&#x27;,
    Disabled: &#x27;disabled&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCaCaIdRenewPostRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCaCaIdRenewPostRequestTypeEnum</b></span>
                        <a href="#ApiV1PkiCaCaIdRenewPostRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Existing: &#x27;existing&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCaCaIdSignCertificatePostRequestExtendedKeyUsagesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCaCaIdSignCertificatePostRequestExtendedKeyUsagesEnum</b></span>
                        <a href="#ApiV1PkiCaCaIdSignCertificatePostRequestExtendedKeyUsagesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ClientAuth: &#x27;clientAuth&#x27;,
    ServerAuth: &#x27;serverAuth&#x27;,
    CodeSigning: &#x27;codeSigning&#x27;,
    EmailProtection: &#x27;emailProtection&#x27;,
    TimeStamping: &#x27;timeStamping&#x27;,
    OcspSigning: &#x27;ocspSigning&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCaCaIdSignCertificatePostRequestKeyUsagesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCaCaIdSignCertificatePostRequestKeyUsagesEnum</b></span>
                        <a href="#ApiV1PkiCaCaIdSignCertificatePostRequestKeyUsagesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    DigitalSignature: &#x27;digitalSignature&#x27;,
    KeyEncipherment: &#x27;keyEncipherment&#x27;,
    NonRepudiation: &#x27;nonRepudiation&#x27;,
    DataEncipherment: &#x27;dataEncipherment&#x27;,
    KeyAgreement: &#x27;keyAgreement&#x27;,
    KeyCertSign: &#x27;keyCertSign&#x27;,
    CRlSign: &#x27;cRLSign&#x27;,
    EncipherOnly: &#x27;encipherOnly&#x27;,
    DecipherOnly: &#x27;decipherOnly&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCaPostRequestKeyAlgorithmEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCaPostRequestKeyAlgorithmEnum</b></span>
                        <a href="#ApiV1PkiCaPostRequestKeyAlgorithmEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Rsa2048: &#x27;RSA_2048&#x27;,
    Rsa4096: &#x27;RSA_4096&#x27;,
    EcPrime256v1: &#x27;EC_prime256v1&#x27;,
    EcSecp384r1: &#x27;EC_secp384r1&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCaPostRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCaPostRequestTypeEnum</b></span>
                        <a href="#ApiV1PkiCaPostRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Root: &#x27;root&#x27;,
    Intermediate: &#x27;intermediate&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCertificatesIssueCertificatePostRequestExtendedKeyUsagesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCertificatesIssueCertificatePostRequestExtendedKeyUsagesEnum</b></span>
                        <a href="#ApiV1PkiCertificatesIssueCertificatePostRequestExtendedKeyUsagesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ClientAuth: &#x27;clientAuth&#x27;,
    ServerAuth: &#x27;serverAuth&#x27;,
    CodeSigning: &#x27;codeSigning&#x27;,
    EmailProtection: &#x27;emailProtection&#x27;,
    TimeStamping: &#x27;timeStamping&#x27;,
    OcspSigning: &#x27;ocspSigning&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCertificatesIssueCertificatePostRequestKeyUsagesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCertificatesIssueCertificatePostRequestKeyUsagesEnum</b></span>
                        <a href="#ApiV1PkiCertificatesIssueCertificatePostRequestKeyUsagesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    DigitalSignature: &#x27;digitalSignature&#x27;,
    KeyEncipherment: &#x27;keyEncipherment&#x27;,
    NonRepudiation: &#x27;nonRepudiation&#x27;,
    DataEncipherment: &#x27;dataEncipherment&#x27;,
    KeyAgreement: &#x27;keyAgreement&#x27;,
    KeyCertSign: &#x27;keyCertSign&#x27;,
    CRlSign: &#x27;cRLSign&#x27;,
    EncipherOnly: &#x27;encipherOnly&#x27;,
    DecipherOnly: &#x27;decipherOnly&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCertificatesSerialNumberRevokePostRequestRevocationReasonEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCertificatesSerialNumberRevokePostRequestRevocationReasonEnum</b></span>
                        <a href="#ApiV1PkiCertificatesSerialNumberRevokePostRequestRevocationReasonEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Unspecified: &#x27;UNSPECIFIED&#x27;,
    KeyCompromise: &#x27;KEY_COMPROMISE&#x27;,
    CaCompromise: &#x27;CA_COMPROMISE&#x27;,
    AffiliationChanged: &#x27;AFFILIATION_CHANGED&#x27;,
    Superseded: &#x27;SUPERSEDED&#x27;,
    CessationOfOperation: &#x27;CESSATION_OF_OPERATION&#x27;,
    CertificateHold: &#x27;CERTIFICATE_HOLD&#x27;,
    PrivilegeWithdrawn: &#x27;PRIVILEGE_WITHDRAWN&#x27;,
    AACompromise: &#x27;A_A_COMPROMISE&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCertificatesSignCertificatePostRequestExtendedKeyUsagesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCertificatesSignCertificatePostRequestExtendedKeyUsagesEnum</b></span>
                        <a href="#ApiV1PkiCertificatesSignCertificatePostRequestExtendedKeyUsagesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ClientAuth: &#x27;clientAuth&#x27;,
    ServerAuth: &#x27;serverAuth&#x27;,
    CodeSigning: &#x27;codeSigning&#x27;,
    EmailProtection: &#x27;emailProtection&#x27;,
    TimeStamping: &#x27;timeStamping&#x27;,
    OcspSigning: &#x27;ocspSigning&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCertificatesSignCertificatePostRequestKeyUsagesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCertificatesSignCertificatePostRequestKeyUsagesEnum</b></span>
                        <a href="#ApiV1PkiCertificatesSignCertificatePostRequestKeyUsagesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    DigitalSignature: &#x27;digitalSignature&#x27;,
    KeyEncipherment: &#x27;keyEncipherment&#x27;,
    NonRepudiation: &#x27;nonRepudiation&#x27;,
    DataEncipherment: &#x27;dataEncipherment&#x27;,
    KeyAgreement: &#x27;keyAgreement&#x27;,
    KeyCertSign: &#x27;keyCertSign&#x27;,
    CRlSign: &#x27;cRLSign&#x27;,
    EncipherOnly: &#x27;encipherOnly&#x27;,
    DecipherOnly: &#x27;decipherOnly&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequestExtendedKeyUsagesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequestExtendedKeyUsagesEnum</b></span>
                        <a href="#ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequestExtendedKeyUsagesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ClientAuth: &#x27;clientAuth&#x27;,
    ServerAuth: &#x27;serverAuth&#x27;,
    CodeSigning: &#x27;codeSigning&#x27;,
    EmailProtection: &#x27;emailProtection&#x27;,
    TimeStamping: &#x27;timeStamping&#x27;,
    OcspSigning: &#x27;ocspSigning&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequestKeyUsagesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequestKeyUsagesEnum</b></span>
                        <a href="#ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequestKeyUsagesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    DigitalSignature: &#x27;digitalSignature&#x27;,
    KeyEncipherment: &#x27;keyEncipherment&#x27;,
    NonRepudiation: &#x27;nonRepudiation&#x27;,
    DataEncipherment: &#x27;dataEncipherment&#x27;,
    KeyAgreement: &#x27;keyAgreement&#x27;,
    KeyCertSign: &#x27;keyCertSign&#x27;,
    CRlSign: &#x27;cRLSign&#x27;,
    EncipherOnly: &#x27;encipherOnly&#x27;,
    DecipherOnly: &#x27;decipherOnly&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCertificateTemplatesPostRequestExtendedKeyUsagesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCertificateTemplatesPostRequestExtendedKeyUsagesEnum</b></span>
                        <a href="#ApiV1PkiCertificateTemplatesPostRequestExtendedKeyUsagesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ClientAuth: &#x27;clientAuth&#x27;,
    ServerAuth: &#x27;serverAuth&#x27;,
    CodeSigning: &#x27;codeSigning&#x27;,
    EmailProtection: &#x27;emailProtection&#x27;,
    TimeStamping: &#x27;timeStamping&#x27;,
    OcspSigning: &#x27;ocspSigning&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCertificateTemplatesPostRequestKeyUsagesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCertificateTemplatesPostRequestKeyUsagesEnum</b></span>
                        <a href="#ApiV1PkiCertificateTemplatesPostRequestKeyUsagesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    DigitalSignature: &#x27;digitalSignature&#x27;,
    KeyEncipherment: &#x27;keyEncipherment&#x27;,
    NonRepudiation: &#x27;nonRepudiation&#x27;,
    DataEncipherment: &#x27;dataEncipherment&#x27;,
    KeyAgreement: &#x27;keyAgreement&#x27;,
    KeyCertSign: &#x27;keyCertSign&#x27;,
    CRlSign: &#x27;cRLSign&#x27;,
    EncipherOnly: &#x27;encipherOnly&#x27;,
    DecipherOnly: &#x27;decipherOnly&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete200ResponseTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete200ResponseTypeEnum</b></span>
                        <a href="#ApiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete200ResponseTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Certificate: &#x27;certificate&#x27;,
    Ca: &#x27;ca&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCollectionsCollectionIdItemsGet200ResponseCollectionItemsInnerTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCollectionsCollectionIdItemsGet200ResponseCollectionItemsInnerTypeEnum</b></span>
                        <a href="#ApiV1PkiCollectionsCollectionIdItemsGet200ResponseCollectionItemsInnerTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Certificate: &#x27;certificate&#x27;,
    Ca: &#x27;ca&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCollectionsCollectionIdItemsGetTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCollectionsCollectionIdItemsGetTypeEnum</b></span>
                        <a href="#ApiV1PkiCollectionsCollectionIdItemsGetTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Certificate: &#x27;certificate&#x27;,
    Ca: &#x27;ca&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCollectionsCollectionIdItemsPost200ResponseTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCollectionsCollectionIdItemsPost200ResponseTypeEnum</b></span>
                        <a href="#ApiV1PkiCollectionsCollectionIdItemsPost200ResponseTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Certificate: &#x27;certificate&#x27;,
    Ca: &#x27;ca&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1PkiCollectionsCollectionIdItemsPostRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1PkiCollectionsCollectionIdItemsPostRequestTypeEnum</b></span>
                        <a href="#ApiV1PkiCollectionsCollectionIdItemsPostRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Certificate: &#x27;certificate&#x27;,
    Ca: &#x27;ca&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretApprovalRequestsGetStatusEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretApprovalRequestsGetStatusEnum</b></span>
                        <a href="#ApiV1SecretApprovalRequestsGetStatusEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Open: &#x27;open&#x27;,
    Close: &#x27;close&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretApprovalRequestsIdReviewPostRequestStatusEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretApprovalRequestsIdReviewPostRequestStatusEnum</b></span>
                        <a href="#ApiV1SecretApprovalRequestsIdReviewPostRequestStatusEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Approved: &#x27;approved&#x27;,
    Rejected: &#x27;rejected&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretApprovalRequestsIdStatusPostRequestStatusEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretApprovalRequestsIdStatusPostRequestStatusEnum</b></span>
                        <a href="#ApiV1SecretApprovalRequestsIdStatusPostRequestStatusEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Open: &#x27;open&#x27;,
    Close: &#x27;close&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretApprovalsGet200ResponseApprovalsInnerApproversInnerTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretApprovalsGet200ResponseApprovalsInnerApproversInnerTypeEnum</b></span>
                        <a href="#ApiV1SecretApprovalsGet200ResponseApprovalsInnerApproversInnerTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Group: &#x27;group&#x27;,
    User: &#x27;user&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretApprovalsPostRequestApproversInnerAnyOf1TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretApprovalsPostRequestApproversInnerAnyOf1TypeEnum</b></span>
                        <a href="#ApiV1SecretApprovalsPostRequestApproversInnerAnyOf1TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    User: &#x27;user&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretApprovalsPostRequestApproversInnerAnyOfTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretApprovalsPostRequestApproversInnerAnyOfTypeEnum</b></span>
                        <a href="#ApiV1SecretApprovalsPostRequestApproversInnerAnyOfTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Group: &#x27;group&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretApprovalsPostRequestApproversInnerTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretApprovalsPostRequestApproversInnerTypeEnum</b></span>
                        <a href="#ApiV1SecretApprovalsPostRequestApproversInnerTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Group: &#x27;group&#x27;,
    User: &#x27;user&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretApprovalsPostRequestEnforcementLevelEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretApprovalsPostRequestEnforcementLevelEnum</b></span>
                        <a href="#ApiV1SecretApprovalsPostRequestEnforcementLevelEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Hard: &#x27;hard&#x27;,
    Soft: &#x27;soft&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretApprovalsSapIdGet200ResponseApprovalApproversInnerTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretApprovalsSapIdGet200ResponseApprovalApproversInnerTypeEnum</b></span>
                        <a href="#ApiV1SecretApprovalsSapIdGet200ResponseApprovalApproversInnerTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Group: &#x27;group&#x27;,
    User: &#x27;user&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretApprovalsSapIdPatchRequestEnforcementLevelEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretApprovalsSapIdPatchRequestEnforcementLevelEnum</b></span>
                        <a href="#ApiV1SecretApprovalsSapIdPatchRequestEnforcementLevelEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Hard: &#x27;hard&#x27;,
    Soft: &#x27;soft&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretScanningOrganizationOrganizationIdRisksExportGetResolvedStatusEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretScanningOrganizationOrganizationIdRisksExportGetResolvedStatusEnum</b></span>
                        <a href="#ApiV1SecretScanningOrganizationOrganizationIdRisksExportGetResolvedStatusEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    All: &#x27;all&#x27;,
    Resolved: &#x27;resolved&#x27;,
    Unresolved: &#x27;unresolved&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderByEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderByEnum</b></span>
                        <a href="#ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderByEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    CreatedAt: &#x27;createdAt&#x27;,
    Name: &#x27;name&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderDirectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderDirectionEnum</b></span>
                        <a href="#ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderDirectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Asc: &#x27;asc&#x27;,
    Desc: &#x27;desc&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretScanningOrganizationOrganizationIdRisksGetResolvedStatusEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretScanningOrganizationOrganizationIdRisksGetResolvedStatusEnum</b></span>
                        <a href="#ApiV1SecretScanningOrganizationOrganizationIdRisksGetResolvedStatusEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    All: &#x27;all&#x27;,
    Resolved: &#x27;resolved&#x27;,
    Unresolved: &#x27;unresolved&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequestStatusEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequestStatusEnum</b></span>
                        <a href="#ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequestStatusEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ResolvedFalsePositive: &#x27;RESOLVED_FALSE_POSITIVE&#x27;,
    ResolvedRevoked: &#x27;RESOLVED_REVOKED&#x27;,
    ResolvedNotRevoked: &#x27;RESOLVED_NOT_REVOKED&#x27;,
    Unresolved: &#x27;UNRESOLVED&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSharingRequestsPostRequestAccessTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSharingRequestsPostRequestAccessTypeEnum</b></span>
                        <a href="#ApiV1SecretSharingRequestsPostRequestAccessTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Anyone: &#x27;anyone&#x27;,
    Organization: &#x27;organization&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSharingSharedPostRequestAccessTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSharingSharedPostRequestAccessTypeEnum</b></span>
                        <a href="#ApiV1SecretSharingSharedPostRequestAccessTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Anyone: &#x27;anyone&#x27;,
    Organization: &#x27;organization&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretsSecretNameAccessListGet200ResponseGroupsInnerAllowedActionsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretsSecretNameAccessListGet200ResponseGroupsInnerAllowedActionsEnum</b></span>
                        <a href="#ApiV1SecretsSecretNameAccessListGet200ResponseGroupsInnerAllowedActionsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Read: &#x27;read&#x27;,
    DescribeSecret: &#x27;describeSecret&#x27;,
    ReadValue: &#x27;readValue&#x27;,
    Create: &#x27;create&#x27;,
    Edit: &#x27;edit&#x27;,
    Delete: &#x27;delete&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsAwsParameterStoreSyncIdDeleteRemoveSecretsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsAwsParameterStoreSyncIdDeleteRemoveSecretsEnum</b></span>
                        <a href="#ApiV1SecretSyncsAwsParameterStoreSyncIdDeleteRemoveSecretsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPostImportBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPostImportBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPostImportBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    PrioritizeSource: &#x27;prioritize-source&#x27;,
    PrioritizeDestination: &#x27;prioritize-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsAwsSecretsManagerSyncIdDeleteRemoveSecretsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsAwsSecretsManagerSyncIdDeleteRemoveSecretsEnum</b></span>
                        <a href="#ApiV1SecretSyncsAwsSecretsManagerSyncIdDeleteRemoveSecretsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPostImportBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPostImportBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPostImportBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    PrioritizeSource: &#x27;prioritize-source&#x27;,
    PrioritizeDestination: &#x27;prioritize-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsAzureAppConfigurationSyncIdDeleteRemoveSecretsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsAzureAppConfigurationSyncIdDeleteRemoveSecretsEnum</b></span>
                        <a href="#ApiV1SecretSyncsAzureAppConfigurationSyncIdDeleteRemoveSecretsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPostImportBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPostImportBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPostImportBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    PrioritizeSource: &#x27;prioritize-source&#x27;,
    PrioritizeDestination: &#x27;prioritize-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsAzureKeyVaultSyncIdDeleteRemoveSecretsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsAzureKeyVaultSyncIdDeleteRemoveSecretsEnum</b></span>
                        <a href="#ApiV1SecretSyncsAzureKeyVaultSyncIdDeleteRemoveSecretsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPostImportBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPostImportBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPostImportBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    PrioritizeSource: &#x27;prioritize-source&#x27;,
    PrioritizeDestination: &#x27;prioritize-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsDatabricksSyncIdDeleteRemoveSecretsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsDatabricksSyncIdDeleteRemoveSecretsEnum</b></span>
                        <a href="#ApiV1SecretSyncsDatabricksSyncIdDeleteRemoveSecretsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsDatabricksSyncIdImportSecretsPostImportBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsDatabricksSyncIdImportSecretsPostImportBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsDatabricksSyncIdImportSecretsPostImportBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    PrioritizeSource: &#x27;prioritize-source&#x27;,
    PrioritizeDestination: &#x27;prioritize-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGcpSecretManagerSyncIdDeleteRemoveSecretsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGcpSecretManagerSyncIdDeleteRemoveSecretsEnum</b></span>
                        <a href="#ApiV1SecretSyncsGcpSecretManagerSyncIdDeleteRemoveSecretsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPostImportBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPostImportBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPostImportBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    PrioritizeSource: &#x27;prioritize-source&#x27;,
    PrioritizeDestination: &#x27;prioritize-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigAllOfAnyOf1MappingBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigAllOfAnyOf1MappingBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigAllOfAnyOf1MappingBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ManyToOne: &#x27;many-to-one&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigAllOfAnyOfMappingBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigAllOfAnyOfMappingBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigAllOfAnyOfMappingBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    OneToOne: &#x27;one-to-one&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigMappingBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigMappingBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigMappingBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ManyToOne: &#x27;many-to-one&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigRegionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigRegionEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationConfigRegionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    UsEast1: &#x27;us-east-1&#x27;,
    UsEast2: &#x27;us-east-2&#x27;,
    UsWest1: &#x27;us-west-1&#x27;,
    UsWest2: &#x27;us-west-2&#x27;,
    UsGovEast1: &#x27;us-gov-east-1&#x27;,
    UsGovWest1: &#x27;us-gov-west-1&#x27;,
    AfSouth1: &#x27;af-south-1&#x27;,
    ApEast1: &#x27;ap-east-1&#x27;,
    ApSouth1: &#x27;ap-south-1&#x27;,
    ApSouth2: &#x27;ap-south-2&#x27;,
    ApNortheast1: &#x27;ap-northeast-1&#x27;,
    ApNortheast2: &#x27;ap-northeast-2&#x27;,
    ApNortheast3: &#x27;ap-northeast-3&#x27;,
    ApSoutheast1: &#x27;ap-southeast-1&#x27;,
    ApSoutheast2: &#x27;ap-southeast-2&#x27;,
    ApSoutheast3: &#x27;ap-southeast-3&#x27;,
    ApSoutheast4: &#x27;ap-southeast-4&#x27;,
    CaCentral1: &#x27;ca-central-1&#x27;,
    EuCentral1: &#x27;eu-central-1&#x27;,
    EuCentral2: &#x27;eu-central-2&#x27;,
    EuWest1: &#x27;eu-west-1&#x27;,
    EuWest2: &#x27;eu-west-2&#x27;,
    EuWest3: &#x27;eu-west-3&#x27;,
    EuSouth1: &#x27;eu-south-1&#x27;,
    EuSouth2: &#x27;eu-south-2&#x27;,
    EuNorth1: &#x27;eu-north-1&#x27;,
    MeSouth1: &#x27;me-south-1&#x27;,
    MeCentral1: &#x27;me-central-1&#x27;,
    SaEast1: &#x27;sa-east-1&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AwsSecretsManager: &#x27;aws-secrets-manager&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1SyncOptionsInitialSyncBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1SyncOptionsInitialSyncBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf1SyncOptionsInitialSyncBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    OverwriteDestination: &#x27;overwrite-destination&#x27;,
    ImportPrioritizeSource: &#x27;import-prioritize-source&#x27;,
    ImportPrioritizeDestination: &#x27;import-prioritize-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOf1ScopeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOf1ScopeEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOf1ScopeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Repository: &#x27;repository&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOf2ScopeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOf2ScopeEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOf2ScopeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    RepositoryEnvironment: &#x27;repository-environment&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOfScopeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOfScopeEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOfScopeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Organization: &#x27;organization&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOfVisibilityEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOfVisibilityEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigAnyOfVisibilityEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    All: &#x27;all&#x27;,
    Private: &#x27;private&#x27;,
    Selected: &#x27;selected&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigScopeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigScopeEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigScopeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    RepositoryEnvironment: &#x27;repository-environment&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigVisibilityEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigVisibilityEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationConfigVisibilityEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    All: &#x27;all&#x27;,
    Private: &#x27;private&#x27;,
    Selected: &#x27;selected&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Github: &#x27;github&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2SyncOptionsInitialSyncBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2SyncOptionsInitialSyncBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf2SyncOptionsInitialSyncBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    OverwriteDestination: &#x27;overwrite-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3DestinationConfigScopeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3DestinationConfigScopeEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3DestinationConfigScopeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Global: &#x27;global&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    GcpSecretManager: &#x27;gcp-secret-manager&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3SyncOptionsInitialSyncBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3SyncOptionsInitialSyncBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf3SyncOptionsInitialSyncBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    OverwriteDestination: &#x27;overwrite-destination&#x27;,
    ImportPrioritizeSource: &#x27;import-prioritize-source&#x27;,
    ImportPrioritizeDestination: &#x27;import-prioritize-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf4DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf4DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf4DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureKeyVault: &#x27;azure-key-vault&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf4SyncOptionsInitialSyncBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf4SyncOptionsInitialSyncBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf4SyncOptionsInitialSyncBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    OverwriteDestination: &#x27;overwrite-destination&#x27;,
    ImportPrioritizeSource: &#x27;import-prioritize-source&#x27;,
    ImportPrioritizeDestination: &#x27;import-prioritize-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf5DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf5DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf5DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureAppConfiguration: &#x27;azure-app-configuration&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf5SyncOptionsInitialSyncBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf5SyncOptionsInitialSyncBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf5SyncOptionsInitialSyncBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    OverwriteDestination: &#x27;overwrite-destination&#x27;,
    ImportPrioritizeSource: &#x27;import-prioritize-source&#x27;,
    ImportPrioritizeDestination: &#x27;import-prioritize-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf6DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf6DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf6DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Databricks: &#x27;databricks&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf6SyncOptionsInitialSyncBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf6SyncOptionsInitialSyncBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf6SyncOptionsInitialSyncBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    OverwriteDestination: &#x27;overwrite-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigAnyOf1ScopeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigAnyOf1ScopeEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigAnyOf1ScopeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Environment: &#x27;environment&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigAnyOfScopeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigAnyOfScopeEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigAnyOfScopeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Application: &#x27;application&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigScopeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigScopeEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationConfigScopeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Environment: &#x27;environment&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7SyncOptionsInitialSyncBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7SyncOptionsInitialSyncBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOf7SyncOptionsInitialSyncBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    OverwriteDestination: &#x27;overwrite-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfDestinationConfigRegionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfDestinationConfigRegionEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfDestinationConfigRegionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    UsEast1: &#x27;us-east-1&#x27;,
    UsEast2: &#x27;us-east-2&#x27;,
    UsWest1: &#x27;us-west-1&#x27;,
    UsWest2: &#x27;us-west-2&#x27;,
    UsGovEast1: &#x27;us-gov-east-1&#x27;,
    UsGovWest1: &#x27;us-gov-west-1&#x27;,
    AfSouth1: &#x27;af-south-1&#x27;,
    ApEast1: &#x27;ap-east-1&#x27;,
    ApSouth1: &#x27;ap-south-1&#x27;,
    ApSouth2: &#x27;ap-south-2&#x27;,
    ApNortheast1: &#x27;ap-northeast-1&#x27;,
    ApNortheast2: &#x27;ap-northeast-2&#x27;,
    ApNortheast3: &#x27;ap-northeast-3&#x27;,
    ApSoutheast1: &#x27;ap-southeast-1&#x27;,
    ApSoutheast2: &#x27;ap-southeast-2&#x27;,
    ApSoutheast3: &#x27;ap-southeast-3&#x27;,
    ApSoutheast4: &#x27;ap-southeast-4&#x27;,
    CaCentral1: &#x27;ca-central-1&#x27;,
    EuCentral1: &#x27;eu-central-1&#x27;,
    EuCentral2: &#x27;eu-central-2&#x27;,
    EuWest1: &#x27;eu-west-1&#x27;,
    EuWest2: &#x27;eu-west-2&#x27;,
    EuWest3: &#x27;eu-west-3&#x27;,
    EuSouth1: &#x27;eu-south-1&#x27;,
    EuSouth2: &#x27;eu-south-2&#x27;,
    EuNorth1: &#x27;eu-north-1&#x27;,
    MeSouth1: &#x27;me-south-1&#x27;,
    MeCentral1: &#x27;me-central-1&#x27;,
    SaEast1: &#x27;sa-east-1&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfDestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfDestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfDestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AwsParameterStore: &#x27;aws-parameter-store&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfSyncOptionsInitialSyncBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfSyncOptionsInitialSyncBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerAnyOfSyncOptionsInitialSyncBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    OverwriteDestination: &#x27;overwrite-destination&#x27;,
    ImportPrioritizeSource: &#x27;import-prioritize-source&#x27;,
    ImportPrioritizeDestination: &#x27;import-prioritize-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGet200ResponseSecretSyncsInnerDestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGet200ResponseSecretSyncsInnerDestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsGet200ResponseSecretSyncsInnerDestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGithubSyncIdDeleteRemoveSecretsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGithubSyncIdDeleteRemoveSecretsEnum</b></span>
                        <a href="#ApiV1SecretSyncsGithubSyncIdDeleteRemoveSecretsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsGithubSyncIdImportSecretsPostImportBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsGithubSyncIdImportSecretsPostImportBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsGithubSyncIdImportSecretsPostImportBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    PrioritizeSource: &#x27;prioritize-source&#x27;,
    PrioritizeDestination: &#x27;prioritize-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsHumanitecSyncIdDeleteRemoveSecretsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsHumanitecSyncIdDeleteRemoveSecretsEnum</b></span>
                        <a href="#ApiV1SecretSyncsHumanitecSyncIdDeleteRemoveSecretsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsHumanitecSyncIdImportSecretsPostImportBehaviorEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsHumanitecSyncIdImportSecretsPostImportBehaviorEnum</b></span>
                        <a href="#ApiV1SecretSyncsHumanitecSyncIdImportSecretsPostImportBehaviorEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    PrioritizeSource: &#x27;prioritize-source&#x27;,
    PrioritizeDestination: &#x27;prioritize-destination&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1ConnectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1ConnectionEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1ConnectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aws: &#x27;aws&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AwsSecretsManager: &#x27;aws-secrets-manager&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1NameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1NameEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf1NameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AwsSecretsManager: &#x27;AWS Secrets Manager&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2ConnectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2ConnectionEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2ConnectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Github: &#x27;github&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Github: &#x27;github&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2NameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2NameEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf2NameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    GitHub: &#x27;GitHub&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3ConnectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3ConnectionEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3ConnectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Gcp: &#x27;gcp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    GcpSecretManager: &#x27;gcp-secret-manager&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3NameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3NameEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf3NameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    GcpSecretManager: &#x27;GCP Secret Manager&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4ConnectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4ConnectionEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4ConnectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureKeyVault: &#x27;azure-key-vault&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureKeyVault: &#x27;azure-key-vault&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4NameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4NameEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf4NameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureKeyVault: &#x27;Azure Key Vault&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5ConnectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5ConnectionEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5ConnectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureAppConfiguration: &#x27;azure-app-configuration&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureAppConfiguration: &#x27;azure-app-configuration&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5NameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5NameEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf5NameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AzureAppConfiguration: &#x27;Azure App Configuration&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6ConnectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6ConnectionEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6ConnectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Databricks: &#x27;databricks&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Databricks: &#x27;databricks&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6NameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6NameEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf6NameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Databricks: &#x27;Databricks&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7ConnectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7ConnectionEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7ConnectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7DestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7DestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7DestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7NameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7NameEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOf7NameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;Humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfConnectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfConnectionEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfConnectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Aws: &#x27;aws&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfDestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfDestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfDestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AwsParameterStore: &#x27;aws-parameter-store&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfNameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfNameEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerAnyOfNameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AwsParameterStore: &#x27;AWS Parameter Store&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerConnectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerConnectionEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerConnectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerDestinationEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerDestinationEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerDestinationEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerNameEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerNameEnum</b></span>
                        <a href="#ApiV1SecretSyncsOptionsGet200ResponseSecretSyncOptionsInnerNameEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Humanitec: &#x27;Humanitec&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SshCaPostRequestKeyAlgorithmEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SshCaPostRequestKeyAlgorithmEnum</b></span>
                        <a href="#ApiV1SshCaPostRequestKeyAlgorithmEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Rsa2048: &#x27;RSA_2048&#x27;,
    Rsa4096: &#x27;RSA_4096&#x27;,
    EcPrime256v1: &#x27;EC_prime256v1&#x27;,
    EcSecp384r1: &#x27;EC_secp384r1&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SshCaSshCaIdPatchRequestStatusEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SshCaSshCaIdPatchRequestStatusEnum</b></span>
                        <a href="#ApiV1SshCaSshCaIdPatchRequestStatusEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Active: &#x27;active&#x27;,
    Disabled: &#x27;disabled&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SshCertificatesIssuePost200ResponseKeyAlgorithmEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SshCertificatesIssuePost200ResponseKeyAlgorithmEnum</b></span>
                        <a href="#ApiV1SshCertificatesIssuePost200ResponseKeyAlgorithmEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Rsa2048: &#x27;RSA_2048&#x27;,
    Rsa4096: &#x27;RSA_4096&#x27;,
    EcPrime256v1: &#x27;EC_prime256v1&#x27;,
    EcSecp384r1: &#x27;EC_secp384r1&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SshCertificatesIssuePostRequestCertTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SshCertificatesIssuePostRequestCertTypeEnum</b></span>
                        <a href="#ApiV1SshCertificatesIssuePostRequestCertTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    User: &#x27;user&#x27;,
    Host: &#x27;host&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SshCertificatesIssuePostRequestKeyAlgorithmEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SshCertificatesIssuePostRequestKeyAlgorithmEnum</b></span>
                        <a href="#ApiV1SshCertificatesIssuePostRequestKeyAlgorithmEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Rsa2048: &#x27;RSA_2048&#x27;,
    Rsa4096: &#x27;RSA_4096&#x27;,
    EcPrime256v1: &#x27;EC_prime256v1&#x27;,
    EcSecp384r1: &#x27;EC_secp384r1&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SshCertificatesSignPostRequestCertTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SshCertificatesSignPostRequestCertTypeEnum</b></span>
                        <a href="#ApiV1SshCertificatesSignPostRequestCertTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    User: &#x27;user&#x27;,
    Host: &#x27;host&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SshCertificateTemplatesCertificateTemplateIdPatchRequestStatusEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SshCertificateTemplatesCertificateTemplateIdPatchRequestStatusEnum</b></span>
                        <a href="#ApiV1SshCertificateTemplatesCertificateTemplateIdPatchRequestStatusEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Active: &#x27;active&#x27;,
    Disabled: &#x27;disabled&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SsoConfigPatchRequestAuthProviderEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SsoConfigPatchRequestAuthProviderEnum</b></span>
                        <a href="#ApiV1SsoConfigPatchRequestAuthProviderEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    OktaSaml: &#x27;okta-saml&#x27;,
    AzureSaml: &#x27;azure-saml&#x27;,
    JumpcloudSaml: &#x27;jumpcloud-saml&#x27;,
    GoogleSaml: &#x27;google-saml&#x27;,
    KeycloakSaml: &#x27;keycloak-saml&#x27;,
    Auth0Saml: &#x27;auth0-saml&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SsoConfigPostRequestAuthProviderEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SsoConfigPostRequestAuthProviderEnum</b></span>
                        <a href="#ApiV1SsoConfigPostRequestAuthProviderEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    OktaSaml: &#x27;okta-saml&#x27;,
    AzureSaml: &#x27;azure-saml&#x27;,
    JumpcloudSaml: &#x27;jumpcloud-saml&#x27;,
    GoogleSaml: &#x27;google-saml&#x27;,
    KeycloakSaml: &#x27;keycloak-saml&#x27;,
    Auth0Saml: &#x27;auth0-saml&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SsoOidcConfigPatchRequestConfigurationTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SsoOidcConfigPatchRequestConfigurationTypeEnum</b></span>
                        <a href="#ApiV1SsoOidcConfigPatchRequestConfigurationTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Custom: &#x27;custom&#x27;,
    DiscoveryUrl: &#x27;discoveryURL&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1SsoOidcConfigPostRequestConfigurationTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1SsoOidcConfigPostRequestConfigurationTypeEnum</b></span>
                        <a href="#ApiV1SsoOidcConfigPostRequestConfigurationTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Custom: &#x27;custom&#x27;,
    DiscoveryUrl: &#x27;discoveryURL&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf1SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf1SubjectEnum</b></span>
                        <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf1SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SecretFolders: &#x27;secret-folders&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf2SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf2SubjectEnum</b></span>
                        <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf2SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SecretImports: &#x27;secret-imports&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf3SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf3SubjectEnum</b></span>
                        <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf3SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    DynamicSecrets: &#x27;dynamic-secrets&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf4SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf4SubjectEnum</b></span>
                        <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOf4SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Identity: &#x27;identity&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOfSubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOfSubjectEnum</b></span>
                        <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerAnyOfSubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Secrets: &#x27;secrets&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerSubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerSubjectEnum</b></span>
                        <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestPermissionsInnerSubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Kmip: &#x27;kmip&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1UserProjectAdditionalPrivilegePostRequestTypeAnyOf1TemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1UserProjectAdditionalPrivilegePostRequestTypeAnyOf1TemporaryModeEnum</b></span>
                        <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestTypeAnyOf1TemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1UserProjectAdditionalPrivilegePostRequestTypeTemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1UserProjectAdditionalPrivilegePostRequestTypeTemporaryModeEnum</b></span>
                        <a href="#ApiV1UserProjectAdditionalPrivilegePostRequestTypeTemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequestTypeAnyOf1TemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequestTypeAnyOf1TemporaryModeEnum</b></span>
                        <a href="#ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequestTypeAnyOf1TemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequestTypeTemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequestTypeTemporaryModeEnum</b></span>
                        <a href="#ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequestTypeTemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WebhooksPostRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WebhooksPostRequestTypeEnum</b></span>
                        <a href="#ApiV1WebhooksPostRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    General: &#x27;general&#x27;,
    Slack: &#x27;slack&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceGetIncludeRolesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceGetIncludeRolesEnum</b></span>
                        <a href="#ApiV1WorkspaceGetIncludeRolesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceGetTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceGetTypeEnum</b></span>
                        <a href="#ApiV1WorkspaceGetTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SecretManager: &#x27;secret-manager&#x27;,
    Kms: &#x27;kms&#x27;,
    CertManager: &#x27;cert-manager&#x27;,
    Ssh: &#x27;ssh&#x27;,
    All: &#x27;all&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf10SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf10SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf10SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Webhooks: &#x27;webhooks&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf11SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf11SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf11SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    ServiceTokens: &#x27;service-tokens&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf12SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf12SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf12SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Settings: &#x27;settings&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf13SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf13SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf13SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Environments: &#x27;environments&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf14SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf14SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf14SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Tags: &#x27;tags&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf15SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf15SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf15SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    AuditLogs: &#x27;audit-logs&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf16SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf16SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf16SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    IpAllowlist: &#x27;ip-allowlist&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf17SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf17SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf17SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    CertificateAuthorities: &#x27;certificate-authorities&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf18SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf18SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf18SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Certificates: &#x27;certificates&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf19SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf19SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf19SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    CertificateTemplates: &#x27;certificate-templates&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf1SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf1SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf1SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SecretFolders: &#x27;secret-folders&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf20SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf20SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf20SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SshCertificateAuthorities: &#x27;ssh-certificate-authorities&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf21SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf21SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf21SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SshCertificates: &#x27;ssh-certificates&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf22SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf22SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf22SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SshCertificateTemplates: &#x27;ssh-certificate-templates&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf23SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf23SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf23SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    PkiAlerts: &#x27;pki-alerts&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf24SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf24SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf24SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    PkiCollections: &#x27;pki-collections&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf25SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf25SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf25SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Workspace: &#x27;workspace&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf26SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf26SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf26SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Kms: &#x27;kms&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf27SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf27SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf27SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Cmek: &#x27;cmek&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf28SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf28SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf28SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SecretSyncs: &#x27;secret-syncs&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf29SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf29SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf29SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Kmip: &#x27;kmip&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf2SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf2SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf2SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Identity: &#x27;identity&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf3SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf3SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf3SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SecretApproval: &#x27;secret-approval&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf4SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf4SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf4SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SecretRotation: &#x27;secret-rotation&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf5SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf5SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf5SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SecretRollback: &#x27;secret-rollback&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf6SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf6SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf6SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Member: &#x27;member&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf7SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf7SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf7SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Groups: &#x27;groups&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf8SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf8SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf8SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Role: &#x27;role&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf9SubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf9SubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOf9SubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Integrations: &#x27;integrations&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOfSubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOfSubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerAnyOfSubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Secrets: &#x27;secrets&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerSubjectEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerSubjectEnum</b></span>
                        <a href="#ApiV1WorkspaceProjectSlugRolesPostRequestPermissionsInnerSubjectEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Kmip: &#x27;kmip&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceWorkspaceIdAuditLogsGetEventTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceWorkspaceIdAuditLogsGetEventTypeEnum</b></span>
                        <a href="#ApiV1WorkspaceWorkspaceIdAuditLogsGetEventTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    GetSecrets: &#x27;get-secrets&#x27;,
    GetSecret: &#x27;get-secret&#x27;,
    RevealSecret: &#x27;reveal-secret&#x27;,
    CreateSecret: &#x27;create-secret&#x27;,
    CreateSecrets: &#x27;create-secrets&#x27;,
    UpdateSecret: &#x27;update-secret&#x27;,
    UpdateSecrets: &#x27;update-secrets&#x27;,
    MoveSecrets: &#x27;move-secrets&#x27;,
    DeleteSecret: &#x27;delete-secret&#x27;,
    DeleteSecrets: &#x27;delete-secrets&#x27;,
    GetWorkspaceKey: &#x27;get-workspace-key&#x27;,
    AuthorizeIntegration: &#x27;authorize-integration&#x27;,
    UpdateIntegrationAuth: &#x27;update-integration-auth&#x27;,
    UnauthorizeIntegration: &#x27;unauthorize-integration&#x27;,
    CreateIntegration: &#x27;create-integration&#x27;,
    DeleteIntegration: &#x27;delete-integration&#x27;,
    ManualSyncIntegration: &#x27;manual-sync-integration&#x27;,
    AddTrustedIp: &#x27;add-trusted-ip&#x27;,
    UpdateTrustedIp: &#x27;update-trusted-ip&#x27;,
    DeleteTrustedIp: &#x27;delete-trusted-ip&#x27;,
    CreateServiceToken: &#x27;create-service-token&#x27;,
    DeleteServiceToken: &#x27;delete-service-token&#x27;,
    CreateIdentity: &#x27;create-identity&#x27;,
    UpdateIdentity: &#x27;update-identity&#x27;,
    DeleteIdentity: &#x27;delete-identity&#x27;,
    LoginIdentityUniversalAuth: &#x27;login-identity-universal-auth&#x27;,
    AddIdentityUniversalAuth: &#x27;add-identity-universal-auth&#x27;,
    UpdateIdentityUniversalAuth: &#x27;update-identity-universal-auth&#x27;,
    GetIdentityUniversalAuth: &#x27;get-identity-universal-auth&#x27;,
    RevokeIdentityUniversalAuth: &#x27;revoke-identity-universal-auth&#x27;,
    CreateTokenIdentityTokenAuth: &#x27;create-token-identity-token-auth&#x27;,
    UpdateTokenIdentityTokenAuth: &#x27;update-token-identity-token-auth&#x27;,
    GetTokensIdentityTokenAuth: &#x27;get-tokens-identity-token-auth&#x27;,
    AddIdentityTokenAuth: &#x27;add-identity-token-auth&#x27;,
    UpdateIdentityTokenAuth: &#x27;update-identity-token-auth&#x27;,
    GetIdentityTokenAuth: &#x27;get-identity-token-auth&#x27;,
    RevokeIdentityTokenAuth: &#x27;revoke-identity-token-auth&#x27;,
    LoginIdentityKubernetesAuth: &#x27;login-identity-kubernetes-auth&#x27;,
    AddIdentityKubernetesAuth: &#x27;add-identity-kubernetes-auth&#x27;,
    UpdateIdentityKubernetesAuth: &#x27;update-identity-kubernetes-auth&#x27;,
    GetIdentityKubernetesAuth: &#x27;get-identity-kubernetes-auth&#x27;,
    RevokeIdentityKubernetesAuth: &#x27;revoke-identity-kubernetes-auth&#x27;,
    LoginIdentityOidcAuth: &#x27;login-identity-oidc-auth&#x27;,
    AddIdentityOidcAuth: &#x27;add-identity-oidc-auth&#x27;,
    UpdateIdentityOidcAuth: &#x27;update-identity-oidc-auth&#x27;,
    GetIdentityOidcAuth: &#x27;get-identity-oidc-auth&#x27;,
    RevokeIdentityOidcAuth: &#x27;revoke-identity-oidc-auth&#x27;,
    LoginIdentityJwtAuth: &#x27;login-identity-jwt-auth&#x27;,
    AddIdentityJwtAuth: &#x27;add-identity-jwt-auth&#x27;,
    UpdateIdentityJwtAuth: &#x27;update-identity-jwt-auth&#x27;,
    GetIdentityJwtAuth: &#x27;get-identity-jwt-auth&#x27;,
    RevokeIdentityJwtAuth: &#x27;revoke-identity-jwt-auth&#x27;,
    CreateIdentityUniversalAuthClientSecret: &#x27;create-identity-universal-auth-client-secret&#x27;,
    RevokeIdentityUniversalAuthClientSecret: &#x27;revoke-identity-universal-auth-client-secret&#x27;,
    GetIdentityUniversalAuthClientSecret: &#x27;get-identity-universal-auth-client-secret&#x27;,
    GetIdentityUniversalAuthClientSecretById: &#x27;get-identity-universal-auth-client-secret-by-id&#x27;,
    LoginIdentityGcpAuth: &#x27;login-identity-gcp-auth&#x27;,
    AddIdentityGcpAuth: &#x27;add-identity-gcp-auth&#x27;,
    UpdateIdentityGcpAuth: &#x27;update-identity-gcp-auth&#x27;,
    RevokeIdentityGcpAuth: &#x27;revoke-identity-gcp-auth&#x27;,
    GetIdentityGcpAuth: &#x27;get-identity-gcp-auth&#x27;,
    LoginIdentityAwsAuth: &#x27;login-identity-aws-auth&#x27;,
    AddIdentityAwsAuth: &#x27;add-identity-aws-auth&#x27;,
    UpdateIdentityAwsAuth: &#x27;update-identity-aws-auth&#x27;,
    RevokeIdentityAwsAuth: &#x27;revoke-identity-aws-auth&#x27;,
    GetIdentityAwsAuth: &#x27;get-identity-aws-auth&#x27;,
    LoginIdentityAzureAuth: &#x27;login-identity-azure-auth&#x27;,
    AddIdentityAzureAuth: &#x27;add-identity-azure-auth&#x27;,
    UpdateIdentityAzureAuth: &#x27;update-identity-azure-auth&#x27;,
    GetIdentityAzureAuth: &#x27;get-identity-azure-auth&#x27;,
    RevokeIdentityAzureAuth: &#x27;revoke-identity-azure-auth&#x27;,
    CreateEnvironment: &#x27;create-environment&#x27;,
    UpdateEnvironment: &#x27;update-environment&#x27;,
    DeleteEnvironment: &#x27;delete-environment&#x27;,
    GetEnvironment: &#x27;get-environment&#x27;,
    AddWorkspaceMember: &#x27;add-workspace-member&#x27;,
    AddWorkspaceMembers: &#x27;add-workspace-members&#x27;,
    RemoveWorkspaceMember: &#x27;remove-workspace-member&#x27;,
    CreateFolder: &#x27;create-folder&#x27;,
    UpdateFolder: &#x27;update-folder&#x27;,
    DeleteFolder: &#x27;delete-folder&#x27;,
    CreateWebhook: &#x27;create-webhook&#x27;,
    UpdateWebhookStatus: &#x27;update-webhook-status&#x27;,
    DeleteWebhook: &#x27;delete-webhook&#x27;,
    GetSecretImports: &#x27;get-secret-imports&#x27;,
    GetSecretImport: &#x27;get-secret-import&#x27;,
    CreateSecretImport: &#x27;create-secret-import&#x27;,
    UpdateSecretImport: &#x27;update-secret-import&#x27;,
    DeleteSecretImport: &#x27;delete-secret-import&#x27;,
    UpdateUserWorkspaceRole: &#x27;update-user-workspace-role&#x27;,
    UpdateUserWorkspaceDeniedPermissions: &#x27;update-user-workspace-denied-permissions&#x27;,
    SecretApprovalMerged: &#x27;secret-approval-merged&#x27;,
    SecretApprovalRequest: &#x27;secret-approval-request&#x27;,
    SecretApprovalClosed: &#x27;secret-approval-closed&#x27;,
    SecretApprovalReopened: &#x27;secret-approval-reopened&#x27;,
    SecretApprovalRequestReview: &#x27;secret-approval-request-review&#x27;,
    SignSshKey: &#x27;sign-ssh-key&#x27;,
    IssueSshCreds: &#x27;issue-ssh-creds&#x27;,
    CreateSshCertificateAuthority: &#x27;create-ssh-certificate-authority&#x27;,
    GetSshCertificateAuthority: &#x27;get-ssh-certificate-authority&#x27;,
    UpdateSshCertificateAuthority: &#x27;update-ssh-certificate-authority&#x27;,
    DeleteSshCertificateAuthority: &#x27;delete-ssh-certificate-authority&#x27;,
    GetSshCertificateAuthorityCertificateTemplates: &#x27;get-ssh-certificate-authority-certificate-templates&#x27;,
    CreateSshCertificateTemplate: &#x27;create-ssh-certificate-template&#x27;,
    UpdateSshCertificateTemplate: &#x27;update-ssh-certificate-template&#x27;,
    DeleteSshCertificateTemplate: &#x27;delete-ssh-certificate-template&#x27;,
    GetSshCertificateTemplate: &#x27;get-ssh-certificate-template&#x27;,
    CreateCertificateAuthority: &#x27;create-certificate-authority&#x27;,
    GetCertificateAuthority: &#x27;get-certificate-authority&#x27;,
    UpdateCertificateAuthority: &#x27;update-certificate-authority&#x27;,
    DeleteCertificateAuthority: &#x27;delete-certificate-authority&#x27;,
    RenewCertificateAuthority: &#x27;renew-certificate-authority&#x27;,
    GetCertificateAuthorityCsr: &#x27;get-certificate-authority-csr&#x27;,
    GetCertificateAuthorityCerts: &#x27;get-certificate-authority-certs&#x27;,
    GetCertificateAuthorityCert: &#x27;get-certificate-authority-cert&#x27;,
    SignIntermediate: &#x27;sign-intermediate&#x27;,
    ImportCertificateAuthorityCert: &#x27;import-certificate-authority-cert&#x27;,
    GetCertificateAuthorityCrls: &#x27;get-certificate-authority-crls&#x27;,
    IssueCert: &#x27;issue-cert&#x27;,
    SignCert: &#x27;sign-cert&#x27;,
    GetCaCertificateTemplates: &#x27;get-ca-certificate-templates&#x27;,
    GetCert: &#x27;get-cert&#x27;,
    DeleteCert: &#x27;delete-cert&#x27;,
    RevokeCert: &#x27;revoke-cert&#x27;,
    GetCertBody: &#x27;get-cert-body&#x27;,
    CreatePkiAlert: &#x27;create-pki-alert&#x27;,
    GetPkiAlert: &#x27;get-pki-alert&#x27;,
    UpdatePkiAlert: &#x27;update-pki-alert&#x27;,
    DeletePkiAlert: &#x27;delete-pki-alert&#x27;,
    CreatePkiCollection: &#x27;create-pki-collection&#x27;,
    GetPkiCollection: &#x27;get-pki-collection&#x27;,
    UpdatePkiCollection: &#x27;update-pki-collection&#x27;,
    DeletePkiCollection: &#x27;delete-pki-collection&#x27;,
    GetPkiCollectionItems: &#x27;get-pki-collection-items&#x27;,
    AddPkiCollectionItem: &#x27;add-pki-collection-item&#x27;,
    DeletePkiCollectionItem: &#x27;delete-pki-collection-item&#x27;,
    CreateKms: &#x27;create-kms&#x27;,
    UpdateKms: &#x27;update-kms&#x27;,
    DeleteKms: &#x27;delete-kms&#x27;,
    GetKms: &#x27;get-kms&#x27;,
    UpdateProjectKms: &#x27;update-project-kms&#x27;,
    GetProjectKmsBackup: &#x27;get-project-kms-backup&#x27;,
    LoadProjectKmsBackup: &#x27;load-project-kms-backup&#x27;,
    OrgAdminAccessedProject: &#x27;org-admin-accessed-project&#x27;,
    CreateCertificateTemplate: &#x27;create-certificate-template&#x27;,
    UpdateCertificateTemplate: &#x27;update-certificate-template&#x27;,
    DeleteCertificateTemplate: &#x27;delete-certificate-template&#x27;,
    GetCertificateTemplate: &#x27;get-certificate-template&#x27;,
    CreateCertificateTemplateEstConfig: &#x27;create-certificate-template-est-config&#x27;,
    UpdateCertificateTemplateEstConfig: &#x27;update-certificate-template-est-config&#x27;,
    GetCertificateTemplateEstConfig: &#x27;get-certificate-template-est-config&#x27;,
    AttemptCreateSlackIntegration: &#x27;attempt-create-slack-integration&#x27;,
    AttemptReinstallSlackIntegration: &#x27;attempt-reinstall-slack-integration&#x27;,
    GetSlackIntegration: &#x27;get-slack-integration&#x27;,
    UpdateSlackIntegration: &#x27;update-slack-integration&#x27;,
    DeleteSlackIntegration: &#x27;delete-slack-integration&#x27;,
    GetProjectSlackConfig: &#x27;get-project-slack-config&#x27;,
    UpdateProjectSlackConfig: &#x27;update-project-slack-config&#x27;,
    IntegrationSynced: &#x27;integration-synced&#x27;,
    CreateCmek: &#x27;create-cmek&#x27;,
    UpdateCmek: &#x27;update-cmek&#x27;,
    DeleteCmek: &#x27;delete-cmek&#x27;,
    GetCmeks: &#x27;get-cmeks&#x27;,
    GetCmek: &#x27;get-cmek&#x27;,
    CmekEncrypt: &#x27;cmek-encrypt&#x27;,
    CmekDecrypt: &#x27;cmek-decrypt&#x27;,
    UpdateExternalGroupOrgRoleMapping: &#x27;update-external-group-org-role-mapping&#x27;,
    GetExternalGroupOrgRoleMapping: &#x27;get-external-group-org-role-mapping&#x27;,
    GetProjectTemplates: &#x27;get-project-templates&#x27;,
    GetProjectTemplate: &#x27;get-project-template&#x27;,
    CreateProjectTemplate: &#x27;create-project-template&#x27;,
    UpdateProjectTemplate: &#x27;update-project-template&#x27;,
    DeleteProjectTemplate: &#x27;delete-project-template&#x27;,
    ApplyProjectTemplate: &#x27;apply-project-template&#x27;,
    GetAppConnections: &#x27;get-app-connections&#x27;,
    GetAvailableAppConnectionsDetails: &#x27;get-available-app-connections-details&#x27;,
    GetAppConnection: &#x27;get-app-connection&#x27;,
    CreateAppConnection: &#x27;create-app-connection&#x27;,
    UpdateAppConnection: &#x27;update-app-connection&#x27;,
    DeleteAppConnection: &#x27;delete-app-connection&#x27;,
    CreateSharedSecret: &#x27;create-shared-secret&#x27;,
    CreateSecretRequest: &#x27;create-secret-request&#x27;,
    DeleteSharedSecret: &#x27;delete-shared-secret&#x27;,
    ReadSharedSecret: &#x27;read-shared-secret&#x27;,
    GetSecretSyncs: &#x27;get-secret-syncs&#x27;,
    GetSecretSync: &#x27;get-secret-sync&#x27;,
    CreateSecretSync: &#x27;create-secret-sync&#x27;,
    UpdateSecretSync: &#x27;update-secret-sync&#x27;,
    DeleteSecretSync: &#x27;delete-secret-sync&#x27;,
    SecretSyncSyncSecrets: &#x27;secret-sync-sync-secrets&#x27;,
    SecretSyncImportSecrets: &#x27;secret-sync-import-secrets&#x27;,
    SecretSyncRemoveSecrets: &#x27;secret-sync-remove-secrets&#x27;,
    OidcGroupMembershipMappingAssignUser: &#x27;oidc-group-membership-mapping-assign-user&#x27;,
    OidcGroupMembershipMappingRemoveUser: &#x27;oidc-group-membership-mapping-remove-user&#x27;,
    CreateKmipClient: &#x27;create-kmip-client&#x27;,
    UpdateKmipClient: &#x27;update-kmip-client&#x27;,
    DeleteKmipClient: &#x27;delete-kmip-client&#x27;,
    GetKmipClient: &#x27;get-kmip-client&#x27;,
    GetKmipClients: &#x27;get-kmip-clients&#x27;,
    CreateKmipClientCertificate: &#x27;create-kmip-client-certificate&#x27;,
    SetupKmip: &#x27;setup-kmip&#x27;,
    GetKmip: &#x27;get-kmip&#x27;,
    RegisterKmipServer: &#x27;register-kmip-server&#x27;,
    KmipOperationCreate: &#x27;kmip-operation-create&#x27;,
    KmipOperationGet: &#x27;kmip-operation-get&#x27;,
    KmipOperationDestroy: &#x27;kmip-operation-destroy&#x27;,
    KmipOperationGetAttributes: &#x27;kmip-operation-get-attributes&#x27;,
    KmipOperationActivate: &#x27;kmip-operation-activate&#x27;,
    KmipOperationRevoke: &#x27;kmip-operation-revoke&#x27;,
    KmipOperationLocate: &#x27;kmip-operation-locate&#x27;,
    KmipOperationRegister: &#x27;kmip-operation-register&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceWorkspaceIdAuditLogsGetUserAgentTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceWorkspaceIdAuditLogsGetUserAgentTypeEnum</b></span>
                        <a href="#ApiV1WorkspaceWorkspaceIdAuditLogsGetUserAgentTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Web: &#x27;web&#x27;,
    Cli: &#x27;cli&#x27;,
    K8Operator: &#x27;k8-operator&#x27;,
    Terraform: &#x27;terraform&#x27;,
    Other: &#x27;other&#x27;,
    InfisicalPythonSdk: &#x27;InfisicalPythonSDK&#x27;,
    InfisicalNodeSdk: &#x27;InfisicalNodeSDK&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsAnyOf1TypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsAnyOf1TypeEnum</b></span>
                        <a href="#ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsAnyOf1TypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    External: &#x27;external&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsAnyOfTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsAnyOfTypeEnum</b></span>
                        <a href="#ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsAnyOfTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Internal: &#x27;internal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsTypeEnum</b></span>
                        <a href="#ApiV1WorkspaceWorkspaceIdKmsPatchRequestKmsTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Internal: &#x27;internal&#x27;,
    External: &#x27;external&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequestRolesInnerAnyOf1TemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequestRolesInnerAnyOf1TemporaryModeEnum</b></span>
                        <a href="#ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequestRolesInnerAnyOf1TemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequestRolesInnerTemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequestRolesInnerTemporaryModeEnum</b></span>
                        <a href="#ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequestRolesInnerTemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV1WorkspaceWorkspaceIdUsersGetIncludeGroupMembersEnum"></a>
                    <span class="name">
                        <span ><b>ApiV1WorkspaceWorkspaceIdUsersGetIncludeGroupMembersEnum</b></span>
                        <a href="#ApiV1WorkspaceWorkspaceIdUsersGetIncludeGroupMembersEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2AuthMfaVerifyPostRequestMfaMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2AuthMfaVerifyPostRequestMfaMethodEnum</b></span>
                        <a href="#ApiV2AuthMfaVerifyPostRequestMfaMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Email: &#x27;email&#x27;,
    Totp: &#x27;totp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequestTypeAnyOfTemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequestTypeAnyOfTemporaryModeEnum</b></span>
                        <a href="#ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequestTypeAnyOfTemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequestTypeTemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequestTypeTemporaryModeEnum</b></span>
                        <a href="#ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequestTypeTemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2IdentityProjectAdditionalPrivilegePostRequestTypeAnyOfTemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2IdentityProjectAdditionalPrivilegePostRequestTypeAnyOfTemporaryModeEnum</b></span>
                        <a href="#ApiV2IdentityProjectAdditionalPrivilegePostRequestTypeAnyOfTemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2IdentityProjectAdditionalPrivilegePostRequestTypeTemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2IdentityProjectAdditionalPrivilegePostRequestTypeTemporaryModeEnum</b></span>
                        <a href="#ApiV2IdentityProjectAdditionalPrivilegePostRequestTypeTemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2OrganizationsOrganizationIdWorkspacesGetTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2OrganizationsOrganizationIdWorkspacesGetTypeEnum</b></span>
                        <a href="#ApiV2OrganizationsOrganizationIdWorkspacesGetTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SecretManager: &#x27;secret-manager&#x27;,
    CertManager: &#x27;cert-manager&#x27;,
    Kms: &#x27;kms&#x27;,
    Ssh: &#x27;ssh&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderByEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderByEnum</b></span>
                        <a href="#ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderByEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Name: &#x27;name&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderDirectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderDirectionEnum</b></span>
                        <a href="#ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderDirectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Asc: &#x27;asc&#x27;,
    Desc: &#x27;desc&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2ServiceTokenPostRequestPermissionsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2ServiceTokenPostRequestPermissionsEnum</b></span>
                        <a href="#ApiV2ServiceTokenPostRequestPermissionsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Read: &#x27;read&#x27;,
    Write: &#x27;write&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2UsersMeAuthMethodsPutRequestAuthMethodsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2UsersMeAuthMethodsPutRequestAuthMethodsEnum</b></span>
                        <a href="#ApiV2UsersMeAuthMethodsPutRequestAuthMethodsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Email: &#x27;email&#x27;,
    Google: &#x27;google&#x27;,
    Github: &#x27;github&#x27;,
    Gitlab: &#x27;gitlab&#x27;,
    OktaSaml: &#x27;okta-saml&#x27;,
    AzureSaml: &#x27;azure-saml&#x27;,
    JumpcloudSaml: &#x27;jumpcloud-saml&#x27;,
    GoogleSaml: &#x27;google-saml&#x27;,
    KeycloakSaml: &#x27;keycloak-saml&#x27;,
    Ldap: &#x27;ldap&#x27;,
    Oidc: &#x27;oidc&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2UsersMeMfaPatchRequestSelectedMfaMethodEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2UsersMeMfaPatchRequestSelectedMfaMethodEnum</b></span>
                        <a href="#ApiV2UsersMeMfaPatchRequestSelectedMfaMethodEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Email: &#x27;email&#x27;,
    Totp: &#x27;totp&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2WorkspacePostRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2WorkspacePostRequestTypeEnum</b></span>
                        <a href="#ApiV2WorkspacePostRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    SecretManager: &#x27;secret-manager&#x27;,
    CertManager: &#x27;cert-manager&#x27;,
    Kms: &#x27;kms&#x27;,
    Ssh: &#x27;ssh&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderByEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderByEnum</b></span>
                        <a href="#ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderByEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Name: &#x27;name&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderDirectionEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderDirectionEnum</b></span>
                        <a href="#ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderDirectionEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Asc: &#x27;asc&#x27;,
    Desc: &#x27;desc&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequestRolesInnerAnyOf1TemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequestRolesInnerAnyOf1TemporaryModeEnum</b></span>
                        <a href="#ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequestRolesInnerAnyOf1TemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequestRolesInnerTemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequestRolesInnerTemporaryModeEnum</b></span>
                        <a href="#ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequestRolesInnerTemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequestRolesInnerAnyOf1TemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequestRolesInnerAnyOf1TemporaryModeEnum</b></span>
                        <a href="#ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequestRolesInnerAnyOf1TemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequestRolesInnerTemporaryModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequestRolesInnerTemporaryModeEnum</b></span>
                        <a href="#ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequestRolesInnerTemporaryModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Relative: &#x27;relative&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV2WorkspaceSlugCasGetStatusEnum"></a>
                    <span class="name">
                        <span ><b>ApiV2WorkspaceSlugCasGetStatusEnum</b></span>
                        <a href="#ApiV2WorkspaceSlugCasGetStatusEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Active: &#x27;active&#x27;,
    PendingCertificate: &#x27;pending-certificate&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3AuthSelectOrganizationPostRequestUserAgentEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3AuthSelectOrganizationPostRequestUserAgentEnum</b></span>
                        <a href="#ApiV3AuthSelectOrganizationPostRequestUserAgentEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Cli: &#x27;cli&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsBatchDeleteRequestSecretsInnerTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsBatchDeleteRequestSecretsInnerTypeEnum</b></span>
                        <a href="#ApiV3SecretsBatchDeleteRequestSecretsInnerTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Shared: &#x27;shared&#x27;,
    Personal: &#x27;personal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsBatchPatchRequestSecretsInnerTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsBatchPatchRequestSecretsInnerTypeEnum</b></span>
                        <a href="#ApiV3SecretsBatchPatchRequestSecretsInnerTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Shared: &#x27;shared&#x27;,
    Personal: &#x27;personal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsBatchRawDeleteRequestSecretsInnerTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsBatchRawDeleteRequestSecretsInnerTypeEnum</b></span>
                        <a href="#ApiV3SecretsBatchRawDeleteRequestSecretsInnerTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Shared: &#x27;shared&#x27;,
    Personal: &#x27;personal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsBatchRawPatchRequestModeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsBatchRawPatchRequestModeEnum</b></span>
                        <a href="#ApiV3SecretsBatchRawPatchRequestModeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Ignore: &#x27;ignore&#x27;,
    Upsert: &#x27;upsert&#x27;,
    FailOnNotFound: &#x27;failOnNotFound&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsGetIncludeImportsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsGetIncludeImportsEnum</b></span>
                        <a href="#ApiV3SecretsGetIncludeImportsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsGetRecursiveEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsGetRecursiveEnum</b></span>
                        <a href="#ApiV3SecretsGetRecursiveEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsRawGetExpandSecretReferencesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsRawGetExpandSecretReferencesEnum</b></span>
                        <a href="#ApiV3SecretsRawGetExpandSecretReferencesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsRawGetIncludeImportsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsRawGetIncludeImportsEnum</b></span>
                        <a href="#ApiV3SecretsRawGetIncludeImportsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsRawGetRecursiveEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsRawGetRecursiveEnum</b></span>
                        <a href="#ApiV3SecretsRawGetRecursiveEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsRawGetViewSecretValueEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsRawGetViewSecretValueEnum</b></span>
                        <a href="#ApiV3SecretsRawGetViewSecretValueEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsRawSecretNameDeleteRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsRawSecretNameDeleteRequestTypeEnum</b></span>
                        <a href="#ApiV3SecretsRawSecretNameDeleteRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Shared: &#x27;shared&#x27;,
    Personal: &#x27;personal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsRawSecretNameGetExpandSecretReferencesEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsRawSecretNameGetExpandSecretReferencesEnum</b></span>
                        <a href="#ApiV3SecretsRawSecretNameGetExpandSecretReferencesEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsRawSecretNameGetIncludeImportsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsRawSecretNameGetIncludeImportsEnum</b></span>
                        <a href="#ApiV3SecretsRawSecretNameGetIncludeImportsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsRawSecretNameGetTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsRawSecretNameGetTypeEnum</b></span>
                        <a href="#ApiV3SecretsRawSecretNameGetTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Shared: &#x27;shared&#x27;,
    Personal: &#x27;personal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsRawSecretNameGetViewSecretValueEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsRawSecretNameGetViewSecretValueEnum</b></span>
                        <a href="#ApiV3SecretsRawSecretNameGetViewSecretValueEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsRawSecretNamePatchRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsRawSecretNamePatchRequestTypeEnum</b></span>
                        <a href="#ApiV3SecretsRawSecretNamePatchRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Shared: &#x27;shared&#x27;,
    Personal: &#x27;personal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsRawSecretNamePostRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsRawSecretNamePostRequestTypeEnum</b></span>
                        <a href="#ApiV3SecretsRawSecretNamePostRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Shared: &#x27;shared&#x27;,
    Personal: &#x27;personal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsSecretNameDeleteRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsSecretNameDeleteRequestTypeEnum</b></span>
                        <a href="#ApiV3SecretsSecretNameDeleteRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Shared: &#x27;shared&#x27;,
    Personal: &#x27;personal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsSecretNameGetIncludeImportsEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsSecretNameGetIncludeImportsEnum</b></span>
                        <a href="#ApiV3SecretsSecretNameGetIncludeImportsEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    True: &#x27;true&#x27;,
    False: &#x27;false&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsSecretNameGetTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsSecretNameGetTypeEnum</b></span>
                        <a href="#ApiV3SecretsSecretNameGetTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Shared: &#x27;shared&#x27;,
    Personal: &#x27;personal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsSecretNamePatchRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsSecretNamePatchRequestTypeEnum</b></span>
                        <a href="#ApiV3SecretsSecretNamePatchRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Shared: &#x27;shared&#x27;,
    Personal: &#x27;personal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsSecretNamePostRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsSecretNamePostRequestTypeEnum</b></span>
                        <a href="#ApiV3SecretsSecretNamePostRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Shared: &#x27;shared&#x27;,
    Personal: &#x27;personal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsTagsSecretNameDeleteRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsTagsSecretNameDeleteRequestTypeEnum</b></span>
                        <a href="#ApiV3SecretsTagsSecretNameDeleteRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Shared: &#x27;shared&#x27;,
    Personal: &#x27;personal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="ApiV3SecretsTagsSecretNamePostRequestTypeEnum"></a>
                    <span class="name">
                        <span ><b>ApiV3SecretsTagsSecretNamePostRequestTypeEnum</b></span>
                        <a href="#ApiV3SecretsTagsSecretNamePostRequestTypeEnum"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    Shared: &#x27;shared&#x27;,
    Personal: &#x27;personal&#x27;
} as const</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="DefaultApiAxiosParamCreator"></a>
                    <span class="name">
                        <span ><b>DefaultApiAxiosParamCreator</b></span>
                        <a href="#DefaultApiAxiosParamCreator"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStatusGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/status&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {string} envSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsPoliciesCountGet: async (projectSlug: string, envSlug: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsPoliciesCountGet&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            // verify required parameter &#x27;envSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsPoliciesCountGet&#x27;, &#x27;envSlug&#x27;, envSlug)
            const localVarPath &#x3D; &#x60;/api/v1/access-approvals/policies/count&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectSlug&#x27;] &#x3D; projectSlug;
            }

            if (envSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;envSlug&#x27;] &#x3D; envSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsPoliciesGet: async (projectSlug: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsPoliciesGet&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            const localVarPath &#x3D; &#x60;/api/v1/access-approvals/policies&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectSlug&#x27;] &#x3D; projectSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsPoliciesPolicyIdDelete: async (policyId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;policyId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsPoliciesPolicyIdDelete&#x27;, &#x27;policyId&#x27;, policyId)
            const localVarPath &#x3D; &#x60;/api/v1/access-approvals/policies/{policyId}&#x60;
                .replace(&#x60;{${&quot;policyId&quot;}}&#x60;, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsPoliciesPolicyIdGet: async (policyId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;policyId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsPoliciesPolicyIdGet&#x27;, &#x27;policyId&#x27;, policyId)
            const localVarPath &#x3D; &#x60;/api/v1/access-approvals/policies/{policyId}&#x60;
                .replace(&#x60;{${&quot;policyId&quot;}}&#x60;, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId 
         * @param {ApiV1AccessApprovalsPoliciesPolicyIdPatchRequest} apiV1AccessApprovalsPoliciesPolicyIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsPoliciesPolicyIdPatch: async (policyId: string, apiV1AccessApprovalsPoliciesPolicyIdPatchRequest: ApiV1AccessApprovalsPoliciesPolicyIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;policyId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsPoliciesPolicyIdPatch&#x27;, &#x27;policyId&#x27;, policyId)
            // verify required parameter &#x27;apiV1AccessApprovalsPoliciesPolicyIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsPoliciesPolicyIdPatch&#x27;, &#x27;apiV1AccessApprovalsPoliciesPolicyIdPatchRequest&#x27;, apiV1AccessApprovalsPoliciesPolicyIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/access-approvals/policies/{policyId}&#x60;
                .replace(&#x60;{${&quot;policyId&quot;}}&#x60;, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AccessApprovalsPoliciesPolicyIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AccessApprovalsPoliciesPostRequest} apiV1AccessApprovalsPoliciesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsPoliciesPost: async (apiV1AccessApprovalsPoliciesPostRequest: ApiV1AccessApprovalsPoliciesPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AccessApprovalsPoliciesPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsPoliciesPost&#x27;, &#x27;apiV1AccessApprovalsPoliciesPostRequest&#x27;, apiV1AccessApprovalsPoliciesPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/access-approvals/policies&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AccessApprovalsPoliciesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsRequestsCountGet: async (projectSlug: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsRequestsCountGet&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            const localVarPath &#x3D; &#x60;/api/v1/access-approvals/requests/count&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectSlug&#x27;] &#x3D; projectSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {string} [authorProjectMembershipId] 
         * @param {string} [envSlug] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsRequestsGet: async (projectSlug: string, authorProjectMembershipId?: string, envSlug?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsRequestsGet&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            const localVarPath &#x3D; &#x60;/api/v1/access-approvals/requests&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectSlug&#x27;] &#x3D; projectSlug;
            }

            if (authorProjectMembershipId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;authorProjectMembershipId&#x27;] &#x3D; authorProjectMembershipId;
            }

            if (envSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;envSlug&#x27;] &#x3D; envSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {ApiV1AccessApprovalsRequestsPostRequest} apiV1AccessApprovalsRequestsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsRequestsPost: async (projectSlug: string, apiV1AccessApprovalsRequestsPostRequest: ApiV1AccessApprovalsRequestsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsRequestsPost&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            // verify required parameter &#x27;apiV1AccessApprovalsRequestsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsRequestsPost&#x27;, &#x27;apiV1AccessApprovalsRequestsPostRequest&#x27;, apiV1AccessApprovalsRequestsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/access-approvals/requests&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectSlug&#x27;] &#x3D; projectSlug;
            }


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AccessApprovalsRequestsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} requestId 
         * @param {ApiV1AccessApprovalsRequestsRequestIdReviewPostRequest} apiV1AccessApprovalsRequestsRequestIdReviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsRequestsRequestIdReviewPost: async (requestId: string, apiV1AccessApprovalsRequestsRequestIdReviewPostRequest: ApiV1AccessApprovalsRequestsRequestIdReviewPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;requestId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsRequestsRequestIdReviewPost&#x27;, &#x27;requestId&#x27;, requestId)
            // verify required parameter &#x27;apiV1AccessApprovalsRequestsRequestIdReviewPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AccessApprovalsRequestsRequestIdReviewPost&#x27;, &#x27;apiV1AccessApprovalsRequestsRequestIdReviewPostRequest&#x27;, apiV1AccessApprovalsRequestsRequestIdReviewPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/access-approvals/requests/{requestId}/review&#x60;
                .replace(&#x60;{${&quot;requestId&quot;}}&#x60;, encodeURIComponent(String(requestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AccessApprovalsRequestsRequestIdReviewPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific privilege of an identity.
         * @param {ApiV1AdditionalPrivilegeIdentityDeleteRequest} apiV1AdditionalPrivilegeIdentityDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdditionalPrivilegeIdentityDelete: async (apiV1AdditionalPrivilegeIdentityDeleteRequest: ApiV1AdditionalPrivilegeIdentityDeleteRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AdditionalPrivilegeIdentityDeleteRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdditionalPrivilegeIdentityDelete&#x27;, &#x27;apiV1AdditionalPrivilegeIdentityDeleteRequest&#x27;, apiV1AdditionalPrivilegeIdentityDeleteRequest)
            const localVarPath &#x3D; &#x60;/api/v1/additional-privilege/identity&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AdditionalPrivilegeIdentityDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of a specific privilege of an identity in a project.
         * @param {string} identityId The ID of the identity to list.
         * @param {string} projectSlug The slug of the project of the identity in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdditionalPrivilegeIdentityGet: async (identityId: string, projectSlug: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdditionalPrivilegeIdentityGet&#x27;, &#x27;identityId&#x27;, identityId)
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdditionalPrivilegeIdentityGet&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            const localVarPath &#x3D; &#x60;/api/v1/additional-privilege/identity&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (identityId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;identityId&#x27;] &#x3D; identityId;
            }

            if (projectSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectSlug&#x27;] &#x3D; projectSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific privilege of an identity.
         * @param {ApiV1AdditionalPrivilegeIdentityPatchRequest} apiV1AdditionalPrivilegeIdentityPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdditionalPrivilegeIdentityPatch: async (apiV1AdditionalPrivilegeIdentityPatchRequest: ApiV1AdditionalPrivilegeIdentityPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AdditionalPrivilegeIdentityPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdditionalPrivilegeIdentityPatch&#x27;, &#x27;apiV1AdditionalPrivilegeIdentityPatchRequest&#x27;, apiV1AdditionalPrivilegeIdentityPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/additional-privilege/identity&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AdditionalPrivilegeIdentityPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a permanent or a non expiry specific privilege for identity.
         * @param {ApiV1AdditionalPrivilegeIdentityPermanentPostRequest} apiV1AdditionalPrivilegeIdentityPermanentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdditionalPrivilegeIdentityPermanentPost: async (apiV1AdditionalPrivilegeIdentityPermanentPostRequest: ApiV1AdditionalPrivilegeIdentityPermanentPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AdditionalPrivilegeIdentityPermanentPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdditionalPrivilegeIdentityPermanentPost&#x27;, &#x27;apiV1AdditionalPrivilegeIdentityPermanentPostRequest&#x27;, apiV1AdditionalPrivilegeIdentityPermanentPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/additional-privilege/identity/permanent&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AdditionalPrivilegeIdentityPermanentPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a specific privilege by privilege slug.
         * @param {string} identityId The ID of the identity to list.
         * @param {string} projectSlug The slug of the project of the identity in.
         * @param {string} privilegeSlug The slug of the privilege.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdditionalPrivilegeIdentityPrivilegeSlugGet: async (identityId: string, projectSlug: string, privilegeSlug: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdditionalPrivilegeIdentityPrivilegeSlugGet&#x27;, &#x27;identityId&#x27;, identityId)
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdditionalPrivilegeIdentityPrivilegeSlugGet&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            // verify required parameter &#x27;privilegeSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdditionalPrivilegeIdentityPrivilegeSlugGet&#x27;, &#x27;privilegeSlug&#x27;, privilegeSlug)
            const localVarPath &#x3D; &#x60;/api/v1/additional-privilege/identity/{privilegeSlug}&#x60;
                .replace(&#x60;{${&quot;privilegeSlug&quot;}}&#x60;, encodeURIComponent(String(privilegeSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (identityId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;identityId&#x27;] &#x3D; identityId;
            }

            if (projectSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectSlug&#x27;] &#x3D; projectSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a temporary or a expiring specific privilege for identity.
         * @param {ApiV1AdditionalPrivilegeIdentityTemporaryPostRequest} apiV1AdditionalPrivilegeIdentityTemporaryPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdditionalPrivilegeIdentityTemporaryPost: async (apiV1AdditionalPrivilegeIdentityTemporaryPostRequest: ApiV1AdditionalPrivilegeIdentityTemporaryPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AdditionalPrivilegeIdentityTemporaryPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdditionalPrivilegeIdentityTemporaryPost&#x27;, &#x27;apiV1AdditionalPrivilegeIdentityTemporaryPostRequest&#x27;, apiV1AdditionalPrivilegeIdentityTemporaryPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/additional-privilege/identity/temporary&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AdditionalPrivilegeIdentityTemporaryPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AdminBootstrapPostRequest} apiV1AdminBootstrapPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminBootstrapPost: async (apiV1AdminBootstrapPostRequest: ApiV1AdminBootstrapPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AdminBootstrapPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdminBootstrapPost&#x27;, &#x27;apiV1AdminBootstrapPostRequest&#x27;, apiV1AdminBootstrapPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/admin/bootstrap&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AdminBootstrapPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminConfigGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/admin/config&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AdminConfigPatchRequest} [apiV1AdminConfigPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminConfigPatch: async (apiV1AdminConfigPatchRequest?: ApiV1AdminConfigPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/admin/config&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AdminConfigPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminEncryptionStrategiesGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/admin/encryption-strategies&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AdminEncryptionStrategiesPatchRequest} apiV1AdminEncryptionStrategiesPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminEncryptionStrategiesPatch: async (apiV1AdminEncryptionStrategiesPatchRequest: ApiV1AdminEncryptionStrategiesPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AdminEncryptionStrategiesPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdminEncryptionStrategiesPatch&#x27;, &#x27;apiV1AdminEncryptionStrategiesPatchRequest&#x27;, apiV1AdminEncryptionStrategiesPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/admin/encryption-strategies&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AdminEncryptionStrategiesPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [searchTerm] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminIdentityManagementIdentitiesGet: async (searchTerm?: string, offset?: number, limit?: number, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/admin/identity-management/identities&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (searchTerm !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;searchTerm&#x27;] &#x3D; searchTerm;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminIdentityManagementIdentitiesIdentityIdSuperAdminAccessDelete: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdminIdentityManagementIdentitiesIdentityIdSuperAdminAccessDelete&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/admin/identity-management/identities/{identityId}/super-admin-access&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminIntegrationsSlackConfigGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/admin/integrations/slack/config&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AdminSignupPostRequest} apiV1AdminSignupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminSignupPost: async (apiV1AdminSignupPostRequest: ApiV1AdminSignupPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AdminSignupPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdminSignupPost&#x27;, &#x27;apiV1AdminSignupPostRequest&#x27;, apiV1AdminSignupPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/admin/signup&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AdminSignupPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [searchTerm] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [adminsOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminUserManagementUsersGet: async (searchTerm?: string, offset?: number, limit?: number, adminsOnly?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/admin/user-management/users&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (searchTerm !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;searchTerm&#x27;] &#x3D; searchTerm;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (adminsOnly !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;adminsOnly&#x27;] &#x3D; adminsOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminUserManagementUsersUserIdAdminAccessDelete: async (userId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;userId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdminUserManagementUsersUserIdAdminAccessDelete&#x27;, &#x27;userId&#x27;, userId)
            const localVarPath &#x3D; &#x60;/api/v1/admin/user-management/users/{userId}/admin-access&#x60;
                .replace(&#x60;{${&quot;userId&quot;}}&#x60;, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminUserManagementUsersUserIdAdminAccessPatch: async (userId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;userId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdminUserManagementUsersUserIdAdminAccessPatch&#x27;, &#x27;userId&#x27;, userId)
            const localVarPath &#x3D; &#x60;/api/v1/admin/user-management/users/{userId}/admin-access&#x60;
                .replace(&#x60;{${&quot;userId&quot;}}&#x60;, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminUserManagementUsersUserIdDelete: async (userId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;userId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AdminUserManagementUsersUserIdDelete&#x27;, &#x27;userId&#x27;, userId)
            const localVarPath &#x3D; &#x60;/api/v1/admin/user-management/users/{userId}&#x60;
                .replace(&#x60;{${&quot;userId&quot;}}&#x60;, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the AWS Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsAvailableGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/aws/available&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified AWS Connection.
         * @param {string} connectionId The ID of the AWS Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsConnectionIdDelete: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAwsConnectionIdDelete&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/aws/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified AWS Connection by ID.
         * @param {string} connectionId The ID of the AWS Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsConnectionIdGet: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAwsConnectionIdGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/aws/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AppConnectionsAwsConnectionIdKmsKeysGetRegionEnum} region 
         * @param {ApiV1AppConnectionsAwsConnectionIdKmsKeysGetDestinationEnum} destination 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsConnectionIdKmsKeysGet: async (region: ApiV1AppConnectionsAwsConnectionIdKmsKeysGetRegionEnum, destination: ApiV1AppConnectionsAwsConnectionIdKmsKeysGetDestinationEnum, connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;region&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAwsConnectionIdKmsKeysGet&#x27;, &#x27;region&#x27;, region)
            // verify required parameter &#x27;destination&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAwsConnectionIdKmsKeysGet&#x27;, &#x27;destination&#x27;, destination)
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAwsConnectionIdKmsKeysGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/aws/{connectionId}/kms-keys&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (region !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;region&#x27;] &#x3D; region;
            }

            if (destination !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;destination&#x27;] &#x3D; destination;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified AWS Connection.
         * @param {string} connectionId The ID of the AWS Connection to be updated.
         * @param {ApiV1AppConnectionsAwsConnectionIdPatchRequest} [apiV1AppConnectionsAwsConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsConnectionIdPatch: async (connectionId: string, apiV1AppConnectionsAwsConnectionIdPatchRequest?: ApiV1AppConnectionsAwsConnectionIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAwsConnectionIdPatch&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/aws/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsAwsConnectionIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified AWS Connection by name.
         * @param {string} connectionName The name of the AWS Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsConnectionNameConnectionNameGet: async (connectionName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAwsConnectionNameConnectionNameGet&#x27;, &#x27;connectionName&#x27;, connectionName)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/aws/connection-name/{connectionName}&#x60;
                .replace(&#x60;{${&quot;connectionName&quot;}}&#x60;, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the AWS Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/aws&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an AWS Connection for the current organization.
         * @param {ApiV1AppConnectionsAwsPostRequest} [apiV1AppConnectionsAwsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsPost: async (apiV1AppConnectionsAwsPostRequest?: ApiV1AppConnectionsAwsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/aws&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsAwsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Azure App Configuration Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationAvailableGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-app-configuration/available&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified Azure App Configuration Connection.
         * @param {string} connectionId The ID of the Azure App Configuration Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationConnectionIdDelete: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAzureAppConfigurationConnectionIdDelete&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-app-configuration/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Azure App Configuration Connection by ID.
         * @param {string} connectionId The ID of the Azure App Configuration Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationConnectionIdGet: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAzureAppConfigurationConnectionIdGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-app-configuration/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified Azure App Configuration Connection.
         * @param {string} connectionId The ID of the Azure App Configuration Connection to be updated.
         * @param {ApiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest} [apiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationConnectionIdPatch: async (connectionId: string, apiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest?: ApiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAzureAppConfigurationConnectionIdPatch&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-app-configuration/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Azure App Configuration Connection by name.
         * @param {string} connectionName The name of the Azure App Configuration Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationConnectionNameConnectionNameGet: async (connectionName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAzureAppConfigurationConnectionNameConnectionNameGet&#x27;, &#x27;connectionName&#x27;, connectionName)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-app-configuration/connection-name/{connectionName}&#x60;
                .replace(&#x60;{${&quot;connectionName&quot;}}&#x60;, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Azure App Configuration Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-app-configuration&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Azure App Configuration Connection for the current organization.
         * @param {ApiV1AppConnectionsAzureAppConfigurationPostRequest} [apiV1AppConnectionsAzureAppConfigurationPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationPost: async (apiV1AppConnectionsAzureAppConfigurationPostRequest?: ApiV1AppConnectionsAzureAppConfigurationPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-app-configuration&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsAzureAppConfigurationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Azure Key Vault Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultAvailableGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-key-vault/available&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified Azure Key Vault Connection.
         * @param {string} connectionId The ID of the Azure Key Vault Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultConnectionIdDelete: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAzureKeyVaultConnectionIdDelete&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-key-vault/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Azure Key Vault Connection by ID.
         * @param {string} connectionId The ID of the Azure Key Vault Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultConnectionIdGet: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAzureKeyVaultConnectionIdGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-key-vault/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified Azure Key Vault Connection.
         * @param {string} connectionId The ID of the Azure Key Vault Connection to be updated.
         * @param {ApiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest} [apiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultConnectionIdPatch: async (connectionId: string, apiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest?: ApiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAzureKeyVaultConnectionIdPatch&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-key-vault/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Azure Key Vault Connection by name.
         * @param {string} connectionName The name of the Azure Key Vault Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultConnectionNameConnectionNameGet: async (connectionName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsAzureKeyVaultConnectionNameConnectionNameGet&#x27;, &#x27;connectionName&#x27;, connectionName)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-key-vault/connection-name/{connectionName}&#x60;
                .replace(&#x60;{${&quot;connectionName&quot;}}&#x60;, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Azure Key Vault Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-key-vault&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Azure Key Vault Connection for the current organization.
         * @param {ApiV1AppConnectionsAzureKeyVaultPostRequest} [apiV1AppConnectionsAzureKeyVaultPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultPost: async (apiV1AppConnectionsAzureKeyVaultPostRequest?: ApiV1AppConnectionsAzureKeyVaultPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/azure-key-vault&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsAzureKeyVaultPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Databricks Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksAvailableGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/databricks/available&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified Databricks Connection.
         * @param {string} connectionId The ID of the Databricks Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksConnectionIdDelete: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsDatabricksConnectionIdDelete&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/databricks/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Databricks Connection by ID.
         * @param {string} connectionId The ID of the Databricks Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksConnectionIdGet: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsDatabricksConnectionIdGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/databricks/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified Databricks Connection.
         * @param {string} connectionId The ID of the Databricks Connection to be updated.
         * @param {ApiV1AppConnectionsDatabricksConnectionIdPatchRequest} [apiV1AppConnectionsDatabricksConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksConnectionIdPatch: async (connectionId: string, apiV1AppConnectionsDatabricksConnectionIdPatchRequest?: ApiV1AppConnectionsDatabricksConnectionIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsDatabricksConnectionIdPatch&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/databricks/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsDatabricksConnectionIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksConnectionIdSecretScopesGet: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsDatabricksConnectionIdSecretScopesGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/databricks/{connectionId}/secret-scopes&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Databricks Connection by name.
         * @param {string} connectionName The name of the Databricks Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksConnectionNameConnectionNameGet: async (connectionName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsDatabricksConnectionNameConnectionNameGet&#x27;, &#x27;connectionName&#x27;, connectionName)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/databricks/connection-name/{connectionName}&#x60;
                .replace(&#x60;{${&quot;connectionName&quot;}}&#x60;, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Databricks Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/databricks&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Databricks Connection for the current organization.
         * @param {ApiV1AppConnectionsDatabricksPostRequest} [apiV1AppConnectionsDatabricksPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksPost: async (apiV1AppConnectionsDatabricksPostRequest?: ApiV1AppConnectionsDatabricksPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/databricks&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsDatabricksPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the GCP Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpAvailableGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/gcp/available&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified GCP Connection.
         * @param {string} connectionId The ID of the GCP Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpConnectionIdDelete: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGcpConnectionIdDelete&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/gcp/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified GCP Connection by ID.
         * @param {string} connectionId The ID of the GCP Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpConnectionIdGet: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGcpConnectionIdGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/gcp/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified GCP Connection.
         * @param {string} connectionId The ID of the GCP Connection to be updated.
         * @param {ApiV1AppConnectionsGcpConnectionIdPatchRequest} [apiV1AppConnectionsGcpConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpConnectionIdPatch: async (connectionId: string, apiV1AppConnectionsGcpConnectionIdPatchRequest?: ApiV1AppConnectionsGcpConnectionIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGcpConnectionIdPatch&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/gcp/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsGcpConnectionIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpConnectionIdSecretManagerProjectsGet: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGcpConnectionIdSecretManagerProjectsGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/gcp/{connectionId}/secret-manager-projects&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified GCP Connection by name.
         * @param {string} connectionName The name of the GCP Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpConnectionNameConnectionNameGet: async (connectionName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGcpConnectionNameConnectionNameGet&#x27;, &#x27;connectionName&#x27;, connectionName)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/gcp/connection-name/{connectionName}&#x60;
                .replace(&#x60;{${&quot;connectionName&quot;}}&#x60;, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the GCP Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/gcp&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a GCP Connection for the current organization.
         * @param {ApiV1AppConnectionsGcpPostRequest} [apiV1AppConnectionsGcpPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpPost: async (apiV1AppConnectionsGcpPostRequest?: ApiV1AppConnectionsGcpPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/gcp&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsGcpPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the App Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the GitHub Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubAvailableGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/github/available&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified GitHub Connection.
         * @param {string} connectionId The ID of the GitHub Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionIdDelete: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGithubConnectionIdDelete&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/github/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repo 
         * @param {string} owner 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionIdEnvironmentsGet: async (repo: string, owner: string, connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;repo&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGithubConnectionIdEnvironmentsGet&#x27;, &#x27;repo&#x27;, repo)
            // verify required parameter &#x27;owner&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGithubConnectionIdEnvironmentsGet&#x27;, &#x27;owner&#x27;, owner)
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGithubConnectionIdEnvironmentsGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/github/{connectionId}/environments&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (repo !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;repo&#x27;] &#x3D; repo;
            }

            if (owner !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;owner&#x27;] &#x3D; owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified GitHub Connection by ID.
         * @param {string} connectionId The ID of the GitHub Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionIdGet: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGithubConnectionIdGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/github/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionIdOrganizationsGet: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGithubConnectionIdOrganizationsGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/github/{connectionId}/organizations&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified GitHub Connection.
         * @param {string} connectionId The ID of the GitHub Connection to be updated.
         * @param {ApiV1AppConnectionsGithubConnectionIdPatchRequest} [apiV1AppConnectionsGithubConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionIdPatch: async (connectionId: string, apiV1AppConnectionsGithubConnectionIdPatchRequest?: ApiV1AppConnectionsGithubConnectionIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGithubConnectionIdPatch&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/github/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsGithubConnectionIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionIdRepositoriesGet: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGithubConnectionIdRepositoriesGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/github/{connectionId}/repositories&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified GitHub Connection by name.
         * @param {string} connectionName The name of the GitHub Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionNameConnectionNameGet: async (connectionName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsGithubConnectionNameConnectionNameGet&#x27;, &#x27;connectionName&#x27;, connectionName)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/github/connection-name/{connectionName}&#x60;
                .replace(&#x60;{${&quot;connectionName&quot;}}&#x60;, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the GitHub Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/github&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a GitHub Connection for the current organization.
         * @param {ApiV1AppConnectionsGithubPostRequest} [apiV1AppConnectionsGithubPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubPost: async (apiV1AppConnectionsGithubPostRequest?: ApiV1AppConnectionsGithubPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/github&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsGithubPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Humanitec Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecAvailableGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/humanitec/available&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified Humanitec Connection.
         * @param {string} connectionId The ID of the Humanitec Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecConnectionIdDelete: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsHumanitecConnectionIdDelete&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/humanitec/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Humanitec Connection by ID.
         * @param {string} connectionId The ID of the Humanitec Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecConnectionIdGet: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsHumanitecConnectionIdGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/humanitec/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecConnectionIdOrganizationsGet: async (connectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsHumanitecConnectionIdOrganizationsGet&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/humanitec/{connectionId}/organizations&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified Humanitec Connection.
         * @param {string} connectionId The ID of the Humanitec Connection to be updated.
         * @param {ApiV1AppConnectionsHumanitecConnectionIdPatchRequest} [apiV1AppConnectionsHumanitecConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecConnectionIdPatch: async (connectionId: string, apiV1AppConnectionsHumanitecConnectionIdPatchRequest?: ApiV1AppConnectionsHumanitecConnectionIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsHumanitecConnectionIdPatch&#x27;, &#x27;connectionId&#x27;, connectionId)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/humanitec/{connectionId}&#x60;
                .replace(&#x60;{${&quot;connectionId&quot;}}&#x60;, encodeURIComponent(String(connectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsHumanitecConnectionIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Humanitec Connection by name.
         * @param {string} connectionName The name of the Humanitec Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecConnectionNameConnectionNameGet: async (connectionName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;connectionName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AppConnectionsHumanitecConnectionNameConnectionNameGet&#x27;, &#x27;connectionName&#x27;, connectionName)
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/humanitec/connection-name/{connectionName}&#x60;
                .replace(&#x60;{${&quot;connectionName&quot;}}&#x60;, encodeURIComponent(String(connectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Humanitec Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/humanitec&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Humanitec Connection for the current organization.
         * @param {ApiV1AppConnectionsHumanitecPostRequest} [apiV1AppConnectionsHumanitecPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecPost: async (apiV1AppConnectionsHumanitecPostRequest?: ApiV1AppConnectionsHumanitecPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/humanitec&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AppConnectionsHumanitecPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the available App Connection Options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsOptionsGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/app-connections/options&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Audit Log Streams.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuditLogStreamsGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/audit-log-streams&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an Audit Log Stream by ID.
         * @param {string} id The ID of the audit log stream to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuditLogStreamsIdDelete: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuditLogStreamsIdDelete&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/audit-log-streams/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Audit Log Stream by ID.
         * @param {string} id The ID of the audit log stream to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuditLogStreamsIdGet: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuditLogStreamsIdGet&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/audit-log-streams/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Audit Log Stream by ID.
         * @param {string} id The ID of the audit log stream to update.
         * @param {ApiV1AuditLogStreamsIdPatchRequest} [apiV1AuditLogStreamsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuditLogStreamsIdPatch: async (id: string, apiV1AuditLogStreamsIdPatchRequest?: ApiV1AuditLogStreamsIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuditLogStreamsIdPatch&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/audit-log-streams/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuditLogStreamsIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Audit Log Stream.
         * @param {ApiV1AuditLogStreamsPostRequest} apiV1AuditLogStreamsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuditLogStreamsPost: async (apiV1AuditLogStreamsPostRequest: ApiV1AuditLogStreamsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AuditLogStreamsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuditLogStreamsPost&#x27;, &#x27;apiV1AuditLogStreamsPostRequest&#x27;, apiV1AuditLogStreamsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/audit-log-streams&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuditLogStreamsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete AWS Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAwsAuthIdentitiesIdentityIdDelete: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthAwsAuthIdentitiesIdentityIdDelete&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/aws-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve AWS Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAwsAuthIdentitiesIdentityIdGet: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthAwsAuthIdentitiesIdentityIdGet&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/aws-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update AWS Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAwsAuthIdentitiesIdentityIdPatch: async (identityId: string, apiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthAwsAuthIdentitiesIdentityIdPatch&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/aws-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach AWS Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthAwsAuthIdentitiesIdentityIdPostRequest} [apiV1AuthAwsAuthIdentitiesIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAwsAuthIdentitiesIdentityIdPost: async (identityId: string, apiV1AuthAwsAuthIdentitiesIdentityIdPostRequest?: ApiV1AuthAwsAuthIdentitiesIdentityIdPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthAwsAuthIdentitiesIdentityIdPost&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/aws-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthAwsAuthIdentitiesIdentityIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login with AWS Auth
         * @param {ApiV1AuthAwsAuthLoginPostRequest} apiV1AuthAwsAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAwsAuthLoginPost: async (apiV1AuthAwsAuthLoginPostRequest: ApiV1AuthAwsAuthLoginPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AuthAwsAuthLoginPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthAwsAuthLoginPost&#x27;, &#x27;apiV1AuthAwsAuthLoginPostRequest&#x27;, apiV1AuthAwsAuthLoginPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/auth/aws-auth/login&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthAwsAuthLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Azure Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAzureAuthIdentitiesIdentityIdDelete: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthAzureAuthIdentitiesIdentityIdDelete&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/azure-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Azure Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAzureAuthIdentitiesIdentityIdGet: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthAzureAuthIdentitiesIdentityIdGet&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/azure-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Azure Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAzureAuthIdentitiesIdentityIdPatch: async (identityId: string, apiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthAzureAuthIdentitiesIdentityIdPatch&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/azure-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach Azure Auth configuration onto identity
         * @param {string} identityId The ID of the identity to login.
         * @param {ApiV1AuthAzureAuthIdentitiesIdentityIdPostRequest} apiV1AuthAzureAuthIdentitiesIdentityIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAzureAuthIdentitiesIdentityIdPost: async (identityId: string, apiV1AuthAzureAuthIdentitiesIdentityIdPostRequest: ApiV1AuthAzureAuthIdentitiesIdentityIdPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthAzureAuthIdentitiesIdentityIdPost&#x27;, &#x27;identityId&#x27;, identityId)
            // verify required parameter &#x27;apiV1AuthAzureAuthIdentitiesIdentityIdPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthAzureAuthIdentitiesIdentityIdPost&#x27;, &#x27;apiV1AuthAzureAuthIdentitiesIdentityIdPostRequest&#x27;, apiV1AuthAzureAuthIdentitiesIdentityIdPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/auth/azure-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthAzureAuthIdentitiesIdentityIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login with Azure Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAzureAuthLoginPost: async (apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AuthKubernetesAuthLoginPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthAzureAuthLoginPost&#x27;, &#x27;apiV1AuthKubernetesAuthLoginPostRequest&#x27;, apiV1AuthKubernetesAuthLoginPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/auth/azure-auth/login&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthKubernetesAuthLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthCheckAuthPost: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/auth/checkAuth&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete GCP Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthGcpAuthIdentitiesIdentityIdDelete: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthGcpAuthIdentitiesIdentityIdDelete&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/gcp-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve GCP Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthGcpAuthIdentitiesIdentityIdGet: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthGcpAuthIdentitiesIdentityIdGet&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/gcp-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update GCP Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthGcpAuthIdentitiesIdentityIdPatch: async (identityId: string, apiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthGcpAuthIdentitiesIdentityIdPatch&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/gcp-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach GCP Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequest} apiV1AuthGcpAuthIdentitiesIdentityIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthGcpAuthIdentitiesIdentityIdPost: async (identityId: string, apiV1AuthGcpAuthIdentitiesIdentityIdPostRequest: ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthGcpAuthIdentitiesIdentityIdPost&#x27;, &#x27;identityId&#x27;, identityId)
            // verify required parameter &#x27;apiV1AuthGcpAuthIdentitiesIdentityIdPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthGcpAuthIdentitiesIdentityIdPost&#x27;, &#x27;apiV1AuthGcpAuthIdentitiesIdentityIdPostRequest&#x27;, apiV1AuthGcpAuthIdentitiesIdentityIdPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/auth/gcp-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthGcpAuthIdentitiesIdentityIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login with GCP Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthGcpAuthLoginPost: async (apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AuthKubernetesAuthLoginPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthGcpAuthLoginPost&#x27;, &#x27;apiV1AuthKubernetesAuthLoginPostRequest&#x27;, apiV1AuthKubernetesAuthLoginPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/auth/gcp-auth/login&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthKubernetesAuthLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete JWT Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthJwtAuthIdentitiesIdentityIdDelete: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthJwtAuthIdentitiesIdentityIdDelete&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/jwt-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve JWT Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthJwtAuthIdentitiesIdentityIdGet: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthJwtAuthIdentitiesIdentityIdGet&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/jwt-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update JWT Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthJwtAuthIdentitiesIdentityIdPatch: async (identityId: string, apiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthJwtAuthIdentitiesIdentityIdPatch&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/jwt-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach JWT Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequest} [apiV1AuthJwtAuthIdentitiesIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthJwtAuthIdentitiesIdentityIdPost: async (identityId: string, apiV1AuthJwtAuthIdentitiesIdentityIdPostRequest?: ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthJwtAuthIdentitiesIdentityIdPost&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/jwt-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthJwtAuthIdentitiesIdentityIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login with JWT Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthJwtAuthLoginPost: async (apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AuthKubernetesAuthLoginPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthJwtAuthLoginPost&#x27;, &#x27;apiV1AuthKubernetesAuthLoginPostRequest&#x27;, apiV1AuthKubernetesAuthLoginPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/auth/jwt-auth/login&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthKubernetesAuthLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Kubernetes Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthKubernetesAuthIdentitiesIdentityIdDelete: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthKubernetesAuthIdentitiesIdentityIdDelete&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/kubernetes-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Kubernetes Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthKubernetesAuthIdentitiesIdentityIdGet: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthKubernetesAuthIdentitiesIdentityIdGet&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/kubernetes-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Kubernetes Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthKubernetesAuthIdentitiesIdentityIdPatch: async (identityId: string, apiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthKubernetesAuthIdentitiesIdentityIdPatch&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/kubernetes-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach Kubernetes Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest} apiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthKubernetesAuthIdentitiesIdentityIdPost: async (identityId: string, apiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest: ApiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthKubernetesAuthIdentitiesIdentityIdPost&#x27;, &#x27;identityId&#x27;, identityId)
            // verify required parameter &#x27;apiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthKubernetesAuthIdentitiesIdentityIdPost&#x27;, &#x27;apiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest&#x27;, apiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/auth/kubernetes-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login with Kubernetes Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthKubernetesAuthLoginPost: async (apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AuthKubernetesAuthLoginPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthKubernetesAuthLoginPost&#x27;, &#x27;apiV1AuthKubernetesAuthLoginPostRequest&#x27;, apiV1AuthKubernetesAuthLoginPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/auth/kubernetes-auth/login&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthKubernetesAuthLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLogoutPost: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/auth/logout&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete OIDC Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthOidcAuthIdentitiesIdentityIdDelete: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthOidcAuthIdentitiesIdentityIdDelete&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/oidc-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve OIDC Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthOidcAuthIdentitiesIdentityIdGet: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthOidcAuthIdentitiesIdentityIdGet&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/oidc-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update OIDC Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthOidcAuthIdentitiesIdentityIdPatch: async (identityId: string, apiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthOidcAuthIdentitiesIdentityIdPatch&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/oidc-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach OIDC Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthOidcAuthIdentitiesIdentityIdPostRequest} apiV1AuthOidcAuthIdentitiesIdentityIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthOidcAuthIdentitiesIdentityIdPost: async (identityId: string, apiV1AuthOidcAuthIdentitiesIdentityIdPostRequest: ApiV1AuthOidcAuthIdentitiesIdentityIdPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthOidcAuthIdentitiesIdentityIdPost&#x27;, &#x27;identityId&#x27;, identityId)
            // verify required parameter &#x27;apiV1AuthOidcAuthIdentitiesIdentityIdPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthOidcAuthIdentitiesIdentityIdPost&#x27;, &#x27;apiV1AuthOidcAuthIdentitiesIdentityIdPostRequest&#x27;, apiV1AuthOidcAuthIdentitiesIdentityIdPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/auth/oidc-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthOidcAuthIdentitiesIdentityIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login with OIDC Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthOidcAuthLoginPost: async (apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AuthKubernetesAuthLoginPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthOidcAuthLoginPost&#x27;, &#x27;apiV1AuthKubernetesAuthLoginPostRequest&#x27;, apiV1AuthKubernetesAuthLoginPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/auth/oidc-auth/login&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthKubernetesAuthLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Token Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthIdentitiesIdentityIdDelete: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthTokenAuthIdentitiesIdentityIdDelete&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/token-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Token Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthIdentitiesIdentityIdGet: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthTokenAuthIdentitiesIdentityIdGet&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/token-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Token Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthIdentitiesIdentityIdPatch: async (identityId: string, apiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthTokenAuthIdentitiesIdentityIdPatch&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/token-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach Token Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthTokenAuthIdentitiesIdentityIdPostRequest} [apiV1AuthTokenAuthIdentitiesIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthIdentitiesIdentityIdPost: async (identityId: string, apiV1AuthTokenAuthIdentitiesIdentityIdPostRequest?: ApiV1AuthTokenAuthIdentitiesIdentityIdPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthTokenAuthIdentitiesIdentityIdPost&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/token-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthTokenAuthIdentitiesIdentityIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tokens for identity with Token Auth
         * @param {string} identityId The ID of the identity to list token metadata for.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th token.
         * @param {number} [limit] The number of tokens to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthIdentitiesIdentityIdTokensGet: async (identityId: string, offset?: number, limit?: number, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthTokenAuthIdentitiesIdentityIdTokensGet&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/token-auth/identities/{identityId}/tokens&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create token for identity with Token Auth
         * @param {string} identityId The ID of the identity to create the token for.
         * @param {ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest} [apiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthIdentitiesIdentityIdTokensPost: async (identityId: string, apiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest?: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthTokenAuthIdentitiesIdentityIdTokensPost&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/token-auth/identities/{identityId}/tokens&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update token for identity with Token Auth
         * @param {string} tokenId The ID of the token to update metadata for.
         * @param {ApiV1AuthTokenAuthTokensTokenIdPatchRequest} [apiV1AuthTokenAuthTokensTokenIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthTokensTokenIdPatch: async (tokenId: string, apiV1AuthTokenAuthTokensTokenIdPatchRequest?: ApiV1AuthTokenAuthTokensTokenIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;tokenId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthTokenAuthTokensTokenIdPatch&#x27;, &#x27;tokenId&#x27;, tokenId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/token-auth/tokens/{tokenId}&#x60;
                .replace(&#x60;{${&quot;tokenId&quot;}}&#x60;, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthTokenAuthTokensTokenIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke token for identity with Token Auth
         * @param {string} tokenId The ID of the token to revoke.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthTokensTokenIdRevokePost: async (tokenId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;tokenId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthTokenAuthTokensTokenIdRevokePost&#x27;, &#x27;tokenId&#x27;, tokenId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/token-auth/tokens/{tokenId}/revoke&#x60;
                .replace(&#x60;{${&quot;tokenId&quot;}}&#x60;, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenPost: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/auth/token&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Renew access token
         * @param {ApiV1AuthTokenRenewPostRequest} apiV1AuthTokenRenewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenRenewPost: async (apiV1AuthTokenRenewPostRequest: ApiV1AuthTokenRenewPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AuthTokenRenewPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthTokenRenewPost&#x27;, &#x27;apiV1AuthTokenRenewPostRequest&#x27;, apiV1AuthTokenRenewPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/auth/token/renew&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthTokenRenewPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke access token
         * @param {ApiV1AuthTokenRevokePostRequest} apiV1AuthTokenRevokePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenRevokePost: async (apiV1AuthTokenRevokePostRequest: ApiV1AuthTokenRevokePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AuthTokenRevokePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthTokenRevokePost&#x27;, &#x27;apiV1AuthTokenRevokePostRequest&#x27;, apiV1AuthTokenRevokePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/auth/token/revoke&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthTokenRevokePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Universal Auth Client Secret for identity
         * @param {string} identityId The ID of the identity to get the client secret from.
         * @param {string} clientSecretId The ID of the client secret to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet: async (identityId: string, clientSecretId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet&#x27;, &#x27;identityId&#x27;, identityId)
            // verify required parameter &#x27;clientSecretId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet&#x27;, &#x27;clientSecretId&#x27;, clientSecretId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/universal-auth/identities/{identityId}/client-secrets/{clientSecretId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)))
                .replace(&#x60;{${&quot;clientSecretId&quot;}}&#x60;, encodeURIComponent(String(clientSecretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke Universal Auth Client Secrets for identity
         * @param {string} identityId The ID of the identity to revoke the client secret from.
         * @param {string} clientSecretId The ID of the client secret to revoke.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdRevokePost: async (identityId: string, clientSecretId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdRevokePost&#x27;, &#x27;identityId&#x27;, identityId)
            // verify required parameter &#x27;clientSecretId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdRevokePost&#x27;, &#x27;clientSecretId&#x27;, clientSecretId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/universal-auth/identities/{identityId}/client-secrets/{clientSecretId}/revoke&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)))
                .replace(&#x60;{${&quot;clientSecretId&quot;}}&#x60;, encodeURIComponent(String(clientSecretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Universal Auth Client Secrets for identity
         * @param {string} identityId The ID of the identity to list client secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/universal-auth/identities/{identityId}/client-secrets&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Universal Auth Client Secret for identity
         * @param {string} identityId The ID of the identity to create a client secret for.
         * @param {ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest} [apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost: async (identityId: string, apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest?: ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/universal-auth/identities/{identityId}/client-secrets&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Universal Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdDelete: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthUniversalAuthIdentitiesIdentityIdDelete&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/universal-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Universal Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdGet: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthUniversalAuthIdentitiesIdentityIdGet&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/universal-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Universal Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdPatch: async (identityId: string, apiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthUniversalAuthIdentitiesIdentityIdPatch&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/universal-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach Universal Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest} [apiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdPost: async (identityId: string, apiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest?: ApiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthUniversalAuthIdentitiesIdentityIdPost&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/auth/universal-auth/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login with Universal Auth
         * @param {ApiV1AuthUniversalAuthLoginPostRequest} apiV1AuthUniversalAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthLoginPost: async (apiV1AuthUniversalAuthLoginPostRequest: ApiV1AuthUniversalAuthLoginPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1AuthUniversalAuthLoginPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1AuthUniversalAuthLoginPost&#x27;, &#x27;apiV1AuthUniversalAuthLoginPostRequest&#x27;, apiV1AuthUniversalAuthLoginPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/auth/universal-auth/login&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1AuthUniversalAuthLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} botId 
         * @param {ApiV1BotBotIdActivePatchRequest} apiV1BotBotIdActivePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BotBotIdActivePatch: async (botId: string, apiV1BotBotIdActivePatchRequest: ApiV1BotBotIdActivePatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;botId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1BotBotIdActivePatch&#x27;, &#x27;botId&#x27;, botId)
            // verify required parameter &#x27;apiV1BotBotIdActivePatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1BotBotIdActivePatch&#x27;, &#x27;apiV1BotBotIdActivePatchRequest&#x27;, apiV1BotBotIdActivePatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/bot/{botId}/active&#x60;
                .replace(&#x60;{${&quot;botId&quot;}}&#x60;, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1BotBotIdActivePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BotProjectIdGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1BotProjectIdGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/bot/{projectId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} environment 
         * @param {string} [secretPath] 
         * @param {ApiV1DashboardAccessibleSecretsGetFilterByActionEnum} [filterByAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardAccessibleSecretsGet: async (projectId: string, environment: string, secretPath?: string, filterByAction?: ApiV1DashboardAccessibleSecretsGetFilterByActionEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DashboardAccessibleSecretsGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DashboardAccessibleSecretsGet&#x27;, &#x27;environment&#x27;, environment)
            const localVarPath &#x3D; &#x60;/api/v1/dashboard/accessible-secrets&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }

            if (filterByAction !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;filterByAction&#x27;] &#x3D; filterByAction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} environment 
         * @param {string} keys 
         * @param {string} [secretPath] 
         * @param {ApiV1FoldersGetRecursiveParameter} [viewSecretValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardSecretsByKeysGet: async (projectId: string, environment: string, keys: string, secretPath?: string, viewSecretValue?: ApiV1FoldersGetRecursiveParameter, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DashboardSecretsByKeysGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DashboardSecretsByKeysGet&#x27;, &#x27;environment&#x27;, environment)
            // verify required parameter &#x27;keys&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DashboardSecretsByKeysGet&#x27;, &#x27;keys&#x27;, keys)
            const localVarPath &#x3D; &#x60;/api/v1/dashboard/secrets-by-keys&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }

            if (keys !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;keys&#x27;] &#x3D; keys;
            }

            if (viewSecretValue !&#x3D;&#x3D; undefined) {
                for (const [key, value] of Object.entries(viewSecretValue)) {
                    localVarQueryParameter[key] &#x3D; value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} environments 
         * @param {string} [secretPath] 
         * @param {string} [search] 
         * @param {string} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardSecretsDeepSearchGet: async (projectId: string, environments: string, secretPath?: string, search?: string, tags?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DashboardSecretsDeepSearchGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;environments&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DashboardSecretsDeepSearchGet&#x27;, &#x27;environments&#x27;, environments)
            const localVarPath &#x3D; &#x60;/api/v1/dashboard/secrets-deep-search&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }

            if (environments !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environments&#x27;] &#x3D; environments;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }

            if (search !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;search&#x27;] &#x3D; search;
            }

            if (tags !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;tags&#x27;] &#x3D; tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List project secrets details
         * @param {string} projectId The ID of the project to list secrets/folders from.
         * @param {string} environment The slug of the environment to list secrets/folders from.
         * @param {string} [secretPath] The secret path to list secrets/folders from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th secret/folder.
         * @param {number} [limit] The number of secrets/folders to return.
         * @param {ApiV1DashboardSecretsDetailsGetOrderByEnum} [orderBy] The column to order secrets/folders by.
         * @param {ApiV1DashboardSecretsDetailsGetOrderDirectionEnum} [orderDirection] The direction to order secrets/folders in.
         * @param {string} [search] The text string to filter secret keys and folder names by.
         * @param {string} [tags] The tags to filter secrets by (comma separated, ie \&amp;#39;tags&amp;#x3D;billing,engineering\&amp;#39;).
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [viewSecretValue] 
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeSecrets] Whether to include project secrets in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeFolders] Whether to include project folders in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeDynamicSecrets] Whether to include dynamic project secrets in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeImports] Whether to include project secret imports in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardSecretsDetailsGet: async (projectId: string, environment: string, secretPath?: string, offset?: number, limit?: number, orderBy?: ApiV1DashboardSecretsDetailsGetOrderByEnum, orderDirection?: ApiV1DashboardSecretsDetailsGetOrderDirectionEnum, search?: string, tags?: string, viewSecretValue?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeSecrets?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeFolders?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeDynamicSecrets?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeImports?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DashboardSecretsDetailsGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DashboardSecretsDetailsGet&#x27;, &#x27;environment&#x27;, environment)
            const localVarPath &#x3D; &#x60;/api/v1/dashboard/secrets-details&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (orderBy !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderBy&#x27;] &#x3D; orderBy;
            }

            if (orderDirection !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderDirection&#x27;] &#x3D; orderDirection;
            }

            if (search !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;search&#x27;] &#x3D; search;
            }

            if (tags !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;tags&#x27;] &#x3D; tags;
            }

            if (viewSecretValue !&#x3D;&#x3D; undefined) {
                for (const [key, value] of Object.entries(viewSecretValue)) {
                    localVarQueryParameter[key] &#x3D; value;
                }
            }

            if (includeSecrets !&#x3D;&#x3D; undefined) {
                for (const [key, value] of Object.entries(includeSecrets)) {
                    localVarQueryParameter[key] &#x3D; value;
                }
            }

            if (includeFolders !&#x3D;&#x3D; undefined) {
                for (const [key, value] of Object.entries(includeFolders)) {
                    localVarQueryParameter[key] &#x3D; value;
                }
            }

            if (includeDynamicSecrets !&#x3D;&#x3D; undefined) {
                for (const [key, value] of Object.entries(includeDynamicSecrets)) {
                    localVarQueryParameter[key] &#x3D; value;
                }
            }

            if (includeImports !&#x3D;&#x3D; undefined) {
                for (const [key, value] of Object.entries(includeImports)) {
                    localVarQueryParameter[key] &#x3D; value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List project secrets overview
         * @param {string} projectId The ID of the project to list secrets/folders from.
         * @param {string} environments The slugs of the environments to list secrets/folders from (comma separated, ie \&amp;#39;environments&amp;#x3D;dev,staging,prod\&amp;#39;).
         * @param {string} [secretPath] The secret path to list secrets/folders from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th secret/folder.
         * @param {number} [limit] The number of secrets/folders to return.
         * @param {ApiV1DashboardSecretsOverviewGetOrderByEnum} [orderBy] The column to order secrets/folders by.
         * @param {ApiV1DashboardSecretsOverviewGetOrderDirectionEnum} [orderDirection] The direction to order secrets/folders in.
         * @param {string} [search] The text string to filter secret keys and folder names by.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeSecrets] Whether to include project secrets in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeFolders] Whether to include project folders in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeImports] Whether to include project secret imports in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeDynamicSecrets] Whether to include dynamic project secrets in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardSecretsOverviewGet: async (projectId: string, environments: string, secretPath?: string, offset?: number, limit?: number, orderBy?: ApiV1DashboardSecretsOverviewGetOrderByEnum, orderDirection?: ApiV1DashboardSecretsOverviewGetOrderDirectionEnum, search?: string, includeSecrets?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeFolders?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeImports?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeDynamicSecrets?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DashboardSecretsOverviewGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;environments&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DashboardSecretsOverviewGet&#x27;, &#x27;environments&#x27;, environments)
            const localVarPath &#x3D; &#x60;/api/v1/dashboard/secrets-overview&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }

            if (environments !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environments&#x27;] &#x3D; environments;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (orderBy !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderBy&#x27;] &#x3D; orderBy;
            }

            if (orderDirection !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderDirection&#x27;] &#x3D; orderDirection;
            }

            if (search !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;search&#x27;] &#x3D; search;
            }

            if (includeSecrets !&#x3D;&#x3D; undefined) {
                for (const [key, value] of Object.entries(includeSecrets)) {
                    localVarQueryParameter[key] &#x3D; value;
                }
            }

            if (includeFolders !&#x3D;&#x3D; undefined) {
                for (const [key, value] of Object.entries(includeFolders)) {
                    localVarQueryParameter[key] &#x3D; value;
                }
            }

            if (includeImports !&#x3D;&#x3D; undefined) {
                for (const [key, value] of Object.entries(includeImports)) {
                    localVarQueryParameter[key] &#x3D; value;
                }
            }

            if (includeDynamicSecrets !&#x3D;&#x3D; undefined) {
                for (const [key, value] of Object.entries(includeDynamicSecrets)) {
                    localVarQueryParameter[key] &#x3D; value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1DynamicSecretsEntraIdUsersPostRequest} apiV1DynamicSecretsEntraIdUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsEntraIdUsersPost: async (apiV1DynamicSecretsEntraIdUsersPostRequest: ApiV1DynamicSecretsEntraIdUsersPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1DynamicSecretsEntraIdUsersPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsEntraIdUsersPost&#x27;, &#x27;apiV1DynamicSecretsEntraIdUsersPostRequest&#x27;, apiV1DynamicSecretsEntraIdUsersPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/dynamic-secrets/entra-id/users&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1DynamicSecretsEntraIdUsersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project to create dynamic secret in.
         * @param {string} environmentSlug The slug of the environment to list folders from.
         * @param {string} [path] The path to list folders from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsGet: async (projectSlug: string, environmentSlug: string, path?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsGet&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            // verify required parameter &#x27;environmentSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsGet&#x27;, &#x27;environmentSlug&#x27;, environmentSlug)
            const localVarPath &#x3D; &#x60;/api/v1/dynamic-secrets&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectSlug&#x27;] &#x3D; projectSlug;
            }

            if (path !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;path&#x27;] &#x3D; path;
            }

            if (environmentSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environmentSlug&#x27;] &#x3D; environmentSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} leaseId The ID of the dynamic secret lease.
         * @param {ApiV1DynamicSecretsLeasesLeaseIdDeleteRequest} apiV1DynamicSecretsLeasesLeaseIdDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsLeasesLeaseIdDelete: async (leaseId: string, apiV1DynamicSecretsLeasesLeaseIdDeleteRequest: ApiV1DynamicSecretsLeasesLeaseIdDeleteRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;leaseId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsLeasesLeaseIdDelete&#x27;, &#x27;leaseId&#x27;, leaseId)
            // verify required parameter &#x27;apiV1DynamicSecretsLeasesLeaseIdDeleteRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsLeasesLeaseIdDelete&#x27;, &#x27;apiV1DynamicSecretsLeasesLeaseIdDeleteRequest&#x27;, apiV1DynamicSecretsLeasesLeaseIdDeleteRequest)
            const localVarPath &#x3D; &#x60;/api/v1/dynamic-secrets/leases/{leaseId}&#x60;
                .replace(&#x60;{${&quot;leaseId&quot;}}&#x60;, encodeURIComponent(String(leaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1DynamicSecretsLeasesLeaseIdDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project to create dynamic secret in.
         * @param {string} environmentSlug The slug of the environment to list folders from.
         * @param {string} leaseId The ID of the dynamic secret lease.
         * @param {string} [path] The path to list folders from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsLeasesLeaseIdGet: async (projectSlug: string, environmentSlug: string, leaseId: string, path?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsLeasesLeaseIdGet&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            // verify required parameter &#x27;environmentSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsLeasesLeaseIdGet&#x27;, &#x27;environmentSlug&#x27;, environmentSlug)
            // verify required parameter &#x27;leaseId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsLeasesLeaseIdGet&#x27;, &#x27;leaseId&#x27;, leaseId)
            const localVarPath &#x3D; &#x60;/api/v1/dynamic-secrets/leases/{leaseId}&#x60;
                .replace(&#x60;{${&quot;leaseId&quot;}}&#x60;, encodeURIComponent(String(leaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectSlug&#x27;] &#x3D; projectSlug;
            }

            if (path !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;path&#x27;] &#x3D; path;
            }

            if (environmentSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environmentSlug&#x27;] &#x3D; environmentSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} leaseId The ID of the dynamic secret lease.
         * @param {ApiV1DynamicSecretsLeasesLeaseIdRenewPostRequest} apiV1DynamicSecretsLeasesLeaseIdRenewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsLeasesLeaseIdRenewPost: async (leaseId: string, apiV1DynamicSecretsLeasesLeaseIdRenewPostRequest: ApiV1DynamicSecretsLeasesLeaseIdRenewPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;leaseId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsLeasesLeaseIdRenewPost&#x27;, &#x27;leaseId&#x27;, leaseId)
            // verify required parameter &#x27;apiV1DynamicSecretsLeasesLeaseIdRenewPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsLeasesLeaseIdRenewPost&#x27;, &#x27;apiV1DynamicSecretsLeasesLeaseIdRenewPostRequest&#x27;, apiV1DynamicSecretsLeasesLeaseIdRenewPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/dynamic-secrets/leases/{leaseId}/renew&#x60;
                .replace(&#x60;{${&quot;leaseId&quot;}}&#x60;, encodeURIComponent(String(leaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1DynamicSecretsLeasesLeaseIdRenewPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1DynamicSecretsLeasesPostRequest} apiV1DynamicSecretsLeasesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsLeasesPost: async (apiV1DynamicSecretsLeasesPostRequest: ApiV1DynamicSecretsLeasesPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1DynamicSecretsLeasesPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsLeasesPost&#x27;, &#x27;apiV1DynamicSecretsLeasesPostRequest&#x27;, apiV1DynamicSecretsLeasesPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/dynamic-secrets/leases&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1DynamicSecretsLeasesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name The name of the dynamic secret.
         * @param {ApiV1DynamicSecretsNameDeleteRequest} apiV1DynamicSecretsNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsNameDelete: async (name: string, apiV1DynamicSecretsNameDeleteRequest: ApiV1DynamicSecretsNameDeleteRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;name&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsNameDelete&#x27;, &#x27;name&#x27;, name)
            // verify required parameter &#x27;apiV1DynamicSecretsNameDeleteRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsNameDelete&#x27;, &#x27;apiV1DynamicSecretsNameDeleteRequest&#x27;, apiV1DynamicSecretsNameDeleteRequest)
            const localVarPath &#x3D; &#x60;/api/v1/dynamic-secrets/{name}&#x60;
                .replace(&#x60;{${&quot;name&quot;}}&#x60;, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1DynamicSecretsNameDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project to create dynamic secret in.
         * @param {string} environmentSlug The slug of the environment to list folders from.
         * @param {string} name The name of the dynamic secret.
         * @param {string} [path] The path to list folders from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsNameGet: async (projectSlug: string, environmentSlug: string, name: string, path?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsNameGet&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            // verify required parameter &#x27;environmentSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsNameGet&#x27;, &#x27;environmentSlug&#x27;, environmentSlug)
            // verify required parameter &#x27;name&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsNameGet&#x27;, &#x27;name&#x27;, name)
            const localVarPath &#x3D; &#x60;/api/v1/dynamic-secrets/{name}&#x60;
                .replace(&#x60;{${&quot;name&quot;}}&#x60;, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectSlug&#x27;] &#x3D; projectSlug;
            }

            if (path !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;path&#x27;] &#x3D; path;
            }

            if (environmentSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environmentSlug&#x27;] &#x3D; environmentSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project to create dynamic secret in.
         * @param {string} environmentSlug The slug of the environment to list folders from.
         * @param {string} name The name of the dynamic secret.
         * @param {string} [path] The path to list folders from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsNameLeasesGet: async (projectSlug: string, environmentSlug: string, name: string, path?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsNameLeasesGet&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            // verify required parameter &#x27;environmentSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsNameLeasesGet&#x27;, &#x27;environmentSlug&#x27;, environmentSlug)
            // verify required parameter &#x27;name&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsNameLeasesGet&#x27;, &#x27;name&#x27;, name)
            const localVarPath &#x3D; &#x60;/api/v1/dynamic-secrets/{name}/leases&#x60;
                .replace(&#x60;{${&quot;name&quot;}}&#x60;, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectSlug&#x27;] &#x3D; projectSlug;
            }

            if (path !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;path&#x27;] &#x3D; path;
            }

            if (environmentSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environmentSlug&#x27;] &#x3D; environmentSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name The name of the dynamic secret.
         * @param {ApiV1DynamicSecretsNamePatchRequest} apiV1DynamicSecretsNamePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsNamePatch: async (name: string, apiV1DynamicSecretsNamePatchRequest: ApiV1DynamicSecretsNamePatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;name&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsNamePatch&#x27;, &#x27;name&#x27;, name)
            // verify required parameter &#x27;apiV1DynamicSecretsNamePatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsNamePatch&#x27;, &#x27;apiV1DynamicSecretsNamePatchRequest&#x27;, apiV1DynamicSecretsNamePatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/dynamic-secrets/{name}&#x60;
                .replace(&#x60;{${&quot;name&quot;}}&#x60;, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1DynamicSecretsNamePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1DynamicSecretsPostRequest} apiV1DynamicSecretsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsPost: async (apiV1DynamicSecretsPostRequest: ApiV1DynamicSecretsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1DynamicSecretsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1DynamicSecretsPost&#x27;, &#x27;apiV1DynamicSecretsPostRequest&#x27;, apiV1DynamicSecretsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/dynamic-secrets&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1DynamicSecretsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalGroupMappingsGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/external-group-mappings&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ExternalGroupMappingsPutRequest} apiV1ExternalGroupMappingsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalGroupMappingsPut: async (apiV1ExternalGroupMappingsPutRequest: ApiV1ExternalGroupMappingsPutRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1ExternalGroupMappingsPutRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ExternalGroupMappingsPut&#x27;, &#x27;apiV1ExternalGroupMappingsPutRequest&#x27;, apiV1ExternalGroupMappingsPutRequest)
            const localVarPath &#x3D; &#x60;/api/v1/external-group-mappings&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PUT&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1ExternalGroupMappingsPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ExternalKmsGcpKeysPostRequest} [apiV1ExternalKmsGcpKeysPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsGcpKeysPost: async (apiV1ExternalKmsGcpKeysPostRequest?: ApiV1ExternalKmsGcpKeysPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/external-kms/gcp/keys&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1ExternalKmsGcpKeysPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/external-kms&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsIdDelete: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ExternalKmsIdDelete&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/external-kms/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsIdGet: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ExternalKmsIdGet&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/external-kms/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1ExternalKmsIdPatchRequest} apiV1ExternalKmsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsIdPatch: async (id: string, apiV1ExternalKmsIdPatchRequest: ApiV1ExternalKmsIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ExternalKmsIdPatch&#x27;, &#x27;id&#x27;, id)
            // verify required parameter &#x27;apiV1ExternalKmsIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ExternalKmsIdPatch&#x27;, &#x27;apiV1ExternalKmsIdPatchRequest&#x27;, apiV1ExternalKmsIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/external-kms/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1ExternalKmsIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsNameNameGet: async (name: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;name&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ExternalKmsNameNameGet&#x27;, &#x27;name&#x27;, name)
            const localVarPath &#x3D; &#x60;/api/v1/external-kms/name/{name}&#x60;
                .replace(&#x60;{${&quot;name&quot;}}&#x60;, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ExternalKmsPostRequest} apiV1ExternalKmsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsPost: async (apiV1ExternalKmsPostRequest: ApiV1ExternalKmsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1ExternalKmsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ExternalKmsPost&#x27;, &#x27;apiV1ExternalKmsPostRequest&#x27;, apiV1ExternalKmsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/external-kms&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1ExternalKmsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update folders by batch
         * @param {ApiV1FoldersBatchPatchRequest} apiV1FoldersBatchPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FoldersBatchPatch: async (apiV1FoldersBatchPatchRequest: ApiV1FoldersBatchPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1FoldersBatchPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1FoldersBatchPatch&#x27;, &#x27;apiV1FoldersBatchPatchRequest&#x27;, apiV1FoldersBatchPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/folders/batch&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1FoldersBatchPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a folder
         * @param {string} folderIdOrName The ID or name of the folder to delete.
         * @param {ApiV1FoldersFolderIdOrNameDeleteRequest} apiV1FoldersFolderIdOrNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FoldersFolderIdOrNameDelete: async (folderIdOrName: string, apiV1FoldersFolderIdOrNameDeleteRequest: ApiV1FoldersFolderIdOrNameDeleteRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;folderIdOrName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1FoldersFolderIdOrNameDelete&#x27;, &#x27;folderIdOrName&#x27;, folderIdOrName)
            // verify required parameter &#x27;apiV1FoldersFolderIdOrNameDeleteRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1FoldersFolderIdOrNameDelete&#x27;, &#x27;apiV1FoldersFolderIdOrNameDeleteRequest&#x27;, apiV1FoldersFolderIdOrNameDeleteRequest)
            const localVarPath &#x3D; &#x60;/api/v1/folders/{folderIdOrName}&#x60;
                .replace(&#x60;{${&quot;folderIdOrName&quot;}}&#x60;, encodeURIComponent(String(folderIdOrName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1FoldersFolderIdOrNameDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update folder
         * @param {string} folderId The ID of the folder to update.
         * @param {ApiV1FoldersFolderIdPatchRequest} apiV1FoldersFolderIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FoldersFolderIdPatch: async (folderId: string, apiV1FoldersFolderIdPatchRequest: ApiV1FoldersFolderIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;folderId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1FoldersFolderIdPatch&#x27;, &#x27;folderId&#x27;, folderId)
            // verify required parameter &#x27;apiV1FoldersFolderIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1FoldersFolderIdPatch&#x27;, &#x27;apiV1FoldersFolderIdPatchRequest&#x27;, apiV1FoldersFolderIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/folders/{folderId}&#x60;
                .replace(&#x60;{${&quot;folderId&quot;}}&#x60;, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1FoldersFolderIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get folders
         * @param {string} workspaceId The ID of the project to list folders from.
         * @param {string} environment The slug of the environment to list folders from.
         * @param {string} [path] The path to list folders from.
         * @param {string} [directory] The directory to list folders from. (Deprecated in favor of path)
         * @param {ApiV1FoldersGetRecursiveParameter} [recursive] Whether or not to fetch all folders from the specified base path, and all of its subdirectories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FoldersGet: async (workspaceId: string, environment: string, path?: string, directory?: string, recursive?: ApiV1FoldersGetRecursiveParameter, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1FoldersGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1FoldersGet&#x27;, &#x27;environment&#x27;, environment)
            const localVarPath &#x3D; &#x60;/api/v1/folders&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (path !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;path&#x27;] &#x3D; path;
            }

            if (directory !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;directory&#x27;] &#x3D; directory;
            }

            if (recursive !&#x3D;&#x3D; undefined) {
                for (const [key, value] of Object.entries(recursive)) {
                    localVarQueryParameter[key] &#x3D; value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get folder by id
         * @param {string} id The ID of the folder to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FoldersIdGet: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1FoldersIdGet&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/folders/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create folders
         * @param {ApiV1FoldersPostRequest} apiV1FoldersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FoldersPost: async (apiV1FoldersPostRequest: ApiV1FoldersPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1FoldersPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1FoldersPost&#x27;, &#x27;apiV1FoldersPostRequest&#x27;, apiV1FoldersPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/folders&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1FoldersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1GatewaysExchangeCertPostRequest} apiV1GatewaysExchangeCertPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysExchangeCertPost: async (apiV1GatewaysExchangeCertPostRequest: ApiV1GatewaysExchangeCertPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1GatewaysExchangeCertPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GatewaysExchangeCertPost&#x27;, &#x27;apiV1GatewaysExchangeCertPostRequest&#x27;, apiV1GatewaysExchangeCertPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/gateways/exchange-cert&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1GatewaysExchangeCertPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysGet: async (projectId?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/gateways&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysHeartbeatPost: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/gateways/heartbeat&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysIdDelete: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GatewaysIdDelete&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/gateways/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysIdGet: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GatewaysIdGet&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/gateways/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1GatewaysIdPatchRequest} [apiV1GatewaysIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysIdPatch: async (id: string, apiV1GatewaysIdPatchRequest?: ApiV1GatewaysIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GatewaysIdPatch&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/gateways/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1GatewaysIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysProjectsProjectIdGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GatewaysProjectsProjectIdGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/gateways/projects/{projectId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysRegisterIdentityPost: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/gateways/register-identity&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/groups&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The ID of the group to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsIdDelete: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GroupsIdDelete&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/groups/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The ID of the group to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsIdGet: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GroupsIdGet&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/groups/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The ID of the group to update.
         * @param {ApiV1GroupsIdPatchRequest} [apiV1GroupsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsIdPatch: async (id: string, apiV1GroupsIdPatchRequest?: ApiV1GroupsIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GroupsIdPatch&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/groups/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1GroupsIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The ID of the group to list users for.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th user.
         * @param {number} [limit] The number of users to return.
         * @param {string} [username] The username to search for.
         * @param {string} [search] The text string that user email or name will be filtered by.
         * @param {ApiV1GroupsIdUsersGetFilterEnum} [filter] Whether to filter the list of returned users. \&amp;#39;existingMembers\&amp;#39; will only return existing users in the group, \&amp;#39;nonMembers\&amp;#39; will only return users not in the group, undefined will return all users in the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsIdUsersGet: async (id: string, offset?: number, limit?: number, username?: string, search?: string, filter?: ApiV1GroupsIdUsersGetFilterEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GroupsIdUsersGet&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/groups/{id}/users&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (username !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;username&#x27;] &#x3D; username;
            }

            if (search !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;search&#x27;] &#x3D; search;
            }

            if (filter !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;filter&#x27;] &#x3D; filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The ID of the group to remove the user from.
         * @param {string} username The username of the user to remove from the group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsIdUsersUsernameDelete: async (id: string, username: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GroupsIdUsersUsernameDelete&#x27;, &#x27;id&#x27;, id)
            // verify required parameter &#x27;username&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GroupsIdUsersUsernameDelete&#x27;, &#x27;username&#x27;, username)
            const localVarPath &#x3D; &#x60;/api/v1/groups/{id}/users/{username}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)))
                .replace(&#x60;{${&quot;username&quot;}}&#x60;, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The ID of the group to add the user to.
         * @param {string} username The username of the user to add to the group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsIdUsersUsernamePost: async (id: string, username: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GroupsIdUsersUsernamePost&#x27;, &#x27;id&#x27;, id)
            // verify required parameter &#x27;username&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GroupsIdUsersUsernamePost&#x27;, &#x27;username&#x27;, username)
            const localVarPath &#x3D; &#x60;/api/v1/groups/{id}/users/{username}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)))
                .replace(&#x60;{${&quot;username&quot;}}&#x60;, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1GroupsPostRequest} apiV1GroupsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsPost: async (apiV1GroupsPostRequest: ApiV1GroupsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1GroupsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1GroupsPost&#x27;, &#x27;apiV1GroupsPostRequest&#x27;, apiV1GroupsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/groups&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1GroupsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List identities
         * @param {string} orgId The ID of the organization to list identities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IdentitiesGet: async (orgId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;orgId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IdentitiesGet&#x27;, &#x27;orgId&#x27;, orgId)
            const localVarPath &#x3D; &#x60;/api/v1/identities&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orgId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orgId&#x27;] &#x3D; orgId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete identity
         * @param {string} identityId The ID of the identity to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IdentitiesIdentityIdDelete: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IdentitiesIdentityIdDelete&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an identity by id
         * @param {string} identityId The ID of the identity to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IdentitiesIdentityIdGet: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IdentitiesIdentityIdGet&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List project memberships that identity with id is part of
         * @param {string} identityId The ID of the identity to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IdentitiesIdentityIdIdentityMembershipsGet: async (identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IdentitiesIdentityIdIdentityMembershipsGet&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/identities/{identityId}/identity-memberships&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update identity
         * @param {string} identityId The ID of the identity to update.
         * @param {ApiV1IdentitiesIdentityIdPatchRequest} [apiV1IdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IdentitiesIdentityIdPatch: async (identityId: string, apiV1IdentitiesIdentityIdPatchRequest?: ApiV1IdentitiesIdentityIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IdentitiesIdentityIdPatch&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v1/identities/{identityId}&#x60;
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1IdentitiesIdentityIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create identity
         * @param {ApiV1IdentitiesPostRequest} apiV1IdentitiesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IdentitiesPost: async (apiV1IdentitiesPostRequest: ApiV1IdentitiesPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1IdentitiesPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IdentitiesPost&#x27;, &#x27;apiV1IdentitiesPostRequest&#x27;, apiV1IdentitiesPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/identities&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1IdentitiesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create the integration authentication object required for syncing secrets.
         * @param {ApiV1IntegrationAuthAccessTokenPostRequest} apiV1IntegrationAuthAccessTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthAccessTokenPost: async (apiV1IntegrationAuthAccessTokenPostRequest: ApiV1IntegrationAuthAccessTokenPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1IntegrationAuthAccessTokenPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthAccessTokenPost&#x27;, &#x27;apiV1IntegrationAuthAccessTokenPostRequest&#x27;, apiV1IntegrationAuthAccessTokenPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/access-token&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1IntegrationAuthAccessTokenPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove all integration\&#x27;s auth object from the project.
         * @param {string} integration The slug of the integration to be unauthorized.
         * @param {string} projectId The ID of the project to delete the integration auth from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthDelete: async (integration: string, projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integration&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthDelete&#x27;, &#x27;integration&#x27;, integration)
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthDelete&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (integration !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;integration&#x27;] &#x3D; integration;
            }

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {string} [teamId] 
         * @param {string} [azureDevOpsOrgName] 
         * @param {string} [workspaceSlug] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdAppsGet: async (integrationAuthId: string, teamId?: string, azureDevOpsOrgName?: string, workspaceSlug?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdAppsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/apps&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (teamId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;teamId&#x27;] &#x3D; teamId;
            }

            if (azureDevOpsOrgName !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;azureDevOpsOrgName&#x27;] &#x3D; azureDevOpsOrgName;
            }

            if (workspaceSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceSlug&#x27;] &#x3D; workspaceSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} region 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet: async (region: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;region&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet&#x27;, &#x27;region&#x27;, region)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/aws-secrets-manager/kms-keys&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (region !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;region&#x27;] &#x3D; region;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceSlug 
         * @param {string} repoSlug 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdBitbucketEnvironmentsGet: async (workspaceSlug: string, repoSlug: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdBitbucketEnvironmentsGet&#x27;, &#x27;workspaceSlug&#x27;, workspaceSlug)
            // verify required parameter &#x27;repoSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdBitbucketEnvironmentsGet&#x27;, &#x27;repoSlug&#x27;, repoSlug)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdBitbucketEnvironmentsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/bitbucket/environments&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (workspaceSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceSlug&#x27;] &#x3D; workspaceSlug;
            }

            if (repoSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;repoSlug&#x27;] &#x3D; repoSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet: async (integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/bitbucket/workspaces&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet: async (accountId: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;accountId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet&#x27;, &#x27;accountId&#x27;, accountId)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/checkly/groups&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (accountId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;accountId&#x27;] &#x3D; accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdCircleciOrganizationsGet: async (integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdCircleciOrganizationsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/circleci/organizations&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an integration auth object by object id.
         * @param {string} integrationAuthId The ID of integration authentication object to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdDelete: async (integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdDelete&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {ApiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest} apiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdDuplicatePost: async (integrationAuthId: string, apiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest: ApiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdDuplicatePost&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            // verify required parameter &#x27;apiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdDuplicatePost&#x27;, &#x27;apiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest&#x27;, apiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/duplicate&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of an integration authorization by auth object id.
         * @param {string} integrationAuthId The ID of integration authentication object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdGet: async (integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repoOwner 
         * @param {string} repoName 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet: async (repoOwner: string, repoName: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;repoOwner&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet&#x27;, &#x27;repoOwner&#x27;, repoOwner)
            // verify required parameter &#x27;repoName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet&#x27;, &#x27;repoName&#x27;, repoName)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/github/envs&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (repoOwner !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;repoOwner&#x27;] &#x3D; repoOwner;
            }

            if (repoName !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;repoName&#x27;] &#x3D; repoName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet: async (integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/github/orgs&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet: async (integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/heroku/pipelines&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet: async (appId: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;appId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet&#x27;, &#x27;appId&#x27;, appId)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/northflank/secret-groups&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (appId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;appId&#x27;] &#x3D; appId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGetScopeEnum} scope 
         * @param {string} spaceId 
         * @param {string} resourceId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGet: async (scope: ApiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGetScopeEnum, spaceId: string, resourceId: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;scope&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGet&#x27;, &#x27;scope&#x27;, scope)
            // verify required parameter &#x27;spaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGet&#x27;, &#x27;spaceId&#x27;, spaceId)
            // verify required parameter &#x27;resourceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGet&#x27;, &#x27;resourceId&#x27;, resourceId)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/octopus-deploy/scope-values&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (scope !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;scope&#x27;] &#x3D; scope;
            }

            if (spaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;spaceId&#x27;] &#x3D; spaceId;
            }

            if (resourceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;resourceId&#x27;] &#x3D; resourceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdOctopusDeploySpacesGet: async (integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdOctopusDeploySpacesGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/octopus-deploy/spaces&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the integration authentication object required for syncing secrets.
         * @param {string} integrationAuthId The ID of integration authentication object to update.
         * @param {ApiV1IntegrationAuthIntegrationAuthIdPatchRequest} [apiV1IntegrationAuthIntegrationAuthIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdPatch: async (integrationAuthId: string, apiV1IntegrationAuthIntegrationAuthIdPatchRequest?: ApiV1IntegrationAuthIntegrationAuthIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdPatch&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1IntegrationAuthIntegrationAuthIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} environmentId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet: async (environmentId: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;environmentId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet&#x27;, &#x27;environmentId&#x27;, environmentId)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/qovery/apps&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (environmentId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environmentId&#x27;] &#x3D; environmentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} environmentId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet: async (environmentId: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;environmentId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet&#x27;, &#x27;environmentId&#x27;, environmentId)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/qovery/containers&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (environmentId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environmentId&#x27;] &#x3D; environmentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet: async (projectId: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/qovery/environments&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} environmentId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet: async (environmentId: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;environmentId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet&#x27;, &#x27;environmentId&#x27;, environmentId)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/qovery/jobs&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (environmentId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environmentId&#x27;] &#x3D; environmentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdQoveryOrgsGet: async (integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdQoveryOrgsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/qovery/orgs&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet: async (orgId: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;orgId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet&#x27;, &#x27;orgId&#x27;, orgId)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/qovery/projects&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (orgId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orgId&#x27;] &#x3D; orgId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdRailwayEnvironmentsGet: async (appId: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;appId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdRailwayEnvironmentsGet&#x27;, &#x27;appId&#x27;, appId)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdRailwayEnvironmentsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/railway/environments&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (appId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;appId&#x27;] &#x3D; appId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet: async (appId: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;appId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet&#x27;, &#x27;appId&#x27;, appId)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/railway/services&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (appId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;appId&#x27;] &#x3D; appId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet: async (appId: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;appId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet&#x27;, &#x27;appId&#x27;, appId)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/teamcity/build-configs&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (appId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;appId&#x27;] &#x3D; appId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdTeamsGet: async (integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdTeamsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/teams&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet: async (appId: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;appId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet&#x27;, &#x27;appId&#x27;, appId)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/vercel/branches&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (appId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;appId&#x27;] &#x3D; appId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} teamId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdVercelCustomEnvironmentsGet: async (teamId: string, integrationAuthId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;teamId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdVercelCustomEnvironmentsGet&#x27;, &#x27;teamId&#x27;, teamId)
            // verify required parameter &#x27;integrationAuthId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthIntegrationAuthIdVercelCustomEnvironmentsGet&#x27;, &#x27;integrationAuthId&#x27;, integrationAuthId)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/{integrationAuthId}/vercel/custom-environments&#x60;
                .replace(&#x60;{${&quot;integrationAuthId&quot;}}&#x60;, encodeURIComponent(String(integrationAuthId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (teamId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;teamId&#x27;] &#x3D; teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of integrations available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationOptionsGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/integration-options&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1IntegrationAuthOauthTokenPostRequest} apiV1IntegrationAuthOauthTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthOauthTokenPost: async (apiV1IntegrationAuthOauthTokenPostRequest: ApiV1IntegrationAuthOauthTokenPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1IntegrationAuthOauthTokenPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationAuthOauthTokenPost&#x27;, &#x27;apiV1IntegrationAuthOauthTokenPostRequest&#x27;, apiV1IntegrationAuthOauthTokenPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/integration-auth/oauth-token&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1IntegrationAuthOauthTokenPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an integration using the integration object ID
         * @param {string} integrationId The ID of the integration object.
         * @param {ApiV1IntegrationIntegrationIdDeleteShouldDeleteIntegrationSecretsEnum} [shouldDeleteIntegrationSecrets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationIntegrationIdDelete: async (integrationId: string, shouldDeleteIntegrationSecrets?: ApiV1IntegrationIntegrationIdDeleteShouldDeleteIntegrationSecretsEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationIntegrationIdDelete&#x27;, &#x27;integrationId&#x27;, integrationId)
            const localVarPath &#x3D; &#x60;/api/v1/integration/{integrationId}&#x60;
                .replace(&#x60;{${&quot;integrationId&quot;}}&#x60;, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (shouldDeleteIntegrationSecrets !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;shouldDeleteIntegrationSecrets&#x27;] &#x3D; shouldDeleteIntegrationSecrets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an integration by integration id
         * @param {string} integrationId The ID of the integration object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationIntegrationIdGet: async (integrationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationIntegrationIdGet&#x27;, &#x27;integrationId&#x27;, integrationId)
            const localVarPath &#x3D; &#x60;/api/v1/integration/{integrationId}&#x60;
                .replace(&#x60;{${&quot;integrationId&quot;}}&#x60;, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an integration by integration id
         * @param {string} integrationId The ID of the integration object.
         * @param {ApiV1IntegrationIntegrationIdPatchRequest} [apiV1IntegrationIntegrationIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationIntegrationIdPatch: async (integrationId: string, apiV1IntegrationIntegrationIdPatchRequest?: ApiV1IntegrationIntegrationIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationIntegrationIdPatch&#x27;, &#x27;integrationId&#x27;, integrationId)
            const localVarPath &#x3D; &#x60;/api/v1/integration/{integrationId}&#x60;
                .replace(&#x60;{${&quot;integrationId&quot;}}&#x60;, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1IntegrationIntegrationIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manually trigger sync of an integration by integration id
         * @param {string} integrationId The ID of the integration object to manually sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationIntegrationIdSyncPost: async (integrationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;integrationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationIntegrationIdSyncPost&#x27;, &#x27;integrationId&#x27;, integrationId)
            const localVarPath &#x3D; &#x60;/api/v1/integration/{integrationId}/sync&#x60;
                .replace(&#x60;{${&quot;integrationId&quot;}}&#x60;, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an integration to sync secrets.
         * @param {ApiV1IntegrationPostRequest} apiV1IntegrationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationPost: async (apiV1IntegrationPostRequest: ApiV1IntegrationPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1IntegrationPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1IntegrationPost&#x27;, &#x27;apiV1IntegrationPostRequest&#x27;, apiV1IntegrationPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/integration&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1IntegrationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1InviteOrgSignupPostRequest} apiV1InviteOrgSignupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1InviteOrgSignupPost: async (apiV1InviteOrgSignupPostRequest: ApiV1InviteOrgSignupPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1InviteOrgSignupPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1InviteOrgSignupPost&#x27;, &#x27;apiV1InviteOrgSignupPostRequest&#x27;, apiV1InviteOrgSignupPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/invite-org/signup&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1InviteOrgSignupPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1InviteOrgSignupResendPostRequest} apiV1InviteOrgSignupResendPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1InviteOrgSignupResendPost: async (apiV1InviteOrgSignupResendPostRequest: ApiV1InviteOrgSignupResendPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1InviteOrgSignupResendPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1InviteOrgSignupResendPost&#x27;, &#x27;apiV1InviteOrgSignupResendPostRequest&#x27;, apiV1InviteOrgSignupResendPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/invite-org/signup-resend&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1InviteOrgSignupResendPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1InviteOrgVerifyPostRequest} apiV1InviteOrgVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1InviteOrgVerifyPost: async (apiV1InviteOrgVerifyPostRequest: ApiV1InviteOrgVerifyPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1InviteOrgVerifyPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1InviteOrgVerifyPost&#x27;, &#x27;apiV1InviteOrgVerifyPostRequest&#x27;, apiV1InviteOrgVerifyPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/invite-org/verify&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1InviteOrgVerifyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List KMIP clients
         * @param {string} projectId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {ApiV1KmipClientsGetOrderByEnum} [orderBy] 
         * @param {ApiV1KmipClientsGetOrderDirectionEnum} [orderDirection] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipClientsGet: async (projectId: string, offset?: number, limit?: number, orderBy?: ApiV1KmipClientsGetOrderByEnum, orderDirection?: ApiV1KmipClientsGetOrderDirectionEnum, search?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipClientsGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/clients&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (orderBy !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderBy&#x27;] &#x3D; orderBy;
            }

            if (orderDirection !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderDirection&#x27;] &#x3D; orderDirection;
            }

            if (search !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;search&#x27;] &#x3D; search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1KmipClientsIdCertificatesPostRequest} apiV1KmipClientsIdCertificatesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipClientsIdCertificatesPost: async (id: string, apiV1KmipClientsIdCertificatesPostRequest: ApiV1KmipClientsIdCertificatesPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipClientsIdCertificatesPost&#x27;, &#x27;id&#x27;, id)
            // verify required parameter &#x27;apiV1KmipClientsIdCertificatesPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipClientsIdCertificatesPost&#x27;, &#x27;apiV1KmipClientsIdCertificatesPostRequest&#x27;, apiV1KmipClientsIdCertificatesPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/clients/{id}/certificates&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1KmipClientsIdCertificatesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipClientsIdDelete: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipClientsIdDelete&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/clients/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipClientsIdGet: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipClientsIdGet&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/clients/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1KmipClientsIdPatchRequest} apiV1KmipClientsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipClientsIdPatch: async (id: string, apiV1KmipClientsIdPatchRequest: ApiV1KmipClientsIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipClientsIdPatch&#x27;, &#x27;id&#x27;, id)
            // verify required parameter &#x27;apiV1KmipClientsIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipClientsIdPatch&#x27;, &#x27;apiV1KmipClientsIdPatchRequest&#x27;, apiV1KmipClientsIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/clients/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1KmipClientsIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1KmipClientsPostRequest} apiV1KmipClientsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipClientsPost: async (apiV1KmipClientsPostRequest: ApiV1KmipClientsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1KmipClientsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipClientsPost&#x27;, &#x27;apiV1KmipClientsPostRequest&#x27;, apiV1KmipClientsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/clients&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1KmipClientsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/kmip&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1KmipPostRequest} apiV1KmipPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipPost: async (apiV1KmipPostRequest: ApiV1KmipPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1KmipPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipPost&#x27;, &#x27;apiV1KmipPostRequest&#x27;, apiV1KmipPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kmip&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1KmipPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1KmipServerRegistrationPostRequest} apiV1KmipServerRegistrationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipServerRegistrationPost: async (apiV1KmipServerRegistrationPostRequest: ApiV1KmipServerRegistrationPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1KmipServerRegistrationPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipServerRegistrationPost&#x27;, &#x27;apiV1KmipServerRegistrationPostRequest&#x27;, apiV1KmipServerRegistrationPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/server-registration&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1KmipServerRegistrationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * KMIP endpoint for activating managed object
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecActivatePost: async (apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretRotationsRestartPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipSpecActivatePost&#x27;, &#x27;apiV1SecretRotationsRestartPostRequest&#x27;, apiV1SecretRotationsRestartPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/spec/activate&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretRotationsRestartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * KMIP endpoint for creating managed objects
         * @param {ApiV1KmipSpecCreatePostRequest} apiV1KmipSpecCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecCreatePost: async (apiV1KmipSpecCreatePostRequest: ApiV1KmipSpecCreatePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1KmipSpecCreatePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipSpecCreatePost&#x27;, &#x27;apiV1KmipSpecCreatePostRequest&#x27;, apiV1KmipSpecCreatePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/spec/create&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1KmipSpecCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * KMIP endpoint for destroying managed objects
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecDestroyPost: async (apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretRotationsRestartPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipSpecDestroyPost&#x27;, &#x27;apiV1SecretRotationsRestartPostRequest&#x27;, apiV1SecretRotationsRestartPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/spec/destroy&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretRotationsRestartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * KMIP endpoint for getting attributes of managed object
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecGetAttributesPost: async (apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretRotationsRestartPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipSpecGetAttributesPost&#x27;, &#x27;apiV1SecretRotationsRestartPostRequest&#x27;, apiV1SecretRotationsRestartPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/spec/get-attributes&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretRotationsRestartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * KMIP endpoint for getting managed objects
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecGetPost: async (apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretRotationsRestartPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipSpecGetPost&#x27;, &#x27;apiV1SecretRotationsRestartPostRequest&#x27;, apiV1SecretRotationsRestartPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/spec/get&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretRotationsRestartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * KMIP endpoint for locating managed objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecLocatePost: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/kmip/spec/locate&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * KMIP endpoint for registering managed object
         * @param {ApiV1KmipSpecRegisterPostRequest} apiV1KmipSpecRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecRegisterPost: async (apiV1KmipSpecRegisterPostRequest: ApiV1KmipSpecRegisterPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1KmipSpecRegisterPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipSpecRegisterPost&#x27;, &#x27;apiV1KmipSpecRegisterPostRequest&#x27;, apiV1KmipSpecRegisterPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/spec/register&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1KmipSpecRegisterPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * KMIP endpoint for revoking managed object
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecRevokePost: async (apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretRotationsRestartPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmipSpecRevokePost&#x27;, &#x27;apiV1SecretRotationsRestartPostRequest&#x27;, apiV1SecretRotationsRestartPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kmip/spec/revoke&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretRotationsRestartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List KMS keys
         * @param {string} projectId The ID of the project to list keys from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th key.
         * @param {number} [limit] The number of keys to return.
         * @param {ApiV1KmsKeysGetOrderByEnum} [orderBy] The column to order keys by.
         * @param {ApiV1KmsKeysGetOrderDirectionEnum} [orderDirection] The direction to order keys in.
         * @param {string} [search] The text string to filter key names by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysGet: async (projectId: string, offset?: number, limit?: number, orderBy?: ApiV1KmsKeysGetOrderByEnum, orderDirection?: ApiV1KmsKeysGetOrderDirectionEnum, search?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmsKeysGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/kms/keys&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (orderBy !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderBy&#x27;] &#x3D; orderBy;
            }

            if (orderDirection !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderDirection&#x27;] &#x3D; orderDirection;
            }

            if (search !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;search&#x27;] &#x3D; search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Decrypt data with KMS key
         * @param {string} keyId The ID of the key to decrypt the data with.
         * @param {ApiV1KmsKeysKeyIdDecryptPostRequest} apiV1KmsKeysKeyIdDecryptPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysKeyIdDecryptPost: async (keyId: string, apiV1KmsKeysKeyIdDecryptPostRequest: ApiV1KmsKeysKeyIdDecryptPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;keyId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmsKeysKeyIdDecryptPost&#x27;, &#x27;keyId&#x27;, keyId)
            // verify required parameter &#x27;apiV1KmsKeysKeyIdDecryptPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmsKeysKeyIdDecryptPost&#x27;, &#x27;apiV1KmsKeysKeyIdDecryptPostRequest&#x27;, apiV1KmsKeysKeyIdDecryptPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kms/keys/{keyId}/decrypt&#x60;
                .replace(&#x60;{${&quot;keyId&quot;}}&#x60;, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1KmsKeysKeyIdDecryptPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete KMS key
         * @param {string} keyId The ID of the key to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysKeyIdDelete: async (keyId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;keyId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmsKeysKeyIdDelete&#x27;, &#x27;keyId&#x27;, keyId)
            const localVarPath &#x3D; &#x60;/api/v1/kms/keys/{keyId}&#x60;
                .replace(&#x60;{${&quot;keyId&quot;}}&#x60;, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Encrypt data with KMS key
         * @param {string} keyId The ID of the key to encrypt the data with.
         * @param {ApiV1KmsKeysKeyIdEncryptPostRequest} apiV1KmsKeysKeyIdEncryptPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysKeyIdEncryptPost: async (keyId: string, apiV1KmsKeysKeyIdEncryptPostRequest: ApiV1KmsKeysKeyIdEncryptPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;keyId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmsKeysKeyIdEncryptPost&#x27;, &#x27;keyId&#x27;, keyId)
            // verify required parameter &#x27;apiV1KmsKeysKeyIdEncryptPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmsKeysKeyIdEncryptPost&#x27;, &#x27;apiV1KmsKeysKeyIdEncryptPostRequest&#x27;, apiV1KmsKeysKeyIdEncryptPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kms/keys/{keyId}/encrypt&#x60;
                .replace(&#x60;{${&quot;keyId&quot;}}&#x60;, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1KmsKeysKeyIdEncryptPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get KMS key by ID
         * @param {string} keyId The ID of the KMS key to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysKeyIdGet: async (keyId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;keyId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmsKeysKeyIdGet&#x27;, &#x27;keyId&#x27;, keyId)
            const localVarPath &#x3D; &#x60;/api/v1/kms/keys/{keyId}&#x60;
                .replace(&#x60;{${&quot;keyId&quot;}}&#x60;, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update KMS key
         * @param {string} keyId The ID of the key to be updated.
         * @param {ApiV1KmsKeysKeyIdPatchRequest} [apiV1KmsKeysKeyIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysKeyIdPatch: async (keyId: string, apiV1KmsKeysKeyIdPatchRequest?: ApiV1KmsKeysKeyIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;keyId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmsKeysKeyIdPatch&#x27;, &#x27;keyId&#x27;, keyId)
            const localVarPath &#x3D; &#x60;/api/v1/kms/keys/{keyId}&#x60;
                .replace(&#x60;{${&quot;keyId&quot;}}&#x60;, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1KmsKeysKeyIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get KMS key by Name
         * @param {string} projectId The ID of the project the key belongs to.
         * @param {string} keyName The name of the KMS key to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysKeyNameKeyNameGet: async (projectId: string, keyName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmsKeysKeyNameKeyNameGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;keyName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmsKeysKeyNameKeyNameGet&#x27;, &#x27;keyName&#x27;, keyName)
            const localVarPath &#x3D; &#x60;/api/v1/kms/keys/key-name/{keyName}&#x60;
                .replace(&#x60;{${&quot;keyName&quot;}}&#x60;, encodeURIComponent(String(keyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create KMS key
         * @param {ApiV1KmsKeysPostRequest} apiV1KmsKeysPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysPost: async (apiV1KmsKeysPostRequest: ApiV1KmsKeysPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1KmsKeysPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1KmsKeysPost&#x27;, &#x27;apiV1KmsKeysPostRequest&#x27;, apiV1KmsKeysPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/kms/keys&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1KmsKeysPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} configId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigConfigIdGroupMapsGet: async (configId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;configId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1LdapConfigConfigIdGroupMapsGet&#x27;, &#x27;configId&#x27;, configId)
            const localVarPath &#x3D; &#x60;/api/v1/ldap/config/{configId}/group-maps&#x60;
                .replace(&#x60;{${&quot;configId&quot;}}&#x60;, encodeURIComponent(String(configId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} configId 
         * @param {string} groupMapId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigConfigIdGroupMapsGroupMapIdDelete: async (configId: string, groupMapId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;configId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1LdapConfigConfigIdGroupMapsGroupMapIdDelete&#x27;, &#x27;configId&#x27;, configId)
            // verify required parameter &#x27;groupMapId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1LdapConfigConfigIdGroupMapsGroupMapIdDelete&#x27;, &#x27;groupMapId&#x27;, groupMapId)
            const localVarPath &#x3D; &#x60;/api/v1/ldap/config/{configId}/group-maps/{groupMapId}&#x60;
                .replace(&#x60;{${&quot;configId&quot;}}&#x60;, encodeURIComponent(String(configId)))
                .replace(&#x60;{${&quot;groupMapId&quot;}}&#x60;, encodeURIComponent(String(groupMapId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} configId 
         * @param {ApiV1LdapConfigConfigIdGroupMapsPostRequest} apiV1LdapConfigConfigIdGroupMapsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigConfigIdGroupMapsPost: async (configId: string, apiV1LdapConfigConfigIdGroupMapsPostRequest: ApiV1LdapConfigConfigIdGroupMapsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;configId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1LdapConfigConfigIdGroupMapsPost&#x27;, &#x27;configId&#x27;, configId)
            // verify required parameter &#x27;apiV1LdapConfigConfigIdGroupMapsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1LdapConfigConfigIdGroupMapsPost&#x27;, &#x27;apiV1LdapConfigConfigIdGroupMapsPostRequest&#x27;, apiV1LdapConfigConfigIdGroupMapsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/ldap/config/{configId}/group-maps&#x60;
                .replace(&#x60;{${&quot;configId&quot;}}&#x60;, encodeURIComponent(String(configId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1LdapConfigConfigIdGroupMapsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} configId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigConfigIdTestConnectionPost: async (configId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;configId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1LdapConfigConfigIdTestConnectionPost&#x27;, &#x27;configId&#x27;, configId)
            const localVarPath &#x3D; &#x60;/api/v1/ldap/config/{configId}/test-connection&#x60;
                .replace(&#x60;{${&quot;configId&quot;}}&#x60;, encodeURIComponent(String(configId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1LdapConfigGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/ldap/config&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (organizationId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;organizationId&#x27;] &#x3D; organizationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1LdapConfigPatchRequest} apiV1LdapConfigPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigPatch: async (apiV1LdapConfigPatchRequest: ApiV1LdapConfigPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1LdapConfigPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1LdapConfigPatch&#x27;, &#x27;apiV1LdapConfigPatchRequest&#x27;, apiV1LdapConfigPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/ldap/config&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1LdapConfigPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1LdapConfigPostRequest} apiV1LdapConfigPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigPost: async (apiV1LdapConfigPostRequest: ApiV1LdapConfigPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1LdapConfigPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1LdapConfigPost&#x27;, &#x27;apiV1LdapConfigPostRequest&#x27;, apiV1LdapConfigPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/ldap/config&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1LdapConfigPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1LdapLoginPostRequest} apiV1LdapLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapLoginPost: async (apiV1LdapLoginPostRequest: ApiV1LdapLoginPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1LdapLoginPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1LdapLoginPost&#x27;, &#x27;apiV1LdapLoginPostRequest&#x27;, apiV1LdapLoginPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/ldap/login&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1LdapLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationAdminProjectsGet: async (search?: string, offset?: number, limit?: number, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/organization-admin/projects&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (search !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;search&#x27;] &#x3D; search;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/organization-admin/projects/{projectId}/grant-admin-access&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all audit logs for an organization
         * @param {string} [projectId] Optionally filter logs by project ID. If not provided, logs from the entire organization will be returned.
         * @param {ApiV1OrganizationAuditLogsGetActorTypeEnum} [actorType] 
         * @param {string} [secretPath] The path of the secret to query audit logs for. Note that the projectId parameter must also be provided.
         * @param {string} [eventType] 
         * @param {ApiV1OrganizationAuditLogsGetUserAgentTypeEnum} [userAgentType] Choose which consuming application to export audit logs for.
         * @param {string} [eventMetadata] Filter by event metadata key-value pairs. Formatted as &amp;#x60;key1&amp;#x3D;value1,key2&amp;#x3D;value2&amp;#x60;, with comma-separation.
         * @param {string} [startDate] The date to start the export from.
         * @param {string} [endDate] The date to end the export at.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th audit log.
         * @param {number} [limit] The number of audit logs to return.
         * @param {string} [actor] The actor to filter the audit logs by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationAuditLogsGet: async (projectId?: string, actorType?: ApiV1OrganizationAuditLogsGetActorTypeEnum, secretPath?: string, eventType?: string, userAgentType?: ApiV1OrganizationAuditLogsGetUserAgentTypeEnum, eventMetadata?: string, startDate?: string, endDate?: string, offset?: number, limit?: number, actor?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/organization/audit-logs&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }

            if (actorType !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;actorType&#x27;] &#x3D; actorType;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }

            if (eventType !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;eventType&#x27;] &#x3D; eventType;
            }

            if (userAgentType !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;userAgentType&#x27;] &#x3D; userAgentType;
            }

            if (eventMetadata !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;eventMetadata&#x27;] &#x3D; eventMetadata;
            }

            if (startDate !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;startDate&#x27;] &#x3D; (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;endDate&#x27;] &#x3D; (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (actor !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;actor&#x27;] &#x3D; actor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/organization&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId The ID of the organization to list groups for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdGroupsGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdGroupsGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}/groups&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdIncidentContactOrgGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdIncidentContactOrgGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}/incidentContactOrg&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} incidentContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdIncidentContactOrgIncidentContactIdDelete: async (organizationId: string, incidentContactId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdIncidentContactOrgIncidentContactIdDelete&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;incidentContactId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdIncidentContactOrgIncidentContactIdDelete&#x27;, &#x27;incidentContactId&#x27;, incidentContactId)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}/incidentContactOrg/{incidentContactId}&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)))
                .replace(&#x60;{${&quot;incidentContactId&quot;}}&#x60;, encodeURIComponent(String(incidentContactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1PasswordEmailPasswordResetPostRequest} apiV1PasswordEmailPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdIncidentContactOrgPost: async (organizationId: string, apiV1PasswordEmailPasswordResetPostRequest: ApiV1PasswordEmailPasswordResetPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdIncidentContactOrgPost&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;apiV1PasswordEmailPasswordResetPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdIncidentContactOrgPost&#x27;, &#x27;apiV1PasswordEmailPasswordResetPostRequest&#x27;, apiV1PasswordEmailPasswordResetPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}/incidentContactOrg&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PasswordEmailPasswordResetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdIntegrationAuthorizationsGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdIntegrationAuthorizationsGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}/integration-authorizations&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationOrganizationIdPatchRequest} [apiV1OrganizationOrganizationIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdPatch: async (organizationId: string, apiV1OrganizationOrganizationIdPatchRequest?: ApiV1OrganizationOrganizationIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdPatch&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1OrganizationOrganizationIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdPermissionsGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdPermissionsGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}/permissions&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdRolesGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdRolesGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}/roles&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationOrganizationIdRolesPostRequest} apiV1OrganizationOrganizationIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdRolesPost: async (organizationId: string, apiV1OrganizationOrganizationIdRolesPostRequest: ApiV1OrganizationOrganizationIdRolesPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdRolesPost&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;apiV1OrganizationOrganizationIdRolesPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdRolesPost&#x27;, &#x27;apiV1OrganizationOrganizationIdRolesPostRequest&#x27;, apiV1OrganizationOrganizationIdRolesPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}/roles&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1OrganizationOrganizationIdRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdRolesRoleIdDelete: async (organizationId: string, roleId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdRolesRoleIdDelete&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;roleId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdRolesRoleIdDelete&#x27;, &#x27;roleId&#x27;, roleId)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}/roles/{roleId}&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)))
                .replace(&#x60;{${&quot;roleId&quot;}}&#x60;, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdRolesRoleIdGet: async (organizationId: string, roleId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdRolesRoleIdGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;roleId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdRolesRoleIdGet&#x27;, &#x27;roleId&#x27;, roleId)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}/roles/{roleId}&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)))
                .replace(&#x60;{${&quot;roleId&quot;}}&#x60;, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} roleId 
         * @param {ApiV1OrganizationOrganizationIdRolesRoleIdPatchRequest} [apiV1OrganizationOrganizationIdRolesRoleIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdRolesRoleIdPatch: async (organizationId: string, roleId: string, apiV1OrganizationOrganizationIdRolesRoleIdPatchRequest?: ApiV1OrganizationOrganizationIdRolesRoleIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdRolesRoleIdPatch&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;roleId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdRolesRoleIdPatch&#x27;, &#x27;roleId&#x27;, roleId)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}/roles/{roleId}&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)))
                .replace(&#x60;{${&quot;roleId&quot;}}&#x60;, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1OrganizationOrganizationIdRolesRoleIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdUsersGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationOrganizationIdUsersGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organization/{organizationId}/users&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdBillingDetailsGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/billing-details&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationsOrganizationIdBillingDetailsPatchRequest} [apiV1OrganizationsOrganizationIdBillingDetailsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsPatch: async (organizationId: string, apiV1OrganizationsOrganizationIdBillingDetailsPatchRequest?: ApiV1OrganizationsOrganizationIdBillingDetailsPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdBillingDetailsPatch&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/billing-details&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1OrganizationsOrganizationIdBillingDetailsPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/billing-details/payment-methods&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} pmtMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPmtMethodIdDelete: async (organizationId: string, pmtMethodId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPmtMethodIdDelete&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;pmtMethodId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPmtMethodIdDelete&#x27;, &#x27;pmtMethodId&#x27;, pmtMethodId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/billing-details/payment-methods/{pmtMethodId}&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)))
                .replace(&#x60;{${&quot;pmtMethodId&quot;}}&#x60;, encodeURIComponent(String(pmtMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest} apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPost: async (organizationId: string, apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest: ApiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPost&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPost&#x27;, &#x27;apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest&#x27;, apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/billing-details/payment-methods&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/billing-details/tax-ids&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest} apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPost: async (organizationId: string, apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest: ApiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPost&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPost&#x27;, &#x27;apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest&#x27;, apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/billing-details/tax-ids&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} taxId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsTaxIdDelete: async (organizationId: string, taxId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsTaxIdDelete&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;taxId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsTaxIdDelete&#x27;, &#x27;taxId&#x27;, taxId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/billing-details/tax-ids/{taxId}&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)))
                .replace(&#x60;{${&quot;taxId&quot;}}&#x60;, encodeURIComponent(String(taxId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdCustomerPortalSessionPost: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdCustomerPortalSessionPost&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/customer-portal-session&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdInvoicesGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdInvoicesGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/invoices&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdLicensesGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdLicensesGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/licenses&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdPlanBillingGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdPlanBillingGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/plan/billing&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdPlanGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdPlanGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/plan&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdPlanTableGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdPlanTableGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/plan/table&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} [workspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdPlansGet: async (organizationId: string, workspaceId?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdPlansGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/plans&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1OrganizationsOrganizationIdPlansTableGetBillingCycleEnum} billingCycle 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdPlansTableGet: async (billingCycle: ApiV1OrganizationsOrganizationIdPlansTableGetBillingCycleEnum, organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;billingCycle&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdPlansTableGet&#x27;, &#x27;billingCycle&#x27;, billingCycle)
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdPlansTableGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/plans/table&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (billingCycle !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;billingCycle&#x27;] &#x3D; billingCycle;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationsOrganizationIdSessionTrialPostRequest} apiV1OrganizationsOrganizationIdSessionTrialPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdSessionTrialPost: async (organizationId: string, apiV1OrganizationsOrganizationIdSessionTrialPostRequest: ApiV1OrganizationsOrganizationIdSessionTrialPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdSessionTrialPost&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;apiV1OrganizationsOrganizationIdSessionTrialPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1OrganizationsOrganizationIdSessionTrialPost&#x27;, &#x27;apiV1OrganizationsOrganizationIdSessionTrialPostRequest&#x27;, apiV1OrganizationsOrganizationIdSessionTrialPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/organizations/{organizationId}/session/trial&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1OrganizationsOrganizationIdSessionTrialPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordBackupPrivateKeyGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/password/backup-private-key&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PasswordBackupPrivateKeyPostRequest} apiV1PasswordBackupPrivateKeyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordBackupPrivateKeyPost: async (apiV1PasswordBackupPrivateKeyPostRequest: ApiV1PasswordBackupPrivateKeyPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PasswordBackupPrivateKeyPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PasswordBackupPrivateKeyPost&#x27;, &#x27;apiV1PasswordBackupPrivateKeyPostRequest&#x27;, apiV1PasswordBackupPrivateKeyPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/password/backup-private-key&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PasswordBackupPrivateKeyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PasswordChangePasswordPostRequest} apiV1PasswordChangePasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordChangePasswordPost: async (apiV1PasswordChangePasswordPostRequest: ApiV1PasswordChangePasswordPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PasswordChangePasswordPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PasswordChangePasswordPost&#x27;, &#x27;apiV1PasswordChangePasswordPostRequest&#x27;, apiV1PasswordChangePasswordPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/password/change-password&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PasswordChangePasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PasswordEmailPasswordResetPostRequest} apiV1PasswordEmailPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordEmailPasswordResetPost: async (apiV1PasswordEmailPasswordResetPostRequest: ApiV1PasswordEmailPasswordResetPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PasswordEmailPasswordResetPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PasswordEmailPasswordResetPost&#x27;, &#x27;apiV1PasswordEmailPasswordResetPostRequest&#x27;, apiV1PasswordEmailPasswordResetPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/password/email/password-reset&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PasswordEmailPasswordResetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PasswordEmailPasswordResetVerifyPostRequest} apiV1PasswordEmailPasswordResetVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordEmailPasswordResetVerifyPost: async (apiV1PasswordEmailPasswordResetVerifyPostRequest: ApiV1PasswordEmailPasswordResetVerifyPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PasswordEmailPasswordResetVerifyPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PasswordEmailPasswordResetVerifyPost&#x27;, &#x27;apiV1PasswordEmailPasswordResetVerifyPostRequest&#x27;, apiV1PasswordEmailPasswordResetVerifyPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/password/email/password-reset-verify&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PasswordEmailPasswordResetVerifyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordEmailPasswordSetupPost: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/password/email/password-setup&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PasswordPasswordResetPostRequest} apiV1PasswordPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordPasswordResetPost: async (apiV1PasswordPasswordResetPostRequest: ApiV1PasswordPasswordResetPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PasswordPasswordResetPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PasswordPasswordResetPost&#x27;, &#x27;apiV1PasswordPasswordResetPostRequest&#x27;, apiV1PasswordPasswordResetPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/password/password-reset&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PasswordPasswordResetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PasswordPasswordSetupPostRequest} apiV1PasswordPasswordSetupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordPasswordSetupPost: async (apiV1PasswordPasswordSetupPostRequest: ApiV1PasswordPasswordSetupPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PasswordPasswordSetupPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PasswordPasswordSetupPost&#x27;, &#x27;apiV1PasswordPasswordSetupPostRequest&#x27;, apiV1PasswordPasswordSetupPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/password/password-setup&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PasswordPasswordSetupPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PasswordSrp1PostRequest} apiV1PasswordSrp1PostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordSrp1Post: async (apiV1PasswordSrp1PostRequest: ApiV1PasswordSrp1PostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PasswordSrp1PostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PasswordSrp1Post&#x27;, &#x27;apiV1PasswordSrp1PostRequest&#x27;, apiV1PasswordSrp1PostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/password/srp1&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PasswordSrp1PostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete PKI alert
         * @param {string} alertId The ID of the alert to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiAlertsAlertIdDelete: async (alertId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;alertId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiAlertsAlertIdDelete&#x27;, &#x27;alertId&#x27;, alertId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/alerts/{alertId}&#x60;
                .replace(&#x60;{${&quot;alertId&quot;}}&#x60;, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get PKI alert
         * @param {string} alertId The ID of the alert to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiAlertsAlertIdGet: async (alertId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;alertId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiAlertsAlertIdGet&#x27;, &#x27;alertId&#x27;, alertId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/alerts/{alertId}&#x60;
                .replace(&#x60;{${&quot;alertId&quot;}}&#x60;, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update PKI alert
         * @param {string} alertId The ID of the alert to update.
         * @param {ApiV1PkiAlertsAlertIdPatchRequest} [apiV1PkiAlertsAlertIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiAlertsAlertIdPatch: async (alertId: string, apiV1PkiAlertsAlertIdPatchRequest?: ApiV1PkiAlertsAlertIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;alertId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiAlertsAlertIdPatch&#x27;, &#x27;alertId&#x27;, alertId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/alerts/{alertId}&#x60;
                .replace(&#x60;{${&quot;alertId&quot;}}&#x60;, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiAlertsAlertIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create PKI alert
         * @param {ApiV1PkiAlertsPostRequest} apiV1PkiAlertsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiAlertsPost: async (apiV1PkiAlertsPostRequest: ApiV1PkiAlertsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PkiAlertsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiAlertsPost&#x27;, &#x27;apiV1PkiAlertsPostRequest&#x27;, apiV1PkiAlertsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/alerts&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiAlertsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of past and current CA certificates for a CA
         * @param {string} caId The ID of the CA to get the CA certificates for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdCaCertificatesGet: async (caId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdCaCertificatesGet&#x27;, &#x27;caId&#x27;, caId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}/ca-certificates&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current CA cert and cert chain of a CA
         * @param {string} caId The ID of the CA to get the certificate body and certificate chain from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdCertificateGet: async (caId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdCertificateGet&#x27;, &#x27;caId&#x27;, caId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}/certificate&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of certificate templates for the CA
         * @param {string} caId The ID of the CA to issue the certificate from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdCertificateTemplatesGet: async (caId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdCertificateTemplatesGet&#x27;, &#x27;caId&#x27;, caId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}/certificate-templates&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get DER-encoded certificate of CA
         * @param {string} caId The ID of the CA to get the CA certificate from.
         * @param {string} caCertId The ID of the CA certificate to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdCertificatesCaCertIdDerGet: async (caId: string, caCertId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdCertificatesCaCertIdDerGet&#x27;, &#x27;caId&#x27;, caId)
            // verify required parameter &#x27;caCertId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdCertificatesCaCertIdDerGet&#x27;, &#x27;caCertId&#x27;, caCertId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}/certificates/{caCertId}/der&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)))
                .replace(&#x60;{${&quot;caCertId&quot;}}&#x60;, encodeURIComponent(String(caCertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of CRLs of the CA
         * @param {string} caId The ID of the CA to get the certificate revocation lists (CRLs) for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdCrlsGet: async (caId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdCrlsGet&#x27;, &#x27;caId&#x27;, caId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}/crls&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CA CSR
         * @param {string} caId The ID of the CA to generate CSR from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdCsrGet: async (caId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdCsrGet&#x27;, &#x27;caId&#x27;, caId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}/csr&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete CA
         * @param {string} caId The ID of the CA to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdDelete: async (caId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdDelete&#x27;, &#x27;caId&#x27;, caId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CA
         * @param {string} caId The ID of the CA to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdGet: async (caId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdGet&#x27;, &#x27;caId&#x27;, caId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import certificate and chain to CA
         * @param {string} caId The ID of the CA to import the certificate for.
         * @param {ApiV1PkiCaCaIdImportCertificatePostRequest} apiV1PkiCaCaIdImportCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdImportCertificatePost: async (caId: string, apiV1PkiCaCaIdImportCertificatePostRequest: ApiV1PkiCaCaIdImportCertificatePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdImportCertificatePost&#x27;, &#x27;caId&#x27;, caId)
            // verify required parameter &#x27;apiV1PkiCaCaIdImportCertificatePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdImportCertificatePost&#x27;, &#x27;apiV1PkiCaCaIdImportCertificatePostRequest&#x27;, apiV1PkiCaCaIdImportCertificatePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}/import-certificate&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCaCaIdImportCertificatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Issue certificate from CA
         * @param {string} caId The ID of the CA to issue the certificate from.
         * @param {ApiV1PkiCaCaIdIssueCertificatePostRequest} apiV1PkiCaCaIdIssueCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdIssueCertificatePost: async (caId: string, apiV1PkiCaCaIdIssueCertificatePostRequest: ApiV1PkiCaCaIdIssueCertificatePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdIssueCertificatePost&#x27;, &#x27;caId&#x27;, caId)
            // verify required parameter &#x27;apiV1PkiCaCaIdIssueCertificatePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdIssueCertificatePost&#x27;, &#x27;apiV1PkiCaCaIdIssueCertificatePostRequest&#x27;, apiV1PkiCaCaIdIssueCertificatePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}/issue-certificate&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCaCaIdIssueCertificatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update CA
         * @param {string} caId The ID of the CA to update.
         * @param {ApiV1PkiCaCaIdPatchRequest} [apiV1PkiCaCaIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdPatch: async (caId: string, apiV1PkiCaCaIdPatchRequest?: ApiV1PkiCaCaIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdPatch&#x27;, &#x27;caId&#x27;, caId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCaCaIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform CA certificate renewal
         * @param {string} caId The ID of the CA to renew the CA certificate for.
         * @param {ApiV1PkiCaCaIdRenewPostRequest} apiV1PkiCaCaIdRenewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdRenewPost: async (caId: string, apiV1PkiCaCaIdRenewPostRequest: ApiV1PkiCaCaIdRenewPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdRenewPost&#x27;, &#x27;caId&#x27;, caId)
            // verify required parameter &#x27;apiV1PkiCaCaIdRenewPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdRenewPost&#x27;, &#x27;apiV1PkiCaCaIdRenewPostRequest&#x27;, apiV1PkiCaCaIdRenewPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}/renew&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCaCaIdRenewPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign certificate from CA
         * @param {string} caId The ID of the CA to issue the certificate from.
         * @param {ApiV1PkiCaCaIdSignCertificatePostRequest} apiV1PkiCaCaIdSignCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdSignCertificatePost: async (caId: string, apiV1PkiCaCaIdSignCertificatePostRequest: ApiV1PkiCaCaIdSignCertificatePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdSignCertificatePost&#x27;, &#x27;caId&#x27;, caId)
            // verify required parameter &#x27;apiV1PkiCaCaIdSignCertificatePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdSignCertificatePost&#x27;, &#x27;apiV1PkiCaCaIdSignCertificatePostRequest&#x27;, apiV1PkiCaCaIdSignCertificatePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}/sign-certificate&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCaCaIdSignCertificatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create intermediate CA certificate from parent CA
         * @param {string} caId The ID of the CA to sign the intermediate certificate with.
         * @param {ApiV1PkiCaCaIdSignIntermediatePostRequest} apiV1PkiCaCaIdSignIntermediatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdSignIntermediatePost: async (caId: string, apiV1PkiCaCaIdSignIntermediatePostRequest: ApiV1PkiCaCaIdSignIntermediatePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;caId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdSignIntermediatePost&#x27;, &#x27;caId&#x27;, caId)
            // verify required parameter &#x27;apiV1PkiCaCaIdSignIntermediatePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaCaIdSignIntermediatePost&#x27;, &#x27;apiV1PkiCaCaIdSignIntermediatePostRequest&#x27;, apiV1PkiCaCaIdSignIntermediatePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca/{caId}/sign-intermediate&#x60;
                .replace(&#x60;{${&quot;caId&quot;}}&#x60;, encodeURIComponent(String(caId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCaCaIdSignIntermediatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create CA
         * @param {ApiV1PkiCaPostRequest} apiV1PkiCaPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaPost: async (apiV1PkiCaPostRequest: ApiV1PkiCaPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PkiCaPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCaPost&#x27;, &#x27;apiV1PkiCaPostRequest&#x27;, apiV1PkiCaPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/ca&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCaPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the certificate template to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesCertificateTemplateIdDelete: async (certificateTemplateId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;certificateTemplateId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificateTemplatesCertificateTemplateIdDelete&#x27;, &#x27;certificateTemplateId&#x27;, certificateTemplateId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/certificate-templates/{certificateTemplateId}&#x60;
                .replace(&#x60;{${&quot;certificateTemplateId&quot;}}&#x60;, encodeURIComponent(String(certificateTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Certificate Template EST configuration
         * @param {string} certificateTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigGet: async (certificateTemplateId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;certificateTemplateId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigGet&#x27;, &#x27;certificateTemplateId&#x27;, certificateTemplateId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/certificate-templates/{certificateTemplateId}/est-config&#x60;
                .replace(&#x60;{${&quot;certificateTemplateId&quot;}}&#x60;, encodeURIComponent(String(certificateTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Certificate Template EST configuration
         * @param {string} certificateTemplateId 
         * @param {ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest} [apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatch: async (certificateTemplateId: string, apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest?: ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;certificateTemplateId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatch&#x27;, &#x27;certificateTemplateId&#x27;, certificateTemplateId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/certificate-templates/{certificateTemplateId}/est-config&#x60;
                .replace(&#x60;{${&quot;certificateTemplateId&quot;}}&#x60;, encodeURIComponent(String(certificateTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Certificate Template EST configuration
         * @param {string} certificateTemplateId 
         * @param {ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest} apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPost: async (certificateTemplateId: string, apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest: ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;certificateTemplateId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPost&#x27;, &#x27;certificateTemplateId&#x27;, certificateTemplateId)
            // verify required parameter &#x27;apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPost&#x27;, &#x27;apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest&#x27;, apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/certificate-templates/{certificateTemplateId}/est-config&#x60;
                .replace(&#x60;{${&quot;certificateTemplateId&quot;}}&#x60;, encodeURIComponent(String(certificateTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the certificate template to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesCertificateTemplateIdGet: async (certificateTemplateId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;certificateTemplateId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificateTemplatesCertificateTemplateIdGet&#x27;, &#x27;certificateTemplateId&#x27;, certificateTemplateId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/certificate-templates/{certificateTemplateId}&#x60;
                .replace(&#x60;{${&quot;certificateTemplateId&quot;}}&#x60;, encodeURIComponent(String(certificateTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the certificate template to update.
         * @param {ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest} [apiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesCertificateTemplateIdPatch: async (certificateTemplateId: string, apiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest?: ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;certificateTemplateId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificateTemplatesCertificateTemplateIdPatch&#x27;, &#x27;certificateTemplateId&#x27;, certificateTemplateId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/certificate-templates/{certificateTemplateId}&#x60;
                .replace(&#x60;{${&quot;certificateTemplateId&quot;}}&#x60;, encodeURIComponent(String(certificateTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PkiCertificateTemplatesPostRequest} apiV1PkiCertificateTemplatesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesPost: async (apiV1PkiCertificateTemplatesPostRequest: ApiV1PkiCertificateTemplatesPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PkiCertificateTemplatesPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificateTemplatesPost&#x27;, &#x27;apiV1PkiCertificateTemplatesPostRequest&#x27;, apiV1PkiCertificateTemplatesPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/certificate-templates&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCertificateTemplatesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Issue certificate
         * @param {ApiV1PkiCertificatesIssueCertificatePostRequest} apiV1PkiCertificatesIssueCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificatesIssueCertificatePost: async (apiV1PkiCertificatesIssueCertificatePostRequest: ApiV1PkiCertificatesIssueCertificatePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PkiCertificatesIssueCertificatePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificatesIssueCertificatePost&#x27;, &#x27;apiV1PkiCertificatesIssueCertificatePostRequest&#x27;, apiV1PkiCertificatesIssueCertificatePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/certificates/issue-certificate&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCertificatesIssueCertificatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get certificate body of certificate
         * @param {string} serialNumber The serial number of the certificate to get the certificate body and certificate chain for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificatesSerialNumberCertificateGet: async (serialNumber: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;serialNumber&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificatesSerialNumberCertificateGet&#x27;, &#x27;serialNumber&#x27;, serialNumber)
            const localVarPath &#x3D; &#x60;/api/v1/pki/certificates/{serialNumber}/certificate&#x60;
                .replace(&#x60;{${&quot;serialNumber&quot;}}&#x60;, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete certificate
         * @param {string} serialNumber The serial number of the certificate to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificatesSerialNumberDelete: async (serialNumber: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;serialNumber&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificatesSerialNumberDelete&#x27;, &#x27;serialNumber&#x27;, serialNumber)
            const localVarPath &#x3D; &#x60;/api/v1/pki/certificates/{serialNumber}&#x60;
                .replace(&#x60;{${&quot;serialNumber&quot;}}&#x60;, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get certificate
         * @param {string} serialNumber The serial number of the certificate to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificatesSerialNumberGet: async (serialNumber: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;serialNumber&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificatesSerialNumberGet&#x27;, &#x27;serialNumber&#x27;, serialNumber)
            const localVarPath &#x3D; &#x60;/api/v1/pki/certificates/{serialNumber}&#x60;
                .replace(&#x60;{${&quot;serialNumber&quot;}}&#x60;, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke
         * @param {string} serialNumber The serial number of the certificate to revoke. The revoked certificate will be added to the certificate revocation list (CRL) of the CA.
         * @param {ApiV1PkiCertificatesSerialNumberRevokePostRequest} apiV1PkiCertificatesSerialNumberRevokePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificatesSerialNumberRevokePost: async (serialNumber: string, apiV1PkiCertificatesSerialNumberRevokePostRequest: ApiV1PkiCertificatesSerialNumberRevokePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;serialNumber&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificatesSerialNumberRevokePost&#x27;, &#x27;serialNumber&#x27;, serialNumber)
            // verify required parameter &#x27;apiV1PkiCertificatesSerialNumberRevokePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificatesSerialNumberRevokePost&#x27;, &#x27;apiV1PkiCertificatesSerialNumberRevokePostRequest&#x27;, apiV1PkiCertificatesSerialNumberRevokePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/certificates/{serialNumber}/revoke&#x60;
                .replace(&#x60;{${&quot;serialNumber&quot;}}&#x60;, encodeURIComponent(String(serialNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCertificatesSerialNumberRevokePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign certificate
         * @param {ApiV1PkiCertificatesSignCertificatePostRequest} apiV1PkiCertificatesSignCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificatesSignCertificatePost: async (apiV1PkiCertificatesSignCertificatePostRequest: ApiV1PkiCertificatesSignCertificatePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PkiCertificatesSignCertificatePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCertificatesSignCertificatePost&#x27;, &#x27;apiV1PkiCertificatesSignCertificatePostRequest&#x27;, apiV1PkiCertificatesSignCertificatePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/certificates/sign-certificate&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCertificatesSignCertificatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete PKI collection
         * @param {string} collectionId The ID of the PKI collection to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsCollectionIdDelete: async (collectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;collectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCollectionsCollectionIdDelete&#x27;, &#x27;collectionId&#x27;, collectionId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/collections/{collectionId}&#x60;
                .replace(&#x60;{${&quot;collectionId&quot;}}&#x60;, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get PKI collection
         * @param {string} collectionId The ID of the PKI collection to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsCollectionIdGet: async (collectionId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;collectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCollectionsCollectionIdGet&#x27;, &#x27;collectionId&#x27;, collectionId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/collections/{collectionId}&#x60;
                .replace(&#x60;{${&quot;collectionId&quot;}}&#x60;, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove item from PKI collection
         * @param {string} collectionId The ID of the PKI collection to delete the item from.
         * @param {string} collectionItemId The ID of the PKI collection item to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete: async (collectionId: string, collectionItemId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;collectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete&#x27;, &#x27;collectionId&#x27;, collectionId)
            // verify required parameter &#x27;collectionItemId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete&#x27;, &#x27;collectionItemId&#x27;, collectionItemId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/collections/{collectionId}/items/{collectionItemId}&#x60;
                .replace(&#x60;{${&quot;collectionId&quot;}}&#x60;, encodeURIComponent(String(collectionId)))
                .replace(&#x60;{${&quot;collectionItemId&quot;}}&#x60;, encodeURIComponent(String(collectionItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get items in PKI collection
         * @param {string} collectionId The ID of the PKI collection to list items from.
         * @param {ApiV1PkiCollectionsCollectionIdItemsGetTypeEnum} [type] The type of the PKI collection item to list.
         * @param {number} [offset] The offset to start from.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsCollectionIdItemsGet: async (collectionId: string, type?: ApiV1PkiCollectionsCollectionIdItemsGetTypeEnum, offset?: number, limit?: number, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;collectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCollectionsCollectionIdItemsGet&#x27;, &#x27;collectionId&#x27;, collectionId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/collections/{collectionId}/items&#x60;
                .replace(&#x60;{${&quot;collectionId&quot;}}&#x60;, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (type !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;type&#x27;] &#x3D; type;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add item to PKI collection
         * @param {string} collectionId The ID of the PKI collection to add the item to.
         * @param {ApiV1PkiCollectionsCollectionIdItemsPostRequest} apiV1PkiCollectionsCollectionIdItemsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsCollectionIdItemsPost: async (collectionId: string, apiV1PkiCollectionsCollectionIdItemsPostRequest: ApiV1PkiCollectionsCollectionIdItemsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;collectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCollectionsCollectionIdItemsPost&#x27;, &#x27;collectionId&#x27;, collectionId)
            // verify required parameter &#x27;apiV1PkiCollectionsCollectionIdItemsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCollectionsCollectionIdItemsPost&#x27;, &#x27;apiV1PkiCollectionsCollectionIdItemsPostRequest&#x27;, apiV1PkiCollectionsCollectionIdItemsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/collections/{collectionId}/items&#x60;
                .replace(&#x60;{${&quot;collectionId&quot;}}&#x60;, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCollectionsCollectionIdItemsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update PKI collection
         * @param {string} collectionId The ID of the PKI collection to update.
         * @param {ApiV1PkiCollectionsCollectionIdPatchRequest} [apiV1PkiCollectionsCollectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsCollectionIdPatch: async (collectionId: string, apiV1PkiCollectionsCollectionIdPatchRequest?: ApiV1PkiCollectionsCollectionIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;collectionId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCollectionsCollectionIdPatch&#x27;, &#x27;collectionId&#x27;, collectionId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/collections/{collectionId}&#x60;
                .replace(&#x60;{${&quot;collectionId&quot;}}&#x60;, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCollectionsCollectionIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create PKI collection
         * @param {ApiV1PkiCollectionsPostRequest} apiV1PkiCollectionsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsPost: async (apiV1PkiCollectionsPostRequest: ApiV1PkiCollectionsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PkiCollectionsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCollectionsPost&#x27;, &#x27;apiV1PkiCollectionsPostRequest&#x27;, apiV1PkiCollectionsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/pki/collections&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PkiCollectionsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CRL in DER format
         * @param {string} crlId The ID of the certificate revocation list (CRL) to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCrlCrlIdDerGet: async (crlId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;crlId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCrlCrlIdDerGet&#x27;, &#x27;crlId&#x27;, crlId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/crl/{crlId}/der&#x60;
                .replace(&#x60;{${&quot;crlId&quot;}}&#x60;, encodeURIComponent(String(crlId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CRL in DER format (deprecated)
         * @param {string} crlId The ID of the certificate revocation list (CRL) to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCrlCrlIdGet: async (crlId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;crlId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1PkiCrlCrlIdGet&#x27;, &#x27;crlId&#x27;, crlId)
            const localVarPath &#x3D; &#x60;/api/v1/pki/crl/{crlId}&#x60;
                .replace(&#x60;{${&quot;crlId&quot;}}&#x60;, encodeURIComponent(String(crlId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List project templates for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProjectTemplatesGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/project-templates&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a project template.
         * @param {ApiV1ProjectTemplatesPostRequest} apiV1ProjectTemplatesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProjectTemplatesPost: async (apiV1ProjectTemplatesPostRequest: ApiV1ProjectTemplatesPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1ProjectTemplatesPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ProjectTemplatesPost&#x27;, &#x27;apiV1ProjectTemplatesPostRequest&#x27;, apiV1ProjectTemplatesPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/project-templates&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1ProjectTemplatesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a project template.
         * @param {string} templateId The ID of the project template to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProjectTemplatesTemplateIdDelete: async (templateId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;templateId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ProjectTemplatesTemplateIdDelete&#x27;, &#x27;templateId&#x27;, templateId)
            const localVarPath &#x3D; &#x60;/api/v1/project-templates/{templateId}&#x60;
                .replace(&#x60;{${&quot;templateId&quot;}}&#x60;, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a project template by ID.
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProjectTemplatesTemplateIdGet: async (templateId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;templateId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ProjectTemplatesTemplateIdGet&#x27;, &#x27;templateId&#x27;, templateId)
            const localVarPath &#x3D; &#x60;/api/v1/project-templates/{templateId}&#x60;
                .replace(&#x60;{${&quot;templateId&quot;}}&#x60;, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a project template.
         * @param {string} templateId The ID of the project template to be updated.
         * @param {ApiV1ProjectTemplatesTemplateIdPatchRequest} [apiV1ProjectTemplatesTemplateIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProjectTemplatesTemplateIdPatch: async (templateId: string, apiV1ProjectTemplatesTemplateIdPatchRequest?: ApiV1ProjectTemplatesTemplateIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;templateId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ProjectTemplatesTemplateIdPatch&#x27;, &#x27;templateId&#x27;, templateId)
            const localVarPath &#x3D; &#x60;/api/v1/project-templates/{templateId}&#x60;
                .replace(&#x60;{${&quot;templateId&quot;}}&#x60;, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1ProjectTemplatesTemplateIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RateLimitGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/rate-limit&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1RateLimitPutRequest} apiV1RateLimitPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RateLimitPut: async (apiV1RateLimitPutRequest: ApiV1RateLimitPutRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1RateLimitPutRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1RateLimitPut&#x27;, &#x27;apiV1RateLimitPutRequest&#x27;, apiV1RateLimitPutRequest)
            const localVarPath &#x3D; &#x60;/api/v1/rate-limit&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PUT&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1RateLimitPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [startIndex] 
         * @param {number} [count] 
         * @param {string} [filter] 
         * @param {string} [excludedAttributes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimGroupsGet: async (startIndex?: number, count?: number, filter?: string, excludedAttributes?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/scim/Groups&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (startIndex !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;startIndex&#x27;] &#x3D; startIndex;
            }

            if (count !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;count&#x27;] &#x3D; count;
            }

            if (filter !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;filter&#x27;] &#x3D; filter;
            }

            if (excludedAttributes !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;excludedAttributes&#x27;] &#x3D; excludedAttributes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimGroupsGroupIdDelete: async (groupId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;groupId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimGroupsGroupIdDelete&#x27;, &#x27;groupId&#x27;, groupId)
            const localVarPath &#x3D; &#x60;/api/v1/scim/Groups/{groupId}&#x60;
                .replace(&#x60;{${&quot;groupId&quot;}}&#x60;, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimGroupsGroupIdGet: async (groupId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;groupId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimGroupsGroupIdGet&#x27;, &#x27;groupId&#x27;, groupId)
            const localVarPath &#x3D; &#x60;/api/v1/scim/Groups/{groupId}&#x60;
                .replace(&#x60;{${&quot;groupId&quot;}}&#x60;, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ApiV1ScimUsersOrgMembershipIdPatchRequest} apiV1ScimUsersOrgMembershipIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimGroupsGroupIdPatch: async (groupId: string, apiV1ScimUsersOrgMembershipIdPatchRequest: ApiV1ScimUsersOrgMembershipIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;groupId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimGroupsGroupIdPatch&#x27;, &#x27;groupId&#x27;, groupId)
            // verify required parameter &#x27;apiV1ScimUsersOrgMembershipIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimGroupsGroupIdPatch&#x27;, &#x27;apiV1ScimUsersOrgMembershipIdPatchRequest&#x27;, apiV1ScimUsersOrgMembershipIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/scim/Groups/{groupId}&#x60;
                .replace(&#x60;{${&quot;groupId&quot;}}&#x60;, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1ScimUsersOrgMembershipIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ApiV1ScimGroupsGroupIdPutRequest} apiV1ScimGroupsGroupIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimGroupsGroupIdPut: async (groupId: string, apiV1ScimGroupsGroupIdPutRequest: ApiV1ScimGroupsGroupIdPutRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;groupId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimGroupsGroupIdPut&#x27;, &#x27;groupId&#x27;, groupId)
            // verify required parameter &#x27;apiV1ScimGroupsGroupIdPutRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimGroupsGroupIdPut&#x27;, &#x27;apiV1ScimGroupsGroupIdPutRequest&#x27;, apiV1ScimGroupsGroupIdPutRequest)
            const localVarPath &#x3D; &#x60;/api/v1/scim/Groups/{groupId}&#x60;
                .replace(&#x60;{${&quot;groupId&quot;}}&#x60;, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PUT&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1ScimGroupsGroupIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ScimGroupsPostRequest} apiV1ScimGroupsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimGroupsPost: async (apiV1ScimGroupsPostRequest: ApiV1ScimGroupsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1ScimGroupsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimGroupsPost&#x27;, &#x27;apiV1ScimGroupsPostRequest&#x27;, apiV1ScimGroupsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/scim/Groups&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1ScimGroupsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimScimTokensGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimScimTokensGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/scim/scim-tokens&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (organizationId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;organizationId&#x27;] &#x3D; organizationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ScimScimTokensPostRequest} apiV1ScimScimTokensPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimScimTokensPost: async (apiV1ScimScimTokensPostRequest: ApiV1ScimScimTokensPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1ScimScimTokensPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimScimTokensPost&#x27;, &#x27;apiV1ScimScimTokensPostRequest&#x27;, apiV1ScimScimTokensPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/scim/scim-tokens&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1ScimScimTokensPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} scimTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimScimTokensScimTokenIdDelete: async (scimTokenId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;scimTokenId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimScimTokensScimTokenIdDelete&#x27;, &#x27;scimTokenId&#x27;, scimTokenId)
            const localVarPath &#x3D; &#x60;/api/v1/scim/scim-tokens/{scimTokenId}&#x60;
                .replace(&#x60;{${&quot;scimTokenId&quot;}}&#x60;, encodeURIComponent(String(scimTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [startIndex] 
         * @param {number} [count] 
         * @param {string} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimUsersGet: async (startIndex?: number, count?: number, filter?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/scim/Users&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (startIndex !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;startIndex&#x27;] &#x3D; startIndex;
            }

            if (count !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;count&#x27;] &#x3D; count;
            }

            if (filter !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;filter&#x27;] &#x3D; filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgMembershipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimUsersOrgMembershipIdDelete: async (orgMembershipId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;orgMembershipId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimUsersOrgMembershipIdDelete&#x27;, &#x27;orgMembershipId&#x27;, orgMembershipId)
            const localVarPath &#x3D; &#x60;/api/v1/scim/Users/{orgMembershipId}&#x60;
                .replace(&#x60;{${&quot;orgMembershipId&quot;}}&#x60;, encodeURIComponent(String(orgMembershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgMembershipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimUsersOrgMembershipIdGet: async (orgMembershipId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;orgMembershipId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimUsersOrgMembershipIdGet&#x27;, &#x27;orgMembershipId&#x27;, orgMembershipId)
            const localVarPath &#x3D; &#x60;/api/v1/scim/Users/{orgMembershipId}&#x60;
                .replace(&#x60;{${&quot;orgMembershipId&quot;}}&#x60;, encodeURIComponent(String(orgMembershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgMembershipId 
         * @param {ApiV1ScimUsersOrgMembershipIdPatchRequest} apiV1ScimUsersOrgMembershipIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimUsersOrgMembershipIdPatch: async (orgMembershipId: string, apiV1ScimUsersOrgMembershipIdPatchRequest: ApiV1ScimUsersOrgMembershipIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;orgMembershipId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimUsersOrgMembershipIdPatch&#x27;, &#x27;orgMembershipId&#x27;, orgMembershipId)
            // verify required parameter &#x27;apiV1ScimUsersOrgMembershipIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimUsersOrgMembershipIdPatch&#x27;, &#x27;apiV1ScimUsersOrgMembershipIdPatchRequest&#x27;, apiV1ScimUsersOrgMembershipIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/scim/Users/{orgMembershipId}&#x60;
                .replace(&#x60;{${&quot;orgMembershipId&quot;}}&#x60;, encodeURIComponent(String(orgMembershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1ScimUsersOrgMembershipIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgMembershipId 
         * @param {ApiV1ScimUsersOrgMembershipIdPutRequest} apiV1ScimUsersOrgMembershipIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimUsersOrgMembershipIdPut: async (orgMembershipId: string, apiV1ScimUsersOrgMembershipIdPutRequest: ApiV1ScimUsersOrgMembershipIdPutRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;orgMembershipId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimUsersOrgMembershipIdPut&#x27;, &#x27;orgMembershipId&#x27;, orgMembershipId)
            // verify required parameter &#x27;apiV1ScimUsersOrgMembershipIdPutRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimUsersOrgMembershipIdPut&#x27;, &#x27;apiV1ScimUsersOrgMembershipIdPutRequest&#x27;, apiV1ScimUsersOrgMembershipIdPutRequest)
            const localVarPath &#x3D; &#x60;/api/v1/scim/Users/{orgMembershipId}&#x60;
                .replace(&#x60;{${&quot;orgMembershipId&quot;}}&#x60;, encodeURIComponent(String(orgMembershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PUT&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1ScimUsersOrgMembershipIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ScimUsersPostRequest} apiV1ScimUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimUsersPost: async (apiV1ScimUsersPostRequest: ApiV1ScimUsersPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1ScimUsersPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1ScimUsersPost&#x27;, &#x27;apiV1ScimUsersPostRequest&#x27;, apiV1ScimUsersPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/scim/Users&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1ScimUsersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalRequestsCountGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalRequestsCountGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-approval-requests/count&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [environment] 
         * @param {string} [committer] 
         * @param {ApiV1SecretApprovalRequestsGetStatusEnum} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalRequestsGet: async (workspaceId: string, environment?: string, committer?: string, status?: ApiV1SecretApprovalRequestsGetStatusEnum, limit?: number, offset?: number, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalRequestsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-approval-requests&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (committer !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;committer&#x27;] &#x3D; committer;
            }

            if (status !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;status&#x27;] &#x3D; status;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalRequestsIdGet: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalRequestsIdGet&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/secret-approval-requests/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretApprovalRequestsIdMergePostRequest} [apiV1SecretApprovalRequestsIdMergePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalRequestsIdMergePost: async (id: string, apiV1SecretApprovalRequestsIdMergePostRequest?: ApiV1SecretApprovalRequestsIdMergePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalRequestsIdMergePost&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/secret-approval-requests/{id}/merge&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretApprovalRequestsIdMergePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretApprovalRequestsIdReviewPostRequest} apiV1SecretApprovalRequestsIdReviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalRequestsIdReviewPost: async (id: string, apiV1SecretApprovalRequestsIdReviewPostRequest: ApiV1SecretApprovalRequestsIdReviewPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalRequestsIdReviewPost&#x27;, &#x27;id&#x27;, id)
            // verify required parameter &#x27;apiV1SecretApprovalRequestsIdReviewPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalRequestsIdReviewPost&#x27;, &#x27;apiV1SecretApprovalRequestsIdReviewPostRequest&#x27;, apiV1SecretApprovalRequestsIdReviewPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-approval-requests/{id}/review&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretApprovalRequestsIdReviewPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretApprovalRequestsIdStatusPostRequest} apiV1SecretApprovalRequestsIdStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalRequestsIdStatusPost: async (id: string, apiV1SecretApprovalRequestsIdStatusPostRequest: ApiV1SecretApprovalRequestsIdStatusPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalRequestsIdStatusPost&#x27;, &#x27;id&#x27;, id)
            // verify required parameter &#x27;apiV1SecretApprovalRequestsIdStatusPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalRequestsIdStatusPost&#x27;, &#x27;apiV1SecretApprovalRequestsIdStatusPostRequest&#x27;, apiV1SecretApprovalRequestsIdStatusPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-approval-requests/{id}/status&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretApprovalRequestsIdStatusPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} secretPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalsBoardGet: async (workspaceId: string, environment: string, secretPath: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalsBoardGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalsBoardGet&#x27;, &#x27;environment&#x27;, environment)
            // verify required parameter &#x27;secretPath&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalsBoardGet&#x27;, &#x27;secretPath&#x27;, secretPath)
            const localVarPath &#x3D; &#x60;/api/v1/secret-approvals/board&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalsGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-approvals&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SecretApprovalsPostRequest} apiV1SecretApprovalsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalsPost: async (apiV1SecretApprovalsPostRequest: ApiV1SecretApprovalsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretApprovalsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalsPost&#x27;, &#x27;apiV1SecretApprovalsPostRequest&#x27;, apiV1SecretApprovalsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-approvals&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretApprovalsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sapId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalsSapIdDelete: async (sapId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;sapId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalsSapIdDelete&#x27;, &#x27;sapId&#x27;, sapId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-approvals/{sapId}&#x60;
                .replace(&#x60;{${&quot;sapId&quot;}}&#x60;, encodeURIComponent(String(sapId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sapId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalsSapIdGet: async (sapId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;sapId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalsSapIdGet&#x27;, &#x27;sapId&#x27;, sapId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-approvals/{sapId}&#x60;
                .replace(&#x60;{${&quot;sapId&quot;}}&#x60;, encodeURIComponent(String(sapId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sapId 
         * @param {ApiV1SecretApprovalsSapIdPatchRequest} apiV1SecretApprovalsSapIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalsSapIdPatch: async (sapId: string, apiV1SecretApprovalsSapIdPatchRequest: ApiV1SecretApprovalsSapIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;sapId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalsSapIdPatch&#x27;, &#x27;sapId&#x27;, sapId)
            // verify required parameter &#x27;apiV1SecretApprovalsSapIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretApprovalsSapIdPatch&#x27;, &#x27;apiV1SecretApprovalsSapIdPatchRequest&#x27;, apiV1SecretApprovalsSapIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-approvals/{sapId}&#x60;
                .replace(&#x60;{${&quot;sapId&quot;}}&#x60;, encodeURIComponent(String(sapId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretApprovalsSapIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get secret imports
         * @param {string} workspaceId The ID of the project to list secret imports from.
         * @param {string} environment The slug of the environment to list secret imports from.
         * @param {string} [path] The path to list secret imports from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsGet: async (workspaceId: string, environment: string, path?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsGet&#x27;, &#x27;environment&#x27;, environment)
            const localVarPath &#x3D; &#x60;/api/v1/secret-imports&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (path !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;path&#x27;] &#x3D; path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create secret imports
         * @param {ApiV1SecretImportsPostRequest} apiV1SecretImportsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsPost: async (apiV1SecretImportsPostRequest: ApiV1SecretImportsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretImportsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsPost&#x27;, &#x27;apiV1SecretImportsPostRequest&#x27;, apiV1SecretImportsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-imports&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretImportsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete secret imports
         * @param {string} secretImportId The ID of the secret import to delete.
         * @param {ApiV1SecretImportsSecretImportIdDeleteRequest} apiV1SecretImportsSecretImportIdDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsSecretImportIdDelete: async (secretImportId: string, apiV1SecretImportsSecretImportIdDeleteRequest: ApiV1SecretImportsSecretImportIdDeleteRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretImportId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsSecretImportIdDelete&#x27;, &#x27;secretImportId&#x27;, secretImportId)
            // verify required parameter &#x27;apiV1SecretImportsSecretImportIdDeleteRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsSecretImportIdDelete&#x27;, &#x27;apiV1SecretImportsSecretImportIdDeleteRequest&#x27;, apiV1SecretImportsSecretImportIdDeleteRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-imports/{secretImportId}&#x60;
                .replace(&#x60;{${&quot;secretImportId&quot;}}&#x60;, encodeURIComponent(String(secretImportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretImportsSecretImportIdDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get single secret import
         * @param {string} secretImportId The ID of the secret import to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsSecretImportIdGet: async (secretImportId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretImportId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsSecretImportIdGet&#x27;, &#x27;secretImportId&#x27;, secretImportId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-imports/{secretImportId}&#x60;
                .replace(&#x60;{${&quot;secretImportId&quot;}}&#x60;, encodeURIComponent(String(secretImportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update secret imports
         * @param {string} secretImportId The ID of the secret import to update.
         * @param {ApiV1SecretImportsSecretImportIdPatchRequest} apiV1SecretImportsSecretImportIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsSecretImportIdPatch: async (secretImportId: string, apiV1SecretImportsSecretImportIdPatchRequest: ApiV1SecretImportsSecretImportIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretImportId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsSecretImportIdPatch&#x27;, &#x27;secretImportId&#x27;, secretImportId)
            // verify required parameter &#x27;apiV1SecretImportsSecretImportIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsSecretImportIdPatch&#x27;, &#x27;apiV1SecretImportsSecretImportIdPatchRequest&#x27;, apiV1SecretImportsSecretImportIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-imports/{secretImportId}&#x60;
                .replace(&#x60;{${&quot;secretImportId&quot;}}&#x60;, encodeURIComponent(String(secretImportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretImportsSecretImportIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resync secret replication of secret imports
         * @param {string} secretImportId The ID of the secret import to update.
         * @param {ApiV1SecretImportsSecretImportIdReplicationResyncPostRequest} apiV1SecretImportsSecretImportIdReplicationResyncPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsSecretImportIdReplicationResyncPost: async (secretImportId: string, apiV1SecretImportsSecretImportIdReplicationResyncPostRequest: ApiV1SecretImportsSecretImportIdReplicationResyncPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretImportId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsSecretImportIdReplicationResyncPost&#x27;, &#x27;secretImportId&#x27;, secretImportId)
            // verify required parameter &#x27;apiV1SecretImportsSecretImportIdReplicationResyncPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsSecretImportIdReplicationResyncPost&#x27;, &#x27;apiV1SecretImportsSecretImportIdReplicationResyncPostRequest&#x27;, apiV1SecretImportsSecretImportIdReplicationResyncPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-imports/{secretImportId}/replication-resync&#x60;
                .replace(&#x60;{${&quot;secretImportId&quot;}}&#x60;, encodeURIComponent(String(secretImportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretImportsSecretImportIdReplicationResyncPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsSecretsGet: async (workspaceId: string, environment: string, path?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsSecretsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsSecretsGet&#x27;, &#x27;environment&#x27;, environment)
            const localVarPath &#x3D; &#x60;/api/v1/secret-imports/secrets&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (path !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;path&#x27;] &#x3D; path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsSecretsRawGet: async (workspaceId: string, environment: string, path?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsSecretsRawGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretImportsSecretsRawGet&#x27;, &#x27;environment&#x27;, environment)
            const localVarPath &#x3D; &#x60;/api/v1/secret-imports/secrets/raw&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (path !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;path&#x27;] &#x3D; path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretRotationProvidersWorkspaceIdGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretRotationProvidersWorkspaceIdGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-rotation-providers/{workspaceId}&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretRotationsGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretRotationsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-rotations&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretRotationsIdDelete: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretRotationsIdDelete&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/secret-rotations/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SecretRotationsPostRequest} apiV1SecretRotationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretRotationsPost: async (apiV1SecretRotationsPostRequest: ApiV1SecretRotationsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretRotationsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretRotationsPost&#x27;, &#x27;apiV1SecretRotationsPostRequest&#x27;, apiV1SecretRotationsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-rotations&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretRotationsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretRotationsRestartPost: async (apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretRotationsRestartPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretRotationsRestartPost&#x27;, &#x27;apiV1SecretRotationsRestartPostRequest&#x27;, apiV1SecretRotationsRestartPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-rotations/restart&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretRotationsRestartPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest} apiV1SecretScanningCreateInstallationSessionOrganizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretScanningCreateInstallationSessionOrganizationPost: async (apiV1SecretScanningCreateInstallationSessionOrganizationPostRequest: ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretScanningCreateInstallationSessionOrganizationPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretScanningCreateInstallationSessionOrganizationPost&#x27;, &#x27;apiV1SecretScanningCreateInstallationSessionOrganizationPostRequest&#x27;, apiV1SecretScanningCreateInstallationSessionOrganizationPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-scanning/create-installation-session/organization&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretScanningCreateInstallationSessionOrganizationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-scanning/installation-status/organization/{organizationId}&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SecretScanningLinkInstallationPostRequest} apiV1SecretScanningLinkInstallationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretScanningLinkInstallationPost: async (apiV1SecretScanningLinkInstallationPostRequest: ApiV1SecretScanningLinkInstallationPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretScanningLinkInstallationPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretScanningLinkInstallationPost&#x27;, &#x27;apiV1SecretScanningLinkInstallationPostRequest&#x27;, apiV1SecretScanningLinkInstallationPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-scanning/link-installation&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretScanningLinkInstallationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string | null} [repositoryNames] 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksExportGetResolvedStatusEnum} [resolvedStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretScanningOrganizationOrganizationIdRisksExportGet: async (organizationId: string, repositoryNames?: string | null, resolvedStatus?: ApiV1SecretScanningOrganizationOrganizationIdRisksExportGetResolvedStatusEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretScanningOrganizationOrganizationIdRisksExportGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-scanning/organization/{organizationId}/risks/export&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (repositoryNames !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;repositoryNames&#x27;] &#x3D; repositoryNames;
            }

            if (resolvedStatus !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;resolvedStatus&#x27;] &#x3D; resolvedStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderByEnum} [orderBy] 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderDirectionEnum} [orderDirection] 
         * @param {string | null} [repositoryNames] 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksGetResolvedStatusEnum} [resolvedStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretScanningOrganizationOrganizationIdRisksGet: async (organizationId: string, offset?: number, limit?: number, orderBy?: ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderByEnum, orderDirection?: ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderDirectionEnum, repositoryNames?: string | null, resolvedStatus?: ApiV1SecretScanningOrganizationOrganizationIdRisksGetResolvedStatusEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretScanningOrganizationOrganizationIdRisksGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-scanning/organization/{organizationId}/risks&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (orderBy !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderBy&#x27;] &#x3D; orderBy;
            }

            if (orderDirection !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderDirection&#x27;] &#x3D; orderDirection;
            }

            if (repositoryNames !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;repositoryNames&#x27;] &#x3D; repositoryNames;
            }

            if (resolvedStatus !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;resolvedStatus&#x27;] &#x3D; resolvedStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} riskId 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest} apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPost: async (organizationId: string, riskId: string, apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest: ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPost&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;riskId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPost&#x27;, &#x27;riskId&#x27;, riskId)
            // verify required parameter &#x27;apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPost&#x27;, &#x27;apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest&#x27;, apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-scanning/organization/{organizationId}/risks/{riskId}/status&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)))
                .replace(&#x60;{${&quot;riskId&quot;}}&#x60;, encodeURIComponent(String(riskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} offset 
         * @param {number} limit 
         * @param {string} secretId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSecretIdSecretVersionsGet: async (offset: number, limit: number, secretId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;offset&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSecretIdSecretVersionsGet&#x27;, &#x27;offset&#x27;, offset)
            // verify required parameter &#x27;limit&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSecretIdSecretVersionsGet&#x27;, &#x27;limit&#x27;, limit)
            // verify required parameter &#x27;secretId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSecretIdSecretVersionsGet&#x27;, &#x27;secretId&#x27;, secretId)
            const localVarPath &#x3D; &#x60;/api/v1/secret/{secretId}/secret-versions&#x60;
                .replace(&#x60;{${&quot;secretId&quot;}}&#x60;, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingRequestsGet: async (offset?: number, limit?: number, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/secret-sharing/requests&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingRequestsIdDelete: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSharingRequestsIdDelete&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/secret-sharing/requests/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingRequestsIdGet: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSharingRequestsIdGet&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/secret-sharing/requests/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingRequestsIdRevealValuePost: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSharingRequestsIdRevealValuePost&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/secret-sharing/requests/{id}/reveal-value&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretSharingRequestsIdSetValuePostRequest} apiV1SecretSharingRequestsIdSetValuePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingRequestsIdSetValuePost: async (id: string, apiV1SecretSharingRequestsIdSetValuePostRequest: ApiV1SecretSharingRequestsIdSetValuePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSharingRequestsIdSetValuePost&#x27;, &#x27;id&#x27;, id)
            // verify required parameter &#x27;apiV1SecretSharingRequestsIdSetValuePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSharingRequestsIdSetValuePost&#x27;, &#x27;apiV1SecretSharingRequestsIdSetValuePostRequest&#x27;, apiV1SecretSharingRequestsIdSetValuePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-sharing/requests/{id}/set-value&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSharingRequestsIdSetValuePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SecretSharingRequestsPostRequest} apiV1SecretSharingRequestsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingRequestsPost: async (apiV1SecretSharingRequestsPostRequest: ApiV1SecretSharingRequestsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretSharingRequestsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSharingRequestsPost&#x27;, &#x27;apiV1SecretSharingRequestsPostRequest&#x27;, apiV1SecretSharingRequestsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-sharing/requests&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSharingRequestsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingSharedGet: async (offset?: number, limit?: number, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/secret-sharing/shared&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SecretSharingSharedPostRequest} apiV1SecretSharingSharedPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingSharedPost: async (apiV1SecretSharingSharedPostRequest: ApiV1SecretSharingSharedPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretSharingSharedPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSharingSharedPost&#x27;, &#x27;apiV1SecretSharingSharedPostRequest&#x27;, apiV1SecretSharingSharedPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-sharing/shared&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSharingSharedPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretSharingSharedPublicIdPostRequest} [apiV1SecretSharingSharedPublicIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingSharedPublicIdPost: async (id: string, apiV1SecretSharingSharedPublicIdPostRequest?: ApiV1SecretSharingSharedPublicIdPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSharingSharedPublicIdPost&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/secret-sharing/shared/public/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSharingSharedPublicIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SecretSharingSharedPublicPostRequest} apiV1SecretSharingSharedPublicPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingSharedPublicPost: async (apiV1SecretSharingSharedPublicPostRequest: ApiV1SecretSharingSharedPublicPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretSharingSharedPublicPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSharingSharedPublicPost&#x27;, &#x27;apiV1SecretSharingSharedPublicPostRequest&#x27;, apiV1SecretSharingSharedPublicPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-sharing/shared/public&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSharingSharedPublicPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sharedSecretId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingSharedSharedSecretIdDelete: async (sharedSecretId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;sharedSecretId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSharingSharedSharedSecretIdDelete&#x27;, &#x27;sharedSecretId&#x27;, sharedSecretId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-sharing/shared/{sharedSecretId}&#x60;
                .replace(&#x60;{${&quot;sharedSecretId&quot;}}&#x60;, encodeURIComponent(String(sharedSecretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} secretSnapshotId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSnapshotSecretSnapshotIdGet: async (secretSnapshotId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretSnapshotId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSnapshotSecretSnapshotIdGet&#x27;, &#x27;secretSnapshotId&#x27;, secretSnapshotId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-snapshot/{secretSnapshotId}&#x60;
                .replace(&#x60;{${&quot;secretSnapshotId&quot;}}&#x60;, encodeURIComponent(String(secretSnapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Roll back project secrets to those captured in a secret snapshot version.
         * @param {string} secretSnapshotId The ID of the snapshot to rollback to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSnapshotSecretSnapshotIdRollbackPost: async (secretSnapshotId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretSnapshotId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSnapshotSecretSnapshotIdRollbackPost&#x27;, &#x27;secretSnapshotId&#x27;, secretSnapshotId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-snapshot/{secretSnapshotId}/rollback&#x60;
                .replace(&#x60;{${&quot;secretSnapshotId&quot;}}&#x60;, encodeURIComponent(String(secretSnapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the AWS Parameter Store Syncs for the specified project.
         * @param {string} projectId The ID of the project to list AWS Parameter Store Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsParameterStoreGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-parameter-store&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an AWS Parameter Store Sync for the specified project environment.
         * @param {ApiV1SecretSyncsAwsParameterStorePostRequest} apiV1SecretSyncsAwsParameterStorePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStorePost: async (apiV1SecretSyncsAwsParameterStorePostRequest: ApiV1SecretSyncsAwsParameterStorePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretSyncsAwsParameterStorePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsParameterStorePost&#x27;, &#x27;apiV1SecretSyncsAwsParameterStorePostRequest&#x27;, apiV1SecretSyncsAwsParameterStorePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-parameter-store&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsAwsParameterStorePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified AWS Parameter Store Sync.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to be deleted.
         * @param {ApiV1SecretSyncsAwsParameterStoreSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncIdDelete: async (syncId: string, removeSecrets?: ApiV1SecretSyncsAwsParameterStoreSyncIdDeleteRemoveSecretsEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsParameterStoreSyncIdDelete&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-parameter-store/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (removeSecrets !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;removeSecrets&#x27;] &#x3D; removeSecrets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified AWS Parameter Store Sync by ID.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncIdGet: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsParameterStoreSyncIdGet&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-parameter-store/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import secrets from the specified AWS Parameter Store Sync destination.
         * @param {ApiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or AWS Parameter Store.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPost: async (importBehavior: ApiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;importBehavior&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPost&#x27;, &#x27;importBehavior&#x27;, importBehavior)
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-parameter-store/{syncId}/import-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (importBehavior !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;importBehavior&#x27;] &#x3D; importBehavior;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified AWS Parameter Store Sync.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to be updated.
         * @param {ApiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest} [apiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncIdPatch: async (syncId: string, apiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest?: ApiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsParameterStoreSyncIdPatch&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-parameter-store/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove previously synced secrets from the specified AWS Parameter Store Sync destination.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncIdRemoveSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsParameterStoreSyncIdRemoveSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-parameter-store/{syncId}/remove-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a sync for the specified AWS Parameter Store Sync.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncIdSyncSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsParameterStoreSyncIdSyncSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-parameter-store/{syncId}/sync-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified AWS Parameter Store Sync by name and project ID.
         * @param {string} projectId The ID of the project the AWS Parameter Store Sync is associated with.
         * @param {string} syncName The name of the AWS Parameter Store Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncNameSyncNameGet: async (projectId: string, syncName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsParameterStoreSyncNameSyncNameGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;syncName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsParameterStoreSyncNameSyncNameGet&#x27;, &#x27;syncName&#x27;, syncName)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-parameter-store/sync-name/{syncName}&#x60;
                .replace(&#x60;{${&quot;syncName&quot;}}&#x60;, encodeURIComponent(String(syncName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the AWS Secrets Manager Syncs for the specified project.
         * @param {string} projectId The ID of the project to list AWS Secrets Manager Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsSecretsManagerGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-secrets-manager&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an AWS Secrets Manager Sync for the specified project environment.
         * @param {ApiV1SecretSyncsAwsSecretsManagerPostRequest} apiV1SecretSyncsAwsSecretsManagerPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerPost: async (apiV1SecretSyncsAwsSecretsManagerPostRequest: ApiV1SecretSyncsAwsSecretsManagerPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretSyncsAwsSecretsManagerPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsSecretsManagerPost&#x27;, &#x27;apiV1SecretSyncsAwsSecretsManagerPostRequest&#x27;, apiV1SecretSyncsAwsSecretsManagerPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-secrets-manager&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsAwsSecretsManagerPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified AWS Secrets Manager Sync.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to be deleted.
         * @param {ApiV1SecretSyncsAwsSecretsManagerSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncIdDelete: async (syncId: string, removeSecrets?: ApiV1SecretSyncsAwsSecretsManagerSyncIdDeleteRemoveSecretsEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsSecretsManagerSyncIdDelete&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-secrets-manager/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (removeSecrets !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;removeSecrets&#x27;] &#x3D; removeSecrets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified AWS Secrets Manager Sync by ID.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncIdGet: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsSecretsManagerSyncIdGet&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-secrets-manager/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import secrets from the specified AWS Secrets Manager Sync destination.
         * @param {ApiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or AWS Secrets Manager.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPost: async (importBehavior: ApiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;importBehavior&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPost&#x27;, &#x27;importBehavior&#x27;, importBehavior)
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-secrets-manager/{syncId}/import-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (importBehavior !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;importBehavior&#x27;] &#x3D; importBehavior;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified AWS Secrets Manager Sync.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to be updated.
         * @param {ApiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest} [apiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncIdPatch: async (syncId: string, apiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest?: ApiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsSecretsManagerSyncIdPatch&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-secrets-manager/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove previously synced secrets from the specified AWS Secrets Manager Sync destination.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncIdRemoveSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsSecretsManagerSyncIdRemoveSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-secrets-manager/{syncId}/remove-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a sync for the specified AWS Secrets Manager Sync.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncIdSyncSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsSecretsManagerSyncIdSyncSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-secrets-manager/{syncId}/sync-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified AWS Secrets Manager Sync by name and project ID.
         * @param {string} projectId The ID of the project the AWS Secrets Manager Sync is associated with.
         * @param {string} syncName The name of the AWS Secrets Manager Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncNameSyncNameGet: async (projectId: string, syncName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsSecretsManagerSyncNameSyncNameGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;syncName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAwsSecretsManagerSyncNameSyncNameGet&#x27;, &#x27;syncName&#x27;, syncName)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/aws-secrets-manager/sync-name/{syncName}&#x60;
                .replace(&#x60;{${&quot;syncName&quot;}}&#x60;, encodeURIComponent(String(syncName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Azure App Configuration Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Azure App Configuration Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureAppConfigurationGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-app-configuration&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Azure App Configuration Sync for the specified project environment.
         * @param {ApiV1SecretSyncsAzureAppConfigurationPostRequest} apiV1SecretSyncsAzureAppConfigurationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationPost: async (apiV1SecretSyncsAzureAppConfigurationPostRequest: ApiV1SecretSyncsAzureAppConfigurationPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretSyncsAzureAppConfigurationPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureAppConfigurationPost&#x27;, &#x27;apiV1SecretSyncsAzureAppConfigurationPostRequest&#x27;, apiV1SecretSyncsAzureAppConfigurationPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-app-configuration&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsAzureAppConfigurationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified Azure App Configuration Sync.
         * @param {string} syncId The ID of the Azure App Configuration Sync to be deleted.
         * @param {ApiV1SecretSyncsAzureAppConfigurationSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncIdDelete: async (syncId: string, removeSecrets?: ApiV1SecretSyncsAzureAppConfigurationSyncIdDeleteRemoveSecretsEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureAppConfigurationSyncIdDelete&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-app-configuration/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (removeSecrets !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;removeSecrets&#x27;] &#x3D; removeSecrets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Azure App Configuration Sync by ID.
         * @param {string} syncId The ID of the Azure App Configuration Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncIdGet: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureAppConfigurationSyncIdGet&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-app-configuration/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import secrets from the specified Azure App Configuration Sync destination.
         * @param {ApiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or Azure App Configuration.
         * @param {string} syncId The ID of the Azure App Configuration Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPost: async (importBehavior: ApiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;importBehavior&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPost&#x27;, &#x27;importBehavior&#x27;, importBehavior)
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-app-configuration/{syncId}/import-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (importBehavior !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;importBehavior&#x27;] &#x3D; importBehavior;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified Azure App Configuration Sync.
         * @param {string} syncId The ID of the Azure App Configuration Sync to be updated.
         * @param {ApiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest} [apiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncIdPatch: async (syncId: string, apiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest?: ApiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureAppConfigurationSyncIdPatch&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-app-configuration/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove previously synced secrets from the specified Azure App Configuration Sync destination.
         * @param {string} syncId The ID of the Azure App Configuration Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncIdRemoveSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureAppConfigurationSyncIdRemoveSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-app-configuration/{syncId}/remove-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a sync for the specified Azure App Configuration Sync.
         * @param {string} syncId The ID of the Azure App Configuration Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncIdSyncSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureAppConfigurationSyncIdSyncSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-app-configuration/{syncId}/sync-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Azure App Configuration Sync by name and project ID.
         * @param {string} projectId The ID of the project the Azure App Configuration Sync is associated with.
         * @param {string} syncName The name of the Azure App Configuration Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncNameSyncNameGet: async (projectId: string, syncName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureAppConfigurationSyncNameSyncNameGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;syncName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureAppConfigurationSyncNameSyncNameGet&#x27;, &#x27;syncName&#x27;, syncName)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-app-configuration/sync-name/{syncName}&#x60;
                .replace(&#x60;{${&quot;syncName&quot;}}&#x60;, encodeURIComponent(String(syncName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Azure Key Vault Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Azure Key Vault Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureKeyVaultGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-key-vault&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Azure Key Vault Sync for the specified project environment.
         * @param {ApiV1SecretSyncsAzureKeyVaultPostRequest} apiV1SecretSyncsAzureKeyVaultPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultPost: async (apiV1SecretSyncsAzureKeyVaultPostRequest: ApiV1SecretSyncsAzureKeyVaultPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretSyncsAzureKeyVaultPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureKeyVaultPost&#x27;, &#x27;apiV1SecretSyncsAzureKeyVaultPostRequest&#x27;, apiV1SecretSyncsAzureKeyVaultPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-key-vault&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsAzureKeyVaultPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified Azure Key Vault Sync.
         * @param {string} syncId The ID of the Azure Key Vault Sync to be deleted.
         * @param {ApiV1SecretSyncsAzureKeyVaultSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncIdDelete: async (syncId: string, removeSecrets?: ApiV1SecretSyncsAzureKeyVaultSyncIdDeleteRemoveSecretsEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureKeyVaultSyncIdDelete&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-key-vault/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (removeSecrets !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;removeSecrets&#x27;] &#x3D; removeSecrets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Azure Key Vault Sync by ID.
         * @param {string} syncId The ID of the Azure Key Vault Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncIdGet: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureKeyVaultSyncIdGet&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-key-vault/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import secrets from the specified Azure Key Vault Sync destination.
         * @param {ApiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or Azure Key Vault.
         * @param {string} syncId The ID of the Azure Key Vault Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPost: async (importBehavior: ApiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;importBehavior&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPost&#x27;, &#x27;importBehavior&#x27;, importBehavior)
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-key-vault/{syncId}/import-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (importBehavior !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;importBehavior&#x27;] &#x3D; importBehavior;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified Azure Key Vault Sync.
         * @param {string} syncId The ID of the Azure Key Vault Sync to be updated.
         * @param {ApiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest} [apiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncIdPatch: async (syncId: string, apiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest?: ApiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureKeyVaultSyncIdPatch&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-key-vault/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove previously synced secrets from the specified Azure Key Vault Sync destination.
         * @param {string} syncId The ID of the Azure Key Vault Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncIdRemoveSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureKeyVaultSyncIdRemoveSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-key-vault/{syncId}/remove-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a sync for the specified Azure Key Vault Sync.
         * @param {string} syncId The ID of the Azure Key Vault Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncIdSyncSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureKeyVaultSyncIdSyncSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-key-vault/{syncId}/sync-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Azure Key Vault Sync by name and project ID.
         * @param {string} projectId The ID of the project the Azure Key Vault Sync is associated with.
         * @param {string} syncName The name of the Azure Key Vault Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncNameSyncNameGet: async (projectId: string, syncName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureKeyVaultSyncNameSyncNameGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;syncName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsAzureKeyVaultSyncNameSyncNameGet&#x27;, &#x27;syncName&#x27;, syncName)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/azure-key-vault/sync-name/{syncName}&#x60;
                .replace(&#x60;{${&quot;syncName&quot;}}&#x60;, encodeURIComponent(String(syncName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Databricks Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Databricks Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsDatabricksGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/databricks&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Databricks Sync for the specified project environment.
         * @param {ApiV1SecretSyncsDatabricksPostRequest} apiV1SecretSyncsDatabricksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksPost: async (apiV1SecretSyncsDatabricksPostRequest: ApiV1SecretSyncsDatabricksPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretSyncsDatabricksPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsDatabricksPost&#x27;, &#x27;apiV1SecretSyncsDatabricksPostRequest&#x27;, apiV1SecretSyncsDatabricksPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/databricks&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsDatabricksPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified Databricks Sync.
         * @param {string} syncId The ID of the Databricks Sync to be deleted.
         * @param {ApiV1SecretSyncsDatabricksSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncIdDelete: async (syncId: string, removeSecrets?: ApiV1SecretSyncsDatabricksSyncIdDeleteRemoveSecretsEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsDatabricksSyncIdDelete&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/databricks/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (removeSecrets !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;removeSecrets&#x27;] &#x3D; removeSecrets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Databricks Sync by ID.
         * @param {string} syncId The ID of the Databricks Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncIdGet: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsDatabricksSyncIdGet&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/databricks/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import secrets from the specified Databricks Sync destination.
         * @param {ApiV1SecretSyncsDatabricksSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or Databricks.
         * @param {string} syncId The ID of the Databricks Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncIdImportSecretsPost: async (importBehavior: ApiV1SecretSyncsDatabricksSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;importBehavior&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsDatabricksSyncIdImportSecretsPost&#x27;, &#x27;importBehavior&#x27;, importBehavior)
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsDatabricksSyncIdImportSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/databricks/{syncId}/import-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (importBehavior !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;importBehavior&#x27;] &#x3D; importBehavior;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified Databricks Sync.
         * @param {string} syncId The ID of the Databricks Sync to be updated.
         * @param {ApiV1SecretSyncsDatabricksSyncIdPatchRequest} [apiV1SecretSyncsDatabricksSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncIdPatch: async (syncId: string, apiV1SecretSyncsDatabricksSyncIdPatchRequest?: ApiV1SecretSyncsDatabricksSyncIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsDatabricksSyncIdPatch&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/databricks/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsDatabricksSyncIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove previously synced secrets from the specified Databricks Sync destination.
         * @param {string} syncId The ID of the Databricks Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncIdRemoveSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsDatabricksSyncIdRemoveSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/databricks/{syncId}/remove-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a sync for the specified Databricks Sync.
         * @param {string} syncId The ID of the Databricks Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncIdSyncSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsDatabricksSyncIdSyncSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/databricks/{syncId}/sync-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Databricks Sync by name and project ID.
         * @param {string} projectId The ID of the project the Databricks Sync is associated with.
         * @param {string} syncName The name of the Databricks Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncNameSyncNameGet: async (projectId: string, syncName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsDatabricksSyncNameSyncNameGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;syncName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsDatabricksSyncNameSyncNameGet&#x27;, &#x27;syncName&#x27;, syncName)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/databricks/sync-name/{syncName}&#x60;
                .replace(&#x60;{${&quot;syncName&quot;}}&#x60;, encodeURIComponent(String(syncName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the GCP Secret Manager Syncs for the specified project.
         * @param {string} projectId The ID of the project to list GCP Secret Manager Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGcpSecretManagerGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/gcp-secret-manager&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a GCP Secret Manager Sync for the specified project environment.
         * @param {ApiV1SecretSyncsGcpSecretManagerPostRequest} apiV1SecretSyncsGcpSecretManagerPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerPost: async (apiV1SecretSyncsGcpSecretManagerPostRequest: ApiV1SecretSyncsGcpSecretManagerPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretSyncsGcpSecretManagerPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGcpSecretManagerPost&#x27;, &#x27;apiV1SecretSyncsGcpSecretManagerPostRequest&#x27;, apiV1SecretSyncsGcpSecretManagerPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/gcp-secret-manager&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsGcpSecretManagerPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified GCP Secret Manager Sync.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to be deleted.
         * @param {ApiV1SecretSyncsGcpSecretManagerSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncIdDelete: async (syncId: string, removeSecrets?: ApiV1SecretSyncsGcpSecretManagerSyncIdDeleteRemoveSecretsEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGcpSecretManagerSyncIdDelete&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/gcp-secret-manager/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (removeSecrets !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;removeSecrets&#x27;] &#x3D; removeSecrets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified GCP Secret Manager Sync by ID.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncIdGet: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGcpSecretManagerSyncIdGet&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/gcp-secret-manager/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import secrets from the specified GCP Secret Manager Sync destination.
         * @param {ApiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or GCP Secret Manager.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPost: async (importBehavior: ApiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;importBehavior&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPost&#x27;, &#x27;importBehavior&#x27;, importBehavior)
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/gcp-secret-manager/{syncId}/import-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (importBehavior !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;importBehavior&#x27;] &#x3D; importBehavior;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified GCP Secret Manager Sync.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to be updated.
         * @param {ApiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest} [apiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncIdPatch: async (syncId: string, apiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest?: ApiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGcpSecretManagerSyncIdPatch&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/gcp-secret-manager/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove previously synced secrets from the specified GCP Secret Manager Sync destination.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncIdRemoveSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGcpSecretManagerSyncIdRemoveSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/gcp-secret-manager/{syncId}/remove-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a sync for the specified GCP Secret Manager Sync.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncIdSyncSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGcpSecretManagerSyncIdSyncSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/gcp-secret-manager/{syncId}/sync-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified GCP Secret Manager Sync by name and project ID.
         * @param {string} projectId The ID of the project the GCP Secret Manager Sync is associated with.
         * @param {string} syncName The name of the GCP Secret Manager Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncNameSyncNameGet: async (projectId: string, syncName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGcpSecretManagerSyncNameSyncNameGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;syncName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGcpSecretManagerSyncNameSyncNameGet&#x27;, &#x27;syncName&#x27;, syncName)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/gcp-secret-manager/sync-name/{syncName}&#x60;
                .replace(&#x60;{${&quot;syncName&quot;}}&#x60;, encodeURIComponent(String(syncName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the Secret Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Secret Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the GitHub Syncs for the specified project.
         * @param {string} projectId The ID of the project to list GitHub Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGithubGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/github&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a GitHub Sync for the specified project environment.
         * @param {ApiV1SecretSyncsGithubPostRequest} apiV1SecretSyncsGithubPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubPost: async (apiV1SecretSyncsGithubPostRequest: ApiV1SecretSyncsGithubPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretSyncsGithubPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGithubPost&#x27;, &#x27;apiV1SecretSyncsGithubPostRequest&#x27;, apiV1SecretSyncsGithubPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/github&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsGithubPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified GitHub Sync.
         * @param {string} syncId The ID of the GitHub Sync to be deleted.
         * @param {ApiV1SecretSyncsGithubSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncIdDelete: async (syncId: string, removeSecrets?: ApiV1SecretSyncsGithubSyncIdDeleteRemoveSecretsEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGithubSyncIdDelete&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/github/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (removeSecrets !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;removeSecrets&#x27;] &#x3D; removeSecrets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified GitHub Sync by ID.
         * @param {string} syncId The ID of the GitHub Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncIdGet: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGithubSyncIdGet&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/github/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import secrets from the specified GitHub Sync destination.
         * @param {ApiV1SecretSyncsGithubSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or GitHub.
         * @param {string} syncId The ID of the GitHub Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncIdImportSecretsPost: async (importBehavior: ApiV1SecretSyncsGithubSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;importBehavior&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGithubSyncIdImportSecretsPost&#x27;, &#x27;importBehavior&#x27;, importBehavior)
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGithubSyncIdImportSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/github/{syncId}/import-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (importBehavior !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;importBehavior&#x27;] &#x3D; importBehavior;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified GitHub Sync.
         * @param {string} syncId The ID of the GitHub Sync to be updated.
         * @param {ApiV1SecretSyncsGithubSyncIdPatchRequest} [apiV1SecretSyncsGithubSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncIdPatch: async (syncId: string, apiV1SecretSyncsGithubSyncIdPatchRequest?: ApiV1SecretSyncsGithubSyncIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGithubSyncIdPatch&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/github/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsGithubSyncIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove previously synced secrets from the specified GitHub Sync destination.
         * @param {string} syncId The ID of the GitHub Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncIdRemoveSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGithubSyncIdRemoveSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/github/{syncId}/remove-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a sync for the specified GitHub Sync.
         * @param {string} syncId The ID of the GitHub Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncIdSyncSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGithubSyncIdSyncSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/github/{syncId}/sync-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified GitHub Sync by name and project ID.
         * @param {string} projectId The ID of the project the GitHub Sync is associated with.
         * @param {string} syncName The name of the GitHub Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncNameSyncNameGet: async (projectId: string, syncName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGithubSyncNameSyncNameGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;syncName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsGithubSyncNameSyncNameGet&#x27;, &#x27;syncName&#x27;, syncName)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/github/sync-name/{syncName}&#x60;
                .replace(&#x60;{${&quot;syncName&quot;}}&#x60;, encodeURIComponent(String(syncName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Humanitec Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Humanitec Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsHumanitecGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/humanitec&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Humanitec Sync for the specified project environment.
         * @param {ApiV1SecretSyncsHumanitecPostRequest} apiV1SecretSyncsHumanitecPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecPost: async (apiV1SecretSyncsHumanitecPostRequest: ApiV1SecretSyncsHumanitecPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SecretSyncsHumanitecPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsHumanitecPost&#x27;, &#x27;apiV1SecretSyncsHumanitecPostRequest&#x27;, apiV1SecretSyncsHumanitecPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/humanitec&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsHumanitecPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified Humanitec Sync.
         * @param {string} syncId The ID of the Humanitec Sync to be deleted.
         * @param {ApiV1SecretSyncsHumanitecSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncIdDelete: async (syncId: string, removeSecrets?: ApiV1SecretSyncsHumanitecSyncIdDeleteRemoveSecretsEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsHumanitecSyncIdDelete&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/humanitec/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (removeSecrets !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;removeSecrets&#x27;] &#x3D; removeSecrets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Humanitec Sync by ID.
         * @param {string} syncId The ID of the Humanitec Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncIdGet: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsHumanitecSyncIdGet&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/humanitec/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import secrets from the specified Humanitec Sync destination.
         * @param {ApiV1SecretSyncsHumanitecSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or Humanitec.
         * @param {string} syncId The ID of the Humanitec Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncIdImportSecretsPost: async (importBehavior: ApiV1SecretSyncsHumanitecSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;importBehavior&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsHumanitecSyncIdImportSecretsPost&#x27;, &#x27;importBehavior&#x27;, importBehavior)
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsHumanitecSyncIdImportSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/humanitec/{syncId}/import-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (importBehavior !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;importBehavior&#x27;] &#x3D; importBehavior;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified Humanitec Sync.
         * @param {string} syncId The ID of the Humanitec Sync to be updated.
         * @param {ApiV1SecretSyncsHumanitecSyncIdPatchRequest} [apiV1SecretSyncsHumanitecSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncIdPatch: async (syncId: string, apiV1SecretSyncsHumanitecSyncIdPatchRequest?: ApiV1SecretSyncsHumanitecSyncIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsHumanitecSyncIdPatch&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/humanitec/{syncId}&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SecretSyncsHumanitecSyncIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove previously synced secrets from the specified Humanitec Sync destination.
         * @param {string} syncId The ID of the Humanitec Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncIdRemoveSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsHumanitecSyncIdRemoveSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/humanitec/{syncId}/remove-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a sync for the specified Humanitec Sync.
         * @param {string} syncId The ID of the Humanitec Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncIdSyncSecretsPost: async (syncId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;syncId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsHumanitecSyncIdSyncSecretsPost&#x27;, &#x27;syncId&#x27;, syncId)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/humanitec/{syncId}/sync-secrets&#x60;
                .replace(&#x60;{${&quot;syncId&quot;}}&#x60;, encodeURIComponent(String(syncId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specified Humanitec Sync by name and project ID.
         * @param {string} projectId The ID of the project the Humanitec Sync is associated with.
         * @param {string} syncName The name of the Humanitec Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncNameSyncNameGet: async (projectId: string, syncName: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsHumanitecSyncNameSyncNameGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;syncName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretSyncsHumanitecSyncNameSyncNameGet&#x27;, &#x27;syncName&#x27;, syncName)
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/humanitec/sync-name/{syncName}&#x60;
                .replace(&#x60;{${&quot;syncName&quot;}}&#x60;, encodeURIComponent(String(syncName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the available Secret Sync Options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsOptionsGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/secret-syncs/options&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of users, machine identities, and groups with access to a secret
         * @param {string} workspaceId The ID of the project where the secret is located.
         * @param {string} environment The slug of the environment where the the secret is located.
         * @param {string} secretName The name of the secret to get the access list for.
         * @param {string} [secretPath] The folder path where the secret is located.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretsSecretNameAccessListGet: async (workspaceId: string, environment: string, secretName: string, secretPath?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretsSecretNameAccessListGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretsSecretNameAccessListGet&#x27;, &#x27;environment&#x27;, environment)
            // verify required parameter &#x27;secretName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SecretsSecretNameAccessListGet&#x27;, &#x27;secretName&#x27;, secretName)
            const localVarPath &#x3D; &#x60;/api/v1/secrets/{secretName}/access-list&#x60;
                .replace(&#x60;{${&quot;secretName&quot;}}&#x60;, encodeURIComponent(String(secretName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create SSH CA
         * @param {ApiV1SshCaPostRequest} apiV1SshCaPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCaPost: async (apiV1SshCaPostRequest: ApiV1SshCaPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SshCaPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SshCaPost&#x27;, &#x27;apiV1SshCaPostRequest&#x27;, apiV1SshCaPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/ssh/ca&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SshCaPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of certificate templates for the SSH CA
         * @param {string} sshCaId The ID of the SSH CA to get the certificate templates for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCaSshCaIdCertificateTemplatesGet: async (sshCaId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;sshCaId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SshCaSshCaIdCertificateTemplatesGet&#x27;, &#x27;sshCaId&#x27;, sshCaId)
            const localVarPath &#x3D; &#x60;/api/v1/ssh/ca/{sshCaId}/certificate-templates&#x60;
                .replace(&#x60;{${&quot;sshCaId&quot;}}&#x60;, encodeURIComponent(String(sshCaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete SSH CA
         * @param {string} sshCaId The ID of the SSH CA to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCaSshCaIdDelete: async (sshCaId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;sshCaId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SshCaSshCaIdDelete&#x27;, &#x27;sshCaId&#x27;, sshCaId)
            const localVarPath &#x3D; &#x60;/api/v1/ssh/ca/{sshCaId}&#x60;
                .replace(&#x60;{${&quot;sshCaId&quot;}}&#x60;, encodeURIComponent(String(sshCaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SSH CA
         * @param {string} sshCaId The ID of the SSH CA to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCaSshCaIdGet: async (sshCaId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;sshCaId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SshCaSshCaIdGet&#x27;, &#x27;sshCaId&#x27;, sshCaId)
            const localVarPath &#x3D; &#x60;/api/v1/ssh/ca/{sshCaId}&#x60;
                .replace(&#x60;{${&quot;sshCaId&quot;}}&#x60;, encodeURIComponent(String(sshCaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update SSH CA
         * @param {string} sshCaId The ID of the SSH CA to update.
         * @param {ApiV1SshCaSshCaIdPatchRequest} [apiV1SshCaSshCaIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCaSshCaIdPatch: async (sshCaId: string, apiV1SshCaSshCaIdPatchRequest?: ApiV1SshCaSshCaIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;sshCaId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SshCaSshCaIdPatch&#x27;, &#x27;sshCaId&#x27;, sshCaId)
            const localVarPath &#x3D; &#x60;/api/v1/ssh/ca/{sshCaId}&#x60;
                .replace(&#x60;{${&quot;sshCaId&quot;}}&#x60;, encodeURIComponent(String(sshCaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SshCaSshCaIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get public key of SSH CA
         * @param {string} sshCaId The ID of the SSH CA to get the public key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCaSshCaIdPublicKeyGet: async (sshCaId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;sshCaId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SshCaSshCaIdPublicKeyGet&#x27;, &#x27;sshCaId&#x27;, sshCaId)
            const localVarPath &#x3D; &#x60;/api/v1/ssh/ca/{sshCaId}/public-key&#x60;
                .replace(&#x60;{${&quot;sshCaId&quot;}}&#x60;, encodeURIComponent(String(sshCaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the SSH certificate template to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCertificateTemplatesCertificateTemplateIdDelete: async (certificateTemplateId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;certificateTemplateId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SshCertificateTemplatesCertificateTemplateIdDelete&#x27;, &#x27;certificateTemplateId&#x27;, certificateTemplateId)
            const localVarPath &#x3D; &#x60;/api/v1/ssh/certificate-templates/{certificateTemplateId}&#x60;
                .replace(&#x60;{${&quot;certificateTemplateId&quot;}}&#x60;, encodeURIComponent(String(certificateTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the SSH certificate template to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCertificateTemplatesCertificateTemplateIdGet: async (certificateTemplateId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;certificateTemplateId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SshCertificateTemplatesCertificateTemplateIdGet&#x27;, &#x27;certificateTemplateId&#x27;, certificateTemplateId)
            const localVarPath &#x3D; &#x60;/api/v1/ssh/certificate-templates/{certificateTemplateId}&#x60;
                .replace(&#x60;{${&quot;certificateTemplateId&quot;}}&#x60;, encodeURIComponent(String(certificateTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the SSH certificate template to update.
         * @param {ApiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest} [apiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCertificateTemplatesCertificateTemplateIdPatch: async (certificateTemplateId: string, apiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest?: ApiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;certificateTemplateId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SshCertificateTemplatesCertificateTemplateIdPatch&#x27;, &#x27;certificateTemplateId&#x27;, certificateTemplateId)
            const localVarPath &#x3D; &#x60;/api/v1/ssh/certificate-templates/{certificateTemplateId}&#x60;
                .replace(&#x60;{${&quot;certificateTemplateId&quot;}}&#x60;, encodeURIComponent(String(certificateTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SshCertificateTemplatesPostRequest} apiV1SshCertificateTemplatesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCertificateTemplatesPost: async (apiV1SshCertificateTemplatesPostRequest: ApiV1SshCertificateTemplatesPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SshCertificateTemplatesPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SshCertificateTemplatesPost&#x27;, &#x27;apiV1SshCertificateTemplatesPostRequest&#x27;, apiV1SshCertificateTemplatesPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/ssh/certificate-templates&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SshCertificateTemplatesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Issue SSH credentials (certificate + key)
         * @param {ApiV1SshCertificatesIssuePostRequest} apiV1SshCertificatesIssuePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCertificatesIssuePost: async (apiV1SshCertificatesIssuePostRequest: ApiV1SshCertificatesIssuePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SshCertificatesIssuePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SshCertificatesIssuePost&#x27;, &#x27;apiV1SshCertificatesIssuePostRequest&#x27;, apiV1SshCertificatesIssuePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/ssh/certificates/issue&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SshCertificatesIssuePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign SSH public key
         * @param {ApiV1SshCertificatesSignPostRequest} apiV1SshCertificatesSignPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCertificatesSignPost: async (apiV1SshCertificatesSignPostRequest: ApiV1SshCertificatesSignPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SshCertificatesSignPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SshCertificatesSignPost&#x27;, &#x27;apiV1SshCertificatesSignPostRequest&#x27;, apiV1SshCertificatesSignPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/ssh/certificates/sign&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SshCertificatesSignPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoConfigGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SsoConfigGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v1/sso/config&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (organizationId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;organizationId&#x27;] &#x3D; organizationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SsoConfigPatchRequest} apiV1SsoConfigPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoConfigPatch: async (apiV1SsoConfigPatchRequest: ApiV1SsoConfigPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SsoConfigPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SsoConfigPatch&#x27;, &#x27;apiV1SsoConfigPatchRequest&#x27;, apiV1SsoConfigPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/sso/config&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SsoConfigPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SsoConfigPostRequest} apiV1SsoConfigPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoConfigPost: async (apiV1SsoConfigPostRequest: ApiV1SsoConfigPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SsoConfigPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SsoConfigPost&#x27;, &#x27;apiV1SsoConfigPostRequest&#x27;, apiV1SsoConfigPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/sso/config&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SsoConfigPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoGithubGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/sso/github&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoGitlabGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/sso/gitlab&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoGoogleGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/sso/google&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcCallbackGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/sso/oidc/callback&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcConfigGet: async (orgSlug: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;orgSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SsoOidcConfigGet&#x27;, &#x27;orgSlug&#x27;, orgSlug)
            const localVarPath &#x3D; &#x60;/api/v1/sso/oidc/config&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (orgSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orgSlug&#x27;] &#x3D; orgSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SsoOidcConfigPatchRequest} apiV1SsoOidcConfigPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcConfigPatch: async (apiV1SsoOidcConfigPatchRequest: ApiV1SsoOidcConfigPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SsoOidcConfigPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SsoOidcConfigPatch&#x27;, &#x27;apiV1SsoOidcConfigPatchRequest&#x27;, apiV1SsoOidcConfigPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/sso/oidc/config&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SsoOidcConfigPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SsoOidcConfigPostRequest} apiV1SsoOidcConfigPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcConfigPost: async (apiV1SsoOidcConfigPostRequest: ApiV1SsoOidcConfigPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SsoOidcConfigPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SsoOidcConfigPost&#x27;, &#x27;apiV1SsoOidcConfigPostRequest&#x27;, apiV1SsoOidcConfigPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/sso/oidc/config&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SsoOidcConfigPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcLoginErrorGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/sso/oidc/login/error&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgSlug 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcLoginGet: async (orgSlug: string, callbackPort?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;orgSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SsoOidcLoginGet&#x27;, &#x27;orgSlug&#x27;, orgSlug)
            const localVarPath &#x3D; &#x60;/api/v1/sso/oidc/login&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (orgSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orgSlug&#x27;] &#x3D; orgSlug;
            }

            if (callbackPort !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;callbackPort&#x27;] &#x3D; callbackPort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcManageGroupMembershipsGet: async (orgId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;orgId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SsoOidcManageGroupMembershipsGet&#x27;, &#x27;orgId&#x27;, orgId)
            const localVarPath &#x3D; &#x60;/api/v1/sso/oidc/manage-group-memberships&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (orgId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orgId&#x27;] &#x3D; orgId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoRedirectGithubGet: async (callbackPort?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/sso/redirect/github&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (callbackPort !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;callback_port&#x27;] &#x3D; callbackPort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoRedirectGitlabGet: async (callbackPort?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/sso/redirect/gitlab&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (callbackPort !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;callback_port&#x27;] &#x3D; callbackPort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoRedirectGoogleGet: async (callbackPort?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/sso/redirect/google&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (callbackPort !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;callback_port&#x27;] &#x3D; callbackPort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgSlug 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoRedirectOrganizationsOrgSlugGet: async (orgSlug: string, callbackPort?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;orgSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SsoRedirectOrganizationsOrgSlugGet&#x27;, &#x27;orgSlug&#x27;, orgSlug)
            const localVarPath &#x3D; &#x60;/api/v1/sso/redirect/organizations/{orgSlug}&#x60;
                .replace(&#x60;{${&quot;orgSlug&quot;}}&#x60;, encodeURIComponent(String(orgSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (callbackPort !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;callback_port&#x27;] &#x3D; callbackPort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgSlug 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoRedirectSaml2OrganizationsOrgSlugGet: async (orgSlug: string, callbackPort?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;orgSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SsoRedirectSaml2OrganizationsOrgSlugGet&#x27;, &#x27;orgSlug&#x27;, orgSlug)
            const localVarPath &#x3D; &#x60;/api/v1/sso/redirect/saml2/organizations/{orgSlug}&#x60;
                .replace(&#x60;{${&quot;orgSlug&quot;}}&#x60;, encodeURIComponent(String(orgSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (callbackPort !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;callback_port&#x27;] &#x3D; callbackPort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} samlConfigId 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoRedirectSaml2SamlConfigIdGet: async (samlConfigId: string, callbackPort?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;samlConfigId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SsoRedirectSaml2SamlConfigIdGet&#x27;, &#x27;samlConfigId&#x27;, samlConfigId)
            const localVarPath &#x3D; &#x60;/api/v1/sso/redirect/saml2/{samlConfigId}&#x60;
                .replace(&#x60;{${&quot;samlConfigId&quot;}}&#x60;, encodeURIComponent(String(samlConfigId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (callbackPort !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;callback_port&#x27;] &#x3D; callbackPort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} samlConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoSaml2SamlConfigIdPost: async (samlConfigId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;samlConfigId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SsoSaml2SamlConfigIdPost&#x27;, &#x27;samlConfigId&#x27;, samlConfigId)
            const localVarPath &#x3D; &#x60;/api/v1/sso/saml2/{samlConfigId}&#x60;
                .replace(&#x60;{${&quot;samlConfigId&quot;}}&#x60;, encodeURIComponent(String(samlConfigId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1SsoTokenExchangePostRequest} apiV1SsoTokenExchangePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoTokenExchangePost: async (apiV1SsoTokenExchangePostRequest: ApiV1SsoTokenExchangePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1SsoTokenExchangePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1SsoTokenExchangePost&#x27;, &#x27;apiV1SsoTokenExchangePostRequest&#x27;, apiV1SsoTokenExchangePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/sso/token-exchange&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1SsoTokenExchangePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserActionGet: async (action: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;action&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserActionGet&#x27;, &#x27;action&#x27;, action)
            const localVarPath &#x3D; &#x60;/api/v1/user-action&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (action !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;action&#x27;] &#x3D; action;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserActionPostRequest} apiV1UserActionPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserActionPost: async (apiV1UserActionPostRequest: ApiV1UserActionPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1UserActionPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserActionPost&#x27;, &#x27;apiV1UserActionPostRequest&#x27;, apiV1UserActionPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/user-action&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1UserActionPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserEngagementMeWishPostRequest} apiV1UserEngagementMeWishPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserEngagementMeWishPost: async (apiV1UserEngagementMeWishPostRequest: ApiV1UserEngagementMeWishPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1UserEngagementMeWishPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserEngagementMeWishPost&#x27;, &#x27;apiV1UserEngagementMeWishPostRequest&#x27;, apiV1UserEngagementMeWishPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/user-engagement/me/wish&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1UserEngagementMeWishPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/user&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeProjectFavoritesGet: async (orgId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;orgId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserMeProjectFavoritesGet&#x27;, &#x27;orgId&#x27;, orgId)
            const localVarPath &#x3D; &#x60;/api/v1/user/me/project-favorites&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (orgId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orgId&#x27;] &#x3D; orgId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserMeProjectFavoritesPutRequest} apiV1UserMeProjectFavoritesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeProjectFavoritesPut: async (apiV1UserMeProjectFavoritesPutRequest: ApiV1UserMeProjectFavoritesPutRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1UserMeProjectFavoritesPutRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserMeProjectFavoritesPut&#x27;, &#x27;apiV1UserMeProjectFavoritesPutRequest&#x27;, apiV1UserMeProjectFavoritesPutRequest)
            const localVarPath &#x3D; &#x60;/api/v1/user/me/project-favorites&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PUT&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1UserMeProjectFavoritesPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeTotpDelete: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/user/me/totp&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeTotpGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/user/me/totp&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeTotpRecoveryCodesPost: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/user/me/totp/recovery-codes&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeTotpRegisterPost: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/user/me/totp/register&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserMeTotpVerifyPostRequest} apiV1UserMeTotpVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeTotpVerifyPost: async (apiV1UserMeTotpVerifyPostRequest: ApiV1UserMeTotpVerifyPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1UserMeTotpVerifyPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserMeTotpVerifyPost&#x27;, &#x27;apiV1UserMeTotpVerifyPostRequest&#x27;, apiV1UserMeTotpVerifyPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/user/me/totp/verify&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1UserMeTotpVerifyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeUsernameGroupsGet: async (username: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;username&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserMeUsernameGroupsGet&#x27;, &#x27;username&#x27;, username)
            const localVarPath &#x3D; &#x60;/api/v1/user/me/{username}/groups&#x60;
                .replace(&#x60;{${&quot;username&quot;}}&#x60;, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserPrivateKeyGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/user/private-key&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectMembershipId Project membership ID of user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProjectAdditionalPrivilegeGet: async (projectMembershipId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectMembershipId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserProjectAdditionalPrivilegeGet&#x27;, &#x27;projectMembershipId&#x27;, projectMembershipId)
            const localVarPath &#x3D; &#x60;/api/v1/user-project-additional-privilege&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (projectMembershipId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectMembershipId&#x27;] &#x3D; projectMembershipId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserProjectAdditionalPrivilegePostRequest} apiV1UserProjectAdditionalPrivilegePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProjectAdditionalPrivilegePost: async (apiV1UserProjectAdditionalPrivilegePostRequest: ApiV1UserProjectAdditionalPrivilegePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1UserProjectAdditionalPrivilegePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserProjectAdditionalPrivilegePost&#x27;, &#x27;apiV1UserProjectAdditionalPrivilegePostRequest&#x27;, apiV1UserProjectAdditionalPrivilegePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/user-project-additional-privilege&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1UserProjectAdditionalPrivilegePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} privilegeId The ID of privilege object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProjectAdditionalPrivilegePrivilegeIdDelete: async (privilegeId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;privilegeId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserProjectAdditionalPrivilegePrivilegeIdDelete&#x27;, &#x27;privilegeId&#x27;, privilegeId)
            const localVarPath &#x3D; &#x60;/api/v1/user-project-additional-privilege/{privilegeId}&#x60;
                .replace(&#x60;{${&quot;privilegeId&quot;}}&#x60;, encodeURIComponent(String(privilegeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} privilegeId The ID of privilege object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProjectAdditionalPrivilegePrivilegeIdGet: async (privilegeId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;privilegeId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserProjectAdditionalPrivilegePrivilegeIdGet&#x27;, &#x27;privilegeId&#x27;, privilegeId)
            const localVarPath &#x3D; &#x60;/api/v1/user-project-additional-privilege/{privilegeId}&#x60;
                .replace(&#x60;{${&quot;privilegeId&quot;}}&#x60;, encodeURIComponent(String(privilegeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} privilegeId The ID of privilege object.
         * @param {ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest} [apiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProjectAdditionalPrivilegePrivilegeIdPatch: async (privilegeId: string, apiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest?: ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;privilegeId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserProjectAdditionalPrivilegePrivilegeIdPatch&#x27;, &#x27;privilegeId&#x27;, privilegeId)
            const localVarPath &#x3D; &#x60;/api/v1/user-project-additional-privilege/{privilegeId}&#x60;
                .replace(&#x60;{${&quot;privilegeId&quot;}}&#x60;, encodeURIComponent(String(privilegeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserUserIdUnlockGet: async (token: string, userId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;token&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserUserIdUnlockGet&#x27;, &#x27;token&#x27;, token)
            // verify required parameter &#x27;userId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1UserUserIdUnlockGet&#x27;, &#x27;userId&#x27;, userId)
            const localVarPath &#x3D; &#x60;/api/v1/user/{userId}/unlock&#x60;
                .replace(&#x60;{${&quot;userId&quot;}}&#x60;, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (token !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;token&#x27;] &#x3D; token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [environment] 
         * @param {string} [secretPath] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WebhooksGet: async (workspaceId: string, environment?: string, secretPath?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WebhooksGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/webhooks&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1WebhooksPostRequest} apiV1WebhooksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WebhooksPost: async (apiV1WebhooksPostRequest: ApiV1WebhooksPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1WebhooksPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WebhooksPost&#x27;, &#x27;apiV1WebhooksPostRequest&#x27;, apiV1WebhooksPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/webhooks&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WebhooksPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WebhooksWebhookIdDelete: async (webhookId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;webhookId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WebhooksWebhookIdDelete&#x27;, &#x27;webhookId&#x27;, webhookId)
            const localVarPath &#x3D; &#x60;/api/v1/webhooks/{webhookId}&#x60;
                .replace(&#x60;{${&quot;webhookId&quot;}}&#x60;, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {ApiV1WebhooksWebhookIdPatchRequest} [apiV1WebhooksWebhookIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WebhooksWebhookIdPatch: async (webhookId: string, apiV1WebhooksWebhookIdPatchRequest?: ApiV1WebhooksWebhookIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;webhookId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WebhooksWebhookIdPatch&#x27;, &#x27;webhookId&#x27;, webhookId)
            const localVarPath &#x3D; &#x60;/api/v1/webhooks/{webhookId}&#x60;
                .replace(&#x60;{${&quot;webhookId&quot;}}&#x60;, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WebhooksWebhookIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WebhooksWebhookIdTestPost: async (webhookId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;webhookId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WebhooksWebhookIdTestPost&#x27;, &#x27;webhookId&#x27;, webhookId)
            const localVarPath &#x3D; &#x60;/api/v1/webhooks/{webhookId}/test&#x60;
                .replace(&#x60;{${&quot;webhookId&quot;}}&#x60;, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/workflow-integrations&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/workflow-integrations/slack&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackIdChannelsGet: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkflowIntegrationsSlackIdChannelsGet&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/workflow-integrations/slack/{id}/channels&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackIdDelete: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkflowIntegrationsSlackIdDelete&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/workflow-integrations/slack/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackIdGet: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkflowIntegrationsSlackIdGet&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/workflow-integrations/slack/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1WorkflowIntegrationsSlackIdPatchRequest} [apiV1WorkflowIntegrationsSlackIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackIdPatch: async (id: string, apiV1WorkflowIntegrationsSlackIdPatchRequest?: ApiV1WorkflowIntegrationsSlackIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkflowIntegrationsSlackIdPatch&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/workflow-integrations/slack/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkflowIntegrationsSlackIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} slug 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackInstallGet: async (slug: string, description?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;slug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkflowIntegrationsSlackInstallGet&#x27;, &#x27;slug&#x27;, slug)
            const localVarPath &#x3D; &#x60;/api/v1/workflow-integrations/slack/install&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (slug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;slug&#x27;] &#x3D; slug;
            }

            if (description !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;description&#x27;] &#x3D; description;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackOauthRedirectGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/workflow-integrations/slack/oauth_redirect&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackReinstallGet: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkflowIntegrationsSlackReinstallGet&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/workflow-integrations/slack/reinstall&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;id&#x27;] &#x3D; id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Environment by ID
         * @param {string} envId The ID of the environment to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceEnvironmentsEnvIdGet: async (envId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;envId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceEnvironmentsEnvIdGet&#x27;, &#x27;envId&#x27;, envId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/environments/{envId}&#x60;
                .replace(&#x60;{${&quot;envId&quot;}}&#x60;, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1WorkspaceGetIncludeRolesEnum} [includeRoles] 
         * @param {ApiV1WorkspaceGetTypeEnum} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceGet: async (includeRoles?: ApiV1WorkspaceGetIncludeRolesEnum, type?: ApiV1WorkspaceGetTypeEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v1/workspace&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (includeRoles !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;includeRoles&#x27;] &#x3D; includeRoles;
            }

            if (type !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;type&#x27;] &#x3D; type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdPermissionsGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectIdPermissionsGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{projectId}/permissions&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId The ID of the project to list tags from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdTagsGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectIdTagsGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{projectId}/tags&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId The ID of the project to create the tag in.
         * @param {ApiV1WorkspaceProjectIdTagsPostRequest} apiV1WorkspaceProjectIdTagsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdTagsPost: async (projectId: string, apiV1WorkspaceProjectIdTagsPostRequest: ApiV1WorkspaceProjectIdTagsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectIdTagsPost&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;apiV1WorkspaceProjectIdTagsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectIdTagsPost&#x27;, &#x27;apiV1WorkspaceProjectIdTagsPostRequest&#x27;, apiV1WorkspaceProjectIdTagsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{projectId}/tags&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceProjectIdTagsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId The ID of the project to get tags from.
         * @param {string} tagSlug The slug of the tag to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdTagsSlugTagSlugGet: async (projectId: string, tagSlug: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectIdTagsSlugTagSlugGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;tagSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectIdTagsSlugTagSlugGet&#x27;, &#x27;tagSlug&#x27;, tagSlug)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{projectId}/tags/slug/{tagSlug}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;tagSlug&quot;}}&#x60;, encodeURIComponent(String(tagSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId The ID of the project to delete the tag from.
         * @param {string} tagId The ID of the tag to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdTagsTagIdDelete: async (projectId: string, tagId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectIdTagsTagIdDelete&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;tagId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectIdTagsTagIdDelete&#x27;, &#x27;tagId&#x27;, tagId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{projectId}/tags/{tagId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;tagId&quot;}}&#x60;, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId The ID of the project to get tags from.
         * @param {string} tagId The ID of the tag to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdTagsTagIdGet: async (projectId: string, tagId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectIdTagsTagIdGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;tagId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectIdTagsTagIdGet&#x27;, &#x27;tagId&#x27;, tagId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{projectId}/tags/{tagId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;tagId&quot;}}&#x60;, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId The ID of the project to update the tag in.
         * @param {string} tagId The ID of the tag to get details.
         * @param {ApiV1WorkspaceProjectIdTagsTagIdPatchRequest} apiV1WorkspaceProjectIdTagsTagIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdTagsTagIdPatch: async (projectId: string, tagId: string, apiV1WorkspaceProjectIdTagsTagIdPatchRequest: ApiV1WorkspaceProjectIdTagsTagIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectIdTagsTagIdPatch&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;tagId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectIdTagsTagIdPatch&#x27;, &#x27;tagId&#x27;, tagId)
            // verify required parameter &#x27;apiV1WorkspaceProjectIdTagsTagIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectIdTagsTagIdPatch&#x27;, &#x27;apiV1WorkspaceProjectIdTagsTagIdPatchRequest&#x27;, apiV1WorkspaceProjectIdTagsTagIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{projectId}/tags/{tagId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;tagId&quot;}}&#x60;, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceProjectIdTagsTagIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List project role
         * @param {string} projectSlug The slug of the project to list the roles of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectSlugRolesGet: async (projectSlug: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectSlugRolesGet&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{projectSlug}/roles&#x60;
                .replace(&#x60;{${&quot;projectSlug&quot;}}&#x60;, encodeURIComponent(String(projectSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a project role
         * @param {string} projectSlug Slug of the project to create the role for.
         * @param {ApiV1WorkspaceProjectSlugRolesPostRequest} apiV1WorkspaceProjectSlugRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectSlugRolesPost: async (projectSlug: string, apiV1WorkspaceProjectSlugRolesPostRequest: ApiV1WorkspaceProjectSlugRolesPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectSlugRolesPost&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            // verify required parameter &#x27;apiV1WorkspaceProjectSlugRolesPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectSlugRolesPost&#x27;, &#x27;apiV1WorkspaceProjectSlugRolesPostRequest&#x27;, apiV1WorkspaceProjectSlugRolesPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{projectSlug}/roles&#x60;
                .replace(&#x60;{${&quot;projectSlug&quot;}}&#x60;, encodeURIComponent(String(projectSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceProjectSlugRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a project role
         * @param {string} projectSlug The slug of the project to delete this role for.
         * @param {string} roleId The ID of the role to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectSlugRolesRoleIdDelete: async (projectSlug: string, roleId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectSlugRolesRoleIdDelete&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            // verify required parameter &#x27;roleId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectSlugRolesRoleIdDelete&#x27;, &#x27;roleId&#x27;, roleId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{projectSlug}/roles/{roleId}&#x60;
                .replace(&#x60;{${&quot;projectSlug&quot;}}&#x60;, encodeURIComponent(String(projectSlug)))
                .replace(&#x60;{${&quot;roleId&quot;}}&#x60;, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a project role
         * @param {string} projectSlug The slug of the project to update the role for.
         * @param {string} roleId The ID of the role to update
         * @param {ApiV1WorkspaceProjectSlugRolesRoleIdPatchRequest} [apiV1WorkspaceProjectSlugRolesRoleIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectSlugRolesRoleIdPatch: async (projectSlug: string, roleId: string, apiV1WorkspaceProjectSlugRolesRoleIdPatchRequest?: ApiV1WorkspaceProjectSlugRolesRoleIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectSlugRolesRoleIdPatch&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            // verify required parameter &#x27;roleId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectSlugRolesRoleIdPatch&#x27;, &#x27;roleId&#x27;, roleId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{projectSlug}/roles/{roleId}&#x60;
                .replace(&#x60;{${&quot;projectSlug&quot;}}&#x60;, encodeURIComponent(String(projectSlug)))
                .replace(&#x60;{${&quot;roleId&quot;}}&#x60;, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceProjectSlugRolesRoleIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project.
         * @param {string} slug The slug of the role to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectSlugRolesSlugSlugGet: async (projectSlug: string, slug: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectSlugRolesSlugSlugGet&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            // verify required parameter &#x27;slug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceProjectSlugRolesSlugSlugGet&#x27;, &#x27;slug&#x27;, slug)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{projectSlug}/roles/slug/{slug}&#x60;
                .replace(&#x60;{${&quot;projectSlug&quot;}}&#x60;, encodeURIComponent(String(projectSlug)))
                .replace(&#x60;{${&quot;slug&quot;}}&#x60;, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/audit-logs/filters/actors&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return audit logs
         * @param {string} workspaceId Optionally filter logs by project ID. If not provided, logs from the entire organization will be returned.
         * @param {ApiV1WorkspaceWorkspaceIdAuditLogsGetEventTypeEnum} [eventType] The type of the event to export.
         * @param {ApiV1WorkspaceWorkspaceIdAuditLogsGetUserAgentTypeEnum} [userAgentType] Choose which consuming application to export audit logs for.
         * @param {string} [startDate] The date to start the export from.
         * @param {string} [endDate] The date to end the export at.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th audit log.
         * @param {number} [limit] The number of audit logs to return.
         * @param {string} [actor] The actor to filter the audit logs by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdAuditLogsGet: async (workspaceId: string, eventType?: ApiV1WorkspaceWorkspaceIdAuditLogsGetEventTypeEnum, userAgentType?: ApiV1WorkspaceWorkspaceIdAuditLogsGetUserAgentTypeEnum, startDate?: string, endDate?: string, offset?: number, limit?: number, actor?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdAuditLogsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/audit-logs&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (eventType !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;eventType&#x27;] &#x3D; eventType;
            }

            if (userAgentType !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;userAgentType&#x27;] &#x3D; userAgentType;
            }

            if (startDate !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;startDate&#x27;] &#x3D; (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;endDate&#x27;] &#x3D; (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (actor !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;actor&#x27;] &#x3D; actor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List integration auth objects for a workspace.
         * @param {string} workspaceId The ID of the project to list integration auths for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdAuthorizationsGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdAuthorizationsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/authorizations&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest} apiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdAutoCapitalizationPost: async (workspaceId: string, apiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest: ApiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdAutoCapitalizationPost&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdAutoCapitalizationPost&#x27;, &#x27;apiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest&#x27;, apiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/auto-capitalization&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete project
         * @param {string} workspaceId The ID of the project to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdDelete: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdDelete&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdEnvironmentFolderTreeGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdEnvironmentFolderTreeGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/environment-folder-tree&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Environment
         * @param {string} workspaceId The ID of the project the environment belongs to.
         * @param {string} envId The ID of the environment to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet: async (workspaceId: string, envId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;envId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet&#x27;, &#x27;envId&#x27;, envId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/environments/{envId}&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)))
                .replace(&#x60;{${&quot;envId&quot;}}&#x60;, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete environment
         * @param {string} workspaceId The ID of the project to delete the environment from.
         * @param {string} id The ID of the environment to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdEnvironmentsIdDelete: async (workspaceId: string, id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdEnvironmentsIdDelete&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdEnvironmentsIdDelete&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/environments/{id}&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)))
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update environment
         * @param {string} workspaceId The ID of the project to update the environment in.
         * @param {string} id The ID of the environment to update.
         * @param {ApiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest} [apiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdEnvironmentsIdPatch: async (workspaceId: string, id: string, apiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest?: ApiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdEnvironmentsIdPatch&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdEnvironmentsIdPatch&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/environments/{id}&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)))
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create environment
         * @param {string} workspaceId The ID of the project to create the environment in.
         * @param {ApiV1WorkspaceWorkspaceIdEnvironmentsPostRequest} apiV1WorkspaceWorkspaceIdEnvironmentsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdEnvironmentsPost: async (workspaceId: string, apiV1WorkspaceWorkspaceIdEnvironmentsPostRequest: ApiV1WorkspaceWorkspaceIdEnvironmentsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdEnvironmentsPost&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceIdEnvironmentsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdEnvironmentsPost&#x27;, &#x27;apiV1WorkspaceWorkspaceIdEnvironmentsPostRequest&#x27;, apiV1WorkspaceWorkspaceIdEnvironmentsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/environments&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdEnvironmentsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get project
         * @param {string} workspaceId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List integrations for a project.
         * @param {string} workspaceId The ID of the project to list integrations for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdIntegrationsGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdIntegrationsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/integrations&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdKeyPostRequest} apiV1WorkspaceWorkspaceIdKeyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdKeyPost: async (workspaceId: string, apiV1WorkspaceWorkspaceIdKeyPostRequest: ApiV1WorkspaceWorkspaceIdKeyPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdKeyPost&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceIdKeyPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdKeyPost&#x27;, &#x27;apiV1WorkspaceWorkspaceIdKeyPostRequest&#x27;, apiV1WorkspaceWorkspaceIdKeyPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/key&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdKeyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdKeysGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdKeysGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/keys&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdKmsBackupGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdKmsBackupGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/kms/backup&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdKmsBackupPostRequest} apiV1WorkspaceWorkspaceIdKmsBackupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdKmsBackupPost: async (workspaceId: string, apiV1WorkspaceWorkspaceIdKmsBackupPostRequest: ApiV1WorkspaceWorkspaceIdKmsBackupPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdKmsBackupPost&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceIdKmsBackupPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdKmsBackupPost&#x27;, &#x27;apiV1WorkspaceWorkspaceIdKmsBackupPostRequest&#x27;, apiV1WorkspaceWorkspaceIdKmsBackupPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/kms/backup&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdKmsBackupPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdKmsGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdKmsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/kms&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdKmsPatchRequest} apiV1WorkspaceWorkspaceIdKmsPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdKmsPatch: async (workspaceId: string, apiV1WorkspaceWorkspaceIdKmsPatchRequest: ApiV1WorkspaceWorkspaceIdKmsPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdKmsPatch&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceIdKmsPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdKmsPatch&#x27;, &#x27;apiV1WorkspaceWorkspaceIdKmsPatchRequest&#x27;, apiV1WorkspaceWorkspaceIdKmsPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/kms&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdKmsPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdLeaveDelete: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdLeaveDelete&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/leave&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return project user memberships
         * @param {string} workspaceId The ID of the project to get memberships from.
         * @param {ApiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest} apiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMembershipsDetailsPost: async (workspaceId: string, apiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest: ApiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdMembershipsDetailsPost&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdMembershipsDetailsPost&#x27;, &#x27;apiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest&#x27;, apiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/memberships/details&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return project user memberships
         * @param {string} workspaceId The ID of the project to get memberships from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMembershipsGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdMembershipsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/memberships&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete project user membership
         * @param {string} workspaceId 
         * @param {string} membershipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMembershipsMembershipIdDelete: async (workspaceId: string, membershipId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdMembershipsMembershipIdDelete&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;membershipId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdMembershipsMembershipIdDelete&#x27;, &#x27;membershipId&#x27;, membershipId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/memberships/{membershipId}&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)))
                .replace(&#x60;{${&quot;membershipId&quot;}}&#x60;, encodeURIComponent(String(membershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return project user membership
         * @param {string} workspaceId The ID of the project to get memberships from.
         * @param {string} membershipId The ID of the user\&amp;#39;s project membership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMembershipsMembershipIdGet: async (workspaceId: string, membershipId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdMembershipsMembershipIdGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;membershipId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdMembershipsMembershipIdGet&#x27;, &#x27;membershipId&#x27;, membershipId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/memberships/{membershipId}&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)))
                .replace(&#x60;{${&quot;membershipId&quot;}}&#x60;, encodeURIComponent(String(membershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update project user membership
         * @param {string} workspaceId The ID of the project to update the membership for.
         * @param {string} membershipId The ID of the membership to update.
         * @param {ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest} apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch: async (workspaceId: string, membershipId: string, apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest: ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;membershipId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch&#x27;, &#x27;membershipId&#x27;, membershipId)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch&#x27;, &#x27;apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest&#x27;, apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/memberships/{membershipId}&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)))
                .replace(&#x60;{${&quot;membershipId&quot;}}&#x60;, encodeURIComponent(String(membershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdMembershipsPostRequest} apiV1WorkspaceWorkspaceIdMembershipsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMembershipsPost: async (workspaceId: string, apiV1WorkspaceWorkspaceIdMembershipsPostRequest: ApiV1WorkspaceWorkspaceIdMembershipsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdMembershipsPost&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceIdMembershipsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdMembershipsPost&#x27;, &#x27;apiV1WorkspaceWorkspaceIdMembershipsPostRequest&#x27;, apiV1WorkspaceWorkspaceIdMembershipsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/memberships&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdMembershipsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMigrateV3Post: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdMigrateV3Post&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/migrate-v3&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdNamePostRequest} apiV1WorkspaceWorkspaceIdNamePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdNamePost: async (workspaceId: string, apiV1WorkspaceWorkspaceIdNamePostRequest: ApiV1WorkspaceWorkspaceIdNamePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdNamePost&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceIdNamePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdNamePost&#x27;, &#x27;apiV1WorkspaceWorkspaceIdNamePostRequest&#x27;, apiV1WorkspaceWorkspaceIdNamePostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/name&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdNamePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update project
         * @param {string} workspaceId The ID of the project to update.
         * @param {ApiV1WorkspaceWorkspaceIdPatchRequest} [apiV1WorkspaceWorkspaceIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdPatch: async (workspaceId: string, apiV1WorkspaceWorkspaceIdPatchRequest?: ApiV1WorkspaceWorkspaceIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdPatch&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} environment 
         * @param {string} workspaceId 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet: async (environment: string, workspaceId: string, path?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet&#x27;, &#x27;environment&#x27;, environment)
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/secret-snapshots/count&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (path !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;path&#x27;] &#x3D; path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return project secret snapshots ids
         * @param {string} environment The environment to get snapshots from.
         * @param {string} workspaceId The ID of the project to get snapshots from.
         * @param {string} [path] The secret path to get snapshots from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th snapshot.
         * @param {number} [limit] The number of snapshots to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdSecretSnapshotsGet: async (environment: string, workspaceId: string, path?: string, offset?: number, limit?: number, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdSecretSnapshotsGet&#x27;, &#x27;environment&#x27;, environment)
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdSecretSnapshotsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/secret-snapshots&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (path !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;path&#x27;] &#x3D; path;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdServiceTokenDataGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdServiceTokenDataGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/service-token-data&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdSlackConfigGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdSlackConfigGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/slack-config&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdSlackConfigPutRequest} apiV1WorkspaceWorkspaceIdSlackConfigPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdSlackConfigPut: async (workspaceId: string, apiV1WorkspaceWorkspaceIdSlackConfigPutRequest: ApiV1WorkspaceWorkspaceIdSlackConfigPutRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdSlackConfigPut&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceIdSlackConfigPutRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdSlackConfigPut&#x27;, &#x27;apiV1WorkspaceWorkspaceIdSlackConfigPutRequest&#x27;, apiV1WorkspaceWorkspaceIdSlackConfigPutRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/slack-config&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PUT&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdSlackConfigPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdTrustedIpsGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdTrustedIpsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/trusted-ips&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdTrustedIpsPostRequest} apiV1WorkspaceWorkspaceIdTrustedIpsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdTrustedIpsPost: async (workspaceId: string, apiV1WorkspaceWorkspaceIdTrustedIpsPostRequest: ApiV1WorkspaceWorkspaceIdTrustedIpsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdTrustedIpsPost&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceIdTrustedIpsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdTrustedIpsPost&#x27;, &#x27;apiV1WorkspaceWorkspaceIdTrustedIpsPostRequest&#x27;, apiV1WorkspaceWorkspaceIdTrustedIpsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/trusted-ips&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdTrustedIpsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} trustedIpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdDelete: async (workspaceId: string, trustedIpId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdDelete&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;trustedIpId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdDelete&#x27;, &#x27;trustedIpId&#x27;, trustedIpId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/trusted-ips/{trustedIpId}&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)))
                .replace(&#x60;{${&quot;trustedIpId&quot;}}&#x60;, encodeURIComponent(String(trustedIpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} trustedIpId 
         * @param {ApiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest} apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatch: async (workspaceId: string, trustedIpId: string, apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest: ApiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatch&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;trustedIpId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatch&#x27;, &#x27;trustedIpId&#x27;, trustedIpId)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatch&#x27;, &#x27;apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest&#x27;, apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/trusted-ips/{trustedIpId}&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)))
                .replace(&#x60;{${&quot;trustedIpId&quot;}}&#x60;, encodeURIComponent(String(trustedIpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdUsersGetIncludeGroupMembersEnum} [includeGroupMembers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdUsersGet: async (workspaceId: string, includeGroupMembers?: ApiV1WorkspaceWorkspaceIdUsersGetIncludeGroupMembersEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceIdUsersGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceId}/users&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (includeGroupMembers !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;includeGroupMembers&#x27;] &#x3D; includeGroupMembers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceSlug 
         * @param {ApiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest} apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPut: async (workspaceSlug: string, apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest: ApiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPut&#x27;, &#x27;workspaceSlug&#x27;, workspaceSlug)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPut&#x27;, &#x27;apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest&#x27;, apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceSlug}/audit-logs-retention&#x60;
                .replace(&#x60;{${&quot;workspaceSlug&quot;}}&#x60;, encodeURIComponent(String(workspaceSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PUT&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceSlug 
         * @param {ApiV1WorkspaceWorkspaceSlugVersionLimitPutRequest} apiV1WorkspaceWorkspaceSlugVersionLimitPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceSlugVersionLimitPut: async (workspaceSlug: string, apiV1WorkspaceWorkspaceSlugVersionLimitPutRequest: ApiV1WorkspaceWorkspaceSlugVersionLimitPutRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceSlugVersionLimitPut&#x27;, &#x27;workspaceSlug&#x27;, workspaceSlug)
            // verify required parameter &#x27;apiV1WorkspaceWorkspaceSlugVersionLimitPutRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV1WorkspaceWorkspaceSlugVersionLimitPut&#x27;, &#x27;apiV1WorkspaceWorkspaceSlugVersionLimitPutRequest&#x27;, apiV1WorkspaceWorkspaceSlugVersionLimitPutRequest)
            const localVarPath &#x3D; &#x60;/api/v1/workspace/{workspaceSlug}/version-limit&#x60;
                .replace(&#x60;{${&quot;workspaceSlug&quot;}}&#x60;, encodeURIComponent(String(workspaceSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PUT&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1WorkspaceWorkspaceSlugVersionLimitPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AuthMfaCheckTotpGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v2/auth/mfa/check/totp&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AuthMfaSendPost: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v2/auth/mfa/send&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV2AuthMfaVerifyPostRequest} apiV2AuthMfaVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AuthMfaVerifyPost: async (apiV2AuthMfaVerifyPostRequest: ApiV2AuthMfaVerifyPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV2AuthMfaVerifyPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2AuthMfaVerifyPost&#x27;, &#x27;apiV2AuthMfaVerifyPostRequest&#x27;, apiV2AuthMfaVerifyPostRequest)
            const localVarPath &#x3D; &#x60;/api/v2/auth/mfa/verify&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2AuthMfaVerifyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List privileges for the specified identity by project.
         * @param {string} identityId The ID of the identity to list.
         * @param {string} projectId The ID of the project that the identity is in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2IdentityProjectAdditionalPrivilegeGet: async (identityId: string, projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2IdentityProjectAdditionalPrivilegeGet&#x27;, &#x27;identityId&#x27;, identityId)
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2IdentityProjectAdditionalPrivilegeGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v2/identity-project-additional-privilege&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (identityId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;identityId&#x27;] &#x3D; identityId;
            }

            if (projectId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectId&#x27;] &#x3D; projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified identity privilege.
         * @param {string} id The ID of the identity privilege.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2IdentityProjectAdditionalPrivilegeIdDelete: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2IdentityProjectAdditionalPrivilegeIdDelete&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v2/identity-project-additional-privilege/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a specific privilege by id.
         * @param {string} id The ID of the identity privilege.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2IdentityProjectAdditionalPrivilegeIdGet: async (id: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2IdentityProjectAdditionalPrivilegeIdGet&#x27;, &#x27;id&#x27;, id)
            const localVarPath &#x3D; &#x60;/api/v2/identity-project-additional-privilege/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific identity privilege.
         * @param {string} id The ID of the identity privilege.
         * @param {ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequest} apiV2IdentityProjectAdditionalPrivilegeIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2IdentityProjectAdditionalPrivilegeIdPatch: async (id: string, apiV2IdentityProjectAdditionalPrivilegeIdPatchRequest: ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;id&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2IdentityProjectAdditionalPrivilegeIdPatch&#x27;, &#x27;id&#x27;, id)
            // verify required parameter &#x27;apiV2IdentityProjectAdditionalPrivilegeIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2IdentityProjectAdditionalPrivilegeIdPatch&#x27;, &#x27;apiV2IdentityProjectAdditionalPrivilegeIdPatchRequest&#x27;, apiV2IdentityProjectAdditionalPrivilegeIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v2/identity-project-additional-privilege/{id}&#x60;
                .replace(&#x60;{${&quot;id&quot;}}&#x60;, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2IdentityProjectAdditionalPrivilegeIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an additional privilege for identity.
         * @param {ApiV2IdentityProjectAdditionalPrivilegePostRequest} apiV2IdentityProjectAdditionalPrivilegePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2IdentityProjectAdditionalPrivilegePost: async (apiV2IdentityProjectAdditionalPrivilegePostRequest: ApiV2IdentityProjectAdditionalPrivilegePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV2IdentityProjectAdditionalPrivilegePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2IdentityProjectAdditionalPrivilegePost&#x27;, &#x27;apiV2IdentityProjectAdditionalPrivilegePostRequest&#x27;, apiV2IdentityProjectAdditionalPrivilegePostRequest)
            const localVarPath &#x3D; &#x60;/api/v2/identity-project-additional-privilege&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2IdentityProjectAdditionalPrivilegePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a specific privilege by slug.
         * @param {string} identityId The ID of the identity to list.
         * @param {string} projectSlug The slug of the project of the identity in.
         * @param {string} privilegeSlug The slug of the privilege.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2IdentityProjectAdditionalPrivilegeSlugPrivilegeSlugGet: async (identityId: string, projectSlug: string, privilegeSlug: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2IdentityProjectAdditionalPrivilegeSlugPrivilegeSlugGet&#x27;, &#x27;identityId&#x27;, identityId)
            // verify required parameter &#x27;projectSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2IdentityProjectAdditionalPrivilegeSlugPrivilegeSlugGet&#x27;, &#x27;projectSlug&#x27;, projectSlug)
            // verify required parameter &#x27;privilegeSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2IdentityProjectAdditionalPrivilegeSlugPrivilegeSlugGet&#x27;, &#x27;privilegeSlug&#x27;, privilegeSlug)
            const localVarPath &#x3D; &#x60;/api/v2/identity-project-additional-privilege/slug/{privilegeSlug}&#x60;
                .replace(&#x60;{${&quot;privilegeSlug&quot;}}&#x60;, encodeURIComponent(String(privilegeSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (identityId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;identityId&#x27;] &#x3D; identityId;
            }

            if (projectSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;projectSlug&#x27;] &#x3D; projectSlug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return organization identity memberships
         * @param {string} orgId The ID of the organization to get identity memberships from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th identity membership.
         * @param {number} [limit] The number of identity memberships to return.
         * @param {ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderByEnum} [orderBy] The column to order identity memberships by.
         * @param {ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderDirectionEnum} [orderDirection] The direction identity memberships will be sorted in.
         * @param {string} [search] The text string that identity membership names will be filtered by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrgIdIdentityMembershipsGet: async (orgId: string, offset?: number, limit?: number, orderBy?: ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderByEnum, orderDirection?: ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderDirectionEnum, search?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;orgId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2OrganizationsOrgIdIdentityMembershipsGet&#x27;, &#x27;orgId&#x27;, orgId)
            const localVarPath &#x3D; &#x60;/api/v2/organizations/{orgId}/identity-memberships&#x60;
                .replace(&#x60;{${&quot;orgId&quot;}}&#x60;, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (orderBy !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderBy&#x27;] &#x3D; orderBy;
            }

            if (orderDirection !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderDirection&#x27;] &#x3D; orderDirection;
            }

            if (search !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;search&#x27;] &#x3D; search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdDelete: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2OrganizationsOrganizationIdDelete&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v2/organizations/{organizationId}&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return organization user memberships
         * @param {string} organizationId The ID of the organization to get memberships from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdMembershipsGet: async (organizationId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2OrganizationsOrganizationIdMembershipsGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v2/organizations/{organizationId}/memberships&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization user memberships
         * @param {string} organizationId The ID of the organization to delete the membership from.
         * @param {string} membershipId The ID of the membership to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete: async (organizationId: string, membershipId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;membershipId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete&#x27;, &#x27;membershipId&#x27;, membershipId)
            const localVarPath &#x3D; &#x60;/api/v2/organizations/{organizationId}/memberships/{membershipId}&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)))
                .replace(&#x60;{${&quot;membershipId&quot;}}&#x60;, encodeURIComponent(String(membershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization user membership
         * @param {string} organizationId The ID of the organization to get the membership for.
         * @param {string} membershipId The ID of the membership to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdMembershipsMembershipIdGet: async (organizationId: string, membershipId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2OrganizationsOrganizationIdMembershipsMembershipIdGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;membershipId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2OrganizationsOrganizationIdMembershipsMembershipIdGet&#x27;, &#x27;membershipId&#x27;, membershipId)
            const localVarPath &#x3D; &#x60;/api/v2/organizations/{organizationId}/memberships/{membershipId}&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)))
                .replace(&#x60;{${&quot;membershipId&quot;}}&#x60;, encodeURIComponent(String(membershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update organization user memberships
         * @param {string} organizationId The ID of the organization to update the membership for.
         * @param {string} membershipId The ID of the membership to update.
         * @param {ApiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest} [apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatch: async (organizationId: string, membershipId: string, apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest?: ApiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatch&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;membershipId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatch&#x27;, &#x27;membershipId&#x27;, membershipId)
            const localVarPath &#x3D; &#x60;/api/v2/organizations/{organizationId}/memberships/{membershipId}&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)))
                .replace(&#x60;{${&quot;membershipId&quot;}}&#x60;, encodeURIComponent(String(membershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get project memberships given organization membership
         * @param {string} organizationId The ID of the organization to delete the membership from.
         * @param {string} membershipId The ID of the membership to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet: async (organizationId: string, membershipId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            // verify required parameter &#x27;membershipId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet&#x27;, &#x27;membershipId&#x27;, membershipId)
            const localVarPath &#x3D; &#x60;/api/v2/organizations/{organizationId}/memberships/{membershipId}/project-memberships&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)))
                .replace(&#x60;{${&quot;membershipId&quot;}}&#x60;, encodeURIComponent(String(membershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return projects in organization that user is apart of
         * @param {string} organizationId The ID of the organization to get projects from.
         * @param {ApiV2OrganizationsOrganizationIdWorkspacesGetTypeEnum} [type] The type of project to filter by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdWorkspacesGet: async (organizationId: string, type?: ApiV2OrganizationsOrganizationIdWorkspacesGetTypeEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;organizationId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2OrganizationsOrganizationIdWorkspacesGet&#x27;, &#x27;organizationId&#x27;, organizationId)
            const localVarPath &#x3D; &#x60;/api/v2/organizations/{organizationId}/workspaces&#x60;
                .replace(&#x60;{${&quot;organizationId&quot;}}&#x60;, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;type&#x27;] &#x3D; type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV2OrganizationsPostRequest} apiV2OrganizationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsPost: async (apiV2OrganizationsPostRequest: ApiV2OrganizationsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV2OrganizationsPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2OrganizationsPost&#x27;, &#x27;apiV2OrganizationsPostRequest&#x27;, apiV2OrganizationsPostRequest)
            const localVarPath &#x3D; &#x60;/api/v2/organizations&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2OrganizationsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsPrivilegeSystemUpgradePost: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v2/organizations/privilege-system-upgrade&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV2PasswordPasswordResetPostRequest} apiV2PasswordPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2PasswordPasswordResetPost: async (apiV2PasswordPasswordResetPostRequest: ApiV2PasswordPasswordResetPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV2PasswordPasswordResetPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2PasswordPasswordResetPost&#x27;, &#x27;apiV2PasswordPasswordResetPostRequest&#x27;, apiV2PasswordPasswordResetPostRequest)
            const localVarPath &#x3D; &#x60;/api/v2/password/password-reset&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2PasswordPasswordResetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV2PasswordUserPasswordResetPostRequest} apiV2PasswordUserPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2PasswordUserPasswordResetPost: async (apiV2PasswordUserPasswordResetPostRequest: ApiV2PasswordUserPasswordResetPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV2PasswordUserPasswordResetPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2PasswordUserPasswordResetPost&#x27;, &#x27;apiV2PasswordUserPasswordResetPostRequest&#x27;, apiV2PasswordUserPasswordResetPostRequest)
            const localVarPath &#x3D; &#x60;/api/v2/password/user/password-reset&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2PasswordUserPasswordResetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return Infisical Token data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ServiceTokenGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v2/service-token&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV2ServiceTokenPostRequest} apiV2ServiceTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ServiceTokenPost: async (apiV2ServiceTokenPostRequest: ApiV2ServiceTokenPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV2ServiceTokenPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2ServiceTokenPost&#x27;, &#x27;apiV2ServiceTokenPostRequest&#x27;, apiV2ServiceTokenPostRequest)
            const localVarPath &#x3D; &#x60;/api/v2/service-token&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2ServiceTokenPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serviceTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ServiceTokenServiceTokenIdDelete: async (serviceTokenId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;serviceTokenId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2ServiceTokenServiceTokenIdDelete&#x27;, &#x27;serviceTokenId&#x27;, serviceTokenId)
            const localVarPath &#x3D; &#x60;/api/v2/service-token/{serviceTokenId}&#x60;
                .replace(&#x60;{${&quot;serviceTokenId&quot;}}&#x60;, encodeURIComponent(String(serviceTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} apiKeyDataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeApiKeysApiKeyDataIdDelete: async (apiKeyDataId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiKeyDataId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2UsersMeApiKeysApiKeyDataIdDelete&#x27;, &#x27;apiKeyDataId&#x27;, apiKeyDataId)
            const localVarPath &#x3D; &#x60;/api/v2/users/me/api-keys/{apiKeyDataId}&#x60;
                .replace(&#x60;{${&quot;apiKeyDataId&quot;}}&#x60;, encodeURIComponent(String(apiKeyDataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeApiKeysGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v2/users/me/api-keys&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV2UsersMeApiKeysPostRequest} apiV2UsersMeApiKeysPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeApiKeysPost: async (apiV2UsersMeApiKeysPostRequest: ApiV2UsersMeApiKeysPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV2UsersMeApiKeysPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2UsersMeApiKeysPost&#x27;, &#x27;apiV2UsersMeApiKeysPostRequest&#x27;, apiV2UsersMeApiKeysPostRequest)
            const localVarPath &#x3D; &#x60;/api/v2/users/me/api-keys&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2UsersMeApiKeysPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV2UsersMeAuthMethodsPutRequest} apiV2UsersMeAuthMethodsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeAuthMethodsPut: async (apiV2UsersMeAuthMethodsPutRequest: ApiV2UsersMeAuthMethodsPutRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV2UsersMeAuthMethodsPutRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2UsersMeAuthMethodsPut&#x27;, &#x27;apiV2UsersMeAuthMethodsPutRequest&#x27;, apiV2UsersMeAuthMethodsPutRequest)
            const localVarPath &#x3D; &#x60;/api/v2/users/me/auth-methods&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PUT&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2UsersMeAuthMethodsPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeDelete: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v2/users/me&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV2UsersMeEmailsCodePostRequest} apiV2UsersMeEmailsCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeEmailsCodePost: async (apiV2UsersMeEmailsCodePostRequest: ApiV2UsersMeEmailsCodePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV2UsersMeEmailsCodePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2UsersMeEmailsCodePost&#x27;, &#x27;apiV2UsersMeEmailsCodePostRequest&#x27;, apiV2UsersMeEmailsCodePostRequest)
            const localVarPath &#x3D; &#x60;/api/v2/users/me/emails/code&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2UsersMeEmailsCodePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV2UsersMeEmailsVerifyPostRequest} apiV2UsersMeEmailsVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeEmailsVerifyPost: async (apiV2UsersMeEmailsVerifyPostRequest: ApiV2UsersMeEmailsVerifyPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV2UsersMeEmailsVerifyPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2UsersMeEmailsVerifyPost&#x27;, &#x27;apiV2UsersMeEmailsVerifyPostRequest&#x27;, apiV2UsersMeEmailsVerifyPostRequest)
            const localVarPath &#x3D; &#x60;/api/v2/users/me/emails/verify&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2UsersMeEmailsVerifyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current user on the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v2/users/me&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV2UsersMeMfaPatchRequest} [apiV2UsersMeMfaPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeMfaPatch: async (apiV2UsersMeMfaPatchRequest?: ApiV2UsersMeMfaPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v2/users/me/mfa&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2UsersMeMfaPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV2UsersMeNamePatchRequest} apiV2UsersMeNamePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeNamePatch: async (apiV2UsersMeNamePatchRequest: ApiV2UsersMeNamePatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV2UsersMeNamePatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2UsersMeNamePatch&#x27;, &#x27;apiV2UsersMeNamePatchRequest&#x27;, apiV2UsersMeNamePatchRequest)
            const localVarPath &#x3D; &#x60;/api/v2/users/me/name&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2UsersMeNamePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return organizations that current user is part of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeOrganizationsGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v2/users/me/organizations&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeSessionsDelete: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v2/users/me/sessions&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeSessionsGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v2/users/me/sessions&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new project
         * @param {ApiV2WorkspacePostRequest} apiV2WorkspacePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspacePost: async (apiV2WorkspacePostRequest: ApiV2WorkspacePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV2WorkspacePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspacePost&#x27;, &#x27;apiV2WorkspacePostRequest&#x27;, apiV2WorkspacePostRequest)
            const localVarPath &#x3D; &#x60;/api/v2/workspace&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2WorkspacePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdCertificateTemplatesGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdCertificateTemplatesGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/certificate-templates&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return list of groups in project
         * @param {string} projectId The ID of the project to list groups for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdGroupsGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdGroupsGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/groups&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove group from project
         * @param {string} projectId The ID of the project to delete the group from.
         * @param {string} groupId The ID of the group to delete from the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdGroupsGroupIdDelete: async (projectId: string, groupId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdGroupsGroupIdDelete&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;groupId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdGroupsGroupIdDelete&#x27;, &#x27;groupId&#x27;, groupId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/groups/{groupId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;groupId&quot;}}&#x60;, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return project group
         * @param {string} projectId 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdGroupsGroupIdGet: async (projectId: string, groupId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdGroupsGroupIdGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;groupId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdGroupsGroupIdGet&#x27;, &#x27;groupId&#x27;, groupId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/groups/{groupId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;groupId&quot;}}&#x60;, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add group to project
         * @param {string} projectId The ID of the project to add the group to.
         * @param {string} groupIdOrName The ID or name of the group to add to the project.
         * @param {ApiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest} [apiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdGroupsGroupIdOrNamePost: async (projectId: string, groupIdOrName: string, apiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest?: ApiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdGroupsGroupIdOrNamePost&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;groupIdOrName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdGroupsGroupIdOrNamePost&#x27;, &#x27;groupIdOrName&#x27;, groupIdOrName)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/groups/{groupIdOrName}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;groupIdOrName&quot;}}&#x60;, encodeURIComponent(String(groupIdOrName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update group in project
         * @param {string} projectId The ID of the project to update the group in.
         * @param {string} groupId The ID of the group to update in the project.
         * @param {ApiV2WorkspaceProjectIdGroupsGroupIdPatchRequest} apiV2WorkspaceProjectIdGroupsGroupIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdGroupsGroupIdPatch: async (projectId: string, groupId: string, apiV2WorkspaceProjectIdGroupsGroupIdPatchRequest: ApiV2WorkspaceProjectIdGroupsGroupIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdGroupsGroupIdPatch&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;groupId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdGroupsGroupIdPatch&#x27;, &#x27;groupId&#x27;, groupId)
            // verify required parameter &#x27;apiV2WorkspaceProjectIdGroupsGroupIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdGroupsGroupIdPatch&#x27;, &#x27;apiV2WorkspaceProjectIdGroupsGroupIdPatchRequest&#x27;, apiV2WorkspaceProjectIdGroupsGroupIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/groups/{groupId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;groupId&quot;}}&#x60;, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2WorkspaceProjectIdGroupsGroupIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return project identity memberships
         * @param {string} projectId The ID of the project to get identity memberships from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th identity membership.
         * @param {number} [limit] The number of identity memberships to return.
         * @param {ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderByEnum} [orderBy] The column to order identity memberships by.
         * @param {ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderDirectionEnum} [orderDirection] The direction identity memberships will be sorted in.
         * @param {string} [search] The text string that identity membership names will be filtered by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdIdentityMembershipsGet: async (projectId: string, offset?: number, limit?: number, orderBy?: ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderByEnum, orderDirection?: ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderDirectionEnum, search?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdIdentityMembershipsGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/identity-memberships&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }

            if (orderBy !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderBy&#x27;] &#x3D; orderBy;
            }

            if (orderDirection !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;orderDirection&#x27;] &#x3D; orderDirection;
            }

            if (search !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;search&#x27;] &#x3D; search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete project identity memberships
         * @param {string} projectId The ID of the project to delete the identity membership from.
         * @param {string} identityId The ID of the identity to delete the membership from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdDelete: async (projectId: string, identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdDelete&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdDelete&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/identity-memberships/{identityId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return project identity membership
         * @param {string} projectId The ID of the project to get the identity membership for.
         * @param {string} identityId The ID of the identity to get the membership for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet: async (projectId: string, identityId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/identity-memberships/{identityId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update project identity memberships
         * @param {string} projectId The ID of the project to update the identity membership for.
         * @param {string} identityId The ID of the identity to update the membership for.
         * @param {ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest} apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatch: async (projectId: string, identityId: string, apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest: ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatch&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatch&#x27;, &#x27;identityId&#x27;, identityId)
            // verify required parameter &#x27;apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatch&#x27;, &#x27;apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest&#x27;, apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/identity-memberships/{identityId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create project identity membership
         * @param {string} projectId 
         * @param {string} identityId 
         * @param {ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest} [apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost: async (projectId: string, identityId: string, apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest?: ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;identityId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost&#x27;, &#x27;identityId&#x27;, identityId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/identity-memberships/{identityId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;identityId&quot;}}&#x60;, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove members from project
         * @param {string} projectId The ID of the project to remove the member from.
         * @param {ApiV2WorkspaceProjectIdMembershipsDeleteRequest} [apiV2WorkspaceProjectIdMembershipsDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdMembershipsDelete: async (projectId: string, apiV2WorkspaceProjectIdMembershipsDeleteRequest?: ApiV2WorkspaceProjectIdMembershipsDeleteRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdMembershipsDelete&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/memberships&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2WorkspaceProjectIdMembershipsDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite members to project
         * @param {string} projectId The ID of the project to invite the member to.
         * @param {ApiV2WorkspaceProjectIdMembershipsPostRequest} [apiV2WorkspaceProjectIdMembershipsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdMembershipsPost: async (projectId: string, apiV2WorkspaceProjectIdMembershipsPostRequest?: ApiV2WorkspaceProjectIdMembershipsPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdMembershipsPost&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/memberships&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2WorkspaceProjectIdMembershipsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdPkiAlertsGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdPkiAlertsGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/pki-alerts&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdPkiCollectionsGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdPkiCollectionsGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/pki-collections&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List project role
         * @param {string} projectId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdRolesGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdRolesGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/roles&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a project role
         * @param {string} projectId Id of the project to create the role for.
         * @param {ApiV2WorkspaceProjectIdRolesPostRequest} apiV2WorkspaceProjectIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdRolesPost: async (projectId: string, apiV2WorkspaceProjectIdRolesPostRequest: ApiV2WorkspaceProjectIdRolesPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdRolesPost&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;apiV2WorkspaceProjectIdRolesPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdRolesPost&#x27;, &#x27;apiV2WorkspaceProjectIdRolesPostRequest&#x27;, apiV2WorkspaceProjectIdRolesPostRequest)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/roles&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2WorkspaceProjectIdRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a project role
         * @param {string} projectId The ID of the project to delete the role for.
         * @param {string} roleId The ID of the role to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdRolesRoleIdDelete: async (projectId: string, roleId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdRolesRoleIdDelete&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;roleId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdRolesRoleIdDelete&#x27;, &#x27;roleId&#x27;, roleId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/roles/{roleId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;roleId&quot;}}&#x60;, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a project role
         * @param {string} projectId The ID of the project to update the role for.
         * @param {string} roleId The ID of the role to update
         * @param {ApiV2WorkspaceProjectIdRolesRoleIdPatchRequest} [apiV2WorkspaceProjectIdRolesRoleIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdRolesRoleIdPatch: async (projectId: string, roleId: string, apiV2WorkspaceProjectIdRolesRoleIdPatchRequest?: ApiV2WorkspaceProjectIdRolesRoleIdPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdRolesRoleIdPatch&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;roleId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdRolesRoleIdPatch&#x27;, &#x27;roleId&#x27;, roleId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/roles/{roleId}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;roleId&quot;}}&#x60;, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2WorkspaceProjectIdRolesRoleIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId The ID of the project.
         * @param {string} roleSlug The slug of the role to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdRolesSlugRoleSlugGet: async (projectId: string, roleSlug: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdRolesSlugRoleSlugGet&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;roleSlug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdRolesSlugRoleSlugGet&#x27;, &#x27;roleSlug&#x27;, roleSlug)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/roles/slug/{roleSlug}&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)))
                .replace(&#x60;{${&quot;roleSlug&quot;}}&#x60;, encodeURIComponent(String(roleSlug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId The ID of the project to list SSH CAs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdSshCasGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdSshCasGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/ssh-cas&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId The ID of the project to list SSH certificate templates for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdSshCertificateTemplatesGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdSshCertificateTemplatesGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/ssh-certificate-templates&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId The ID of the project to list SSH CAs for.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th SSH certificate.
         * @param {number} [limit] The number of SSH certificates to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdSshCertificatesGet: async (projectId: string, offset?: number, limit?: number, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdSshCertificatesGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/ssh-certificates&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {ApiV2WorkspaceProjectIdUpgradePostRequest} apiV2WorkspaceProjectIdUpgradePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdUpgradePost: async (projectId: string, apiV2WorkspaceProjectIdUpgradePostRequest: ApiV2WorkspaceProjectIdUpgradePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdUpgradePost&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;apiV2WorkspaceProjectIdUpgradePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdUpgradePost&#x27;, &#x27;apiV2WorkspaceProjectIdUpgradePostRequest&#x27;, apiV2WorkspaceProjectIdUpgradePostRequest)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/upgrade&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2WorkspaceProjectIdUpgradePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdUpgradeStatusGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceProjectIdUpgradeStatusGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{projectId}/upgrade/status&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} slug The slug of the project to list CAs for.
         * @param {ApiV2WorkspaceSlugCasGetStatusEnum} [status] The status of the CA to filter by.
         * @param {string} [friendlyName] The friendly name of the CA to filter by.
         * @param {string} [commonName] The common name of the CA to filter by.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th CA.
         * @param {number} [limit] The number of CAs to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceSlugCasGet: async (slug: string, status?: ApiV2WorkspaceSlugCasGetStatusEnum, friendlyName?: string, commonName?: string, offset?: number, limit?: number, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;slug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceSlugCasGet&#x27;, &#x27;slug&#x27;, slug)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{slug}/cas&#x60;
                .replace(&#x60;{${&quot;slug&quot;}}&#x60;, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (status !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;status&#x27;] &#x3D; status;
            }

            if (friendlyName !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;friendlyName&#x27;] &#x3D; friendlyName;
            }

            if (commonName !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;commonName&#x27;] &#x3D; commonName;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} slug The slug of the project to list certificates for.
         * @param {string} [friendlyName] The friendly name of the certificate to filter by.
         * @param {string} [commonName] The common name of the certificate to filter by.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th certificate.
         * @param {number} [limit] The number of certificates to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceSlugCertificatesGet: async (slug: string, friendlyName?: string, commonName?: string, offset?: number, limit?: number, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;slug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceSlugCertificatesGet&#x27;, &#x27;slug&#x27;, slug)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{slug}/certificates&#x60;
                .replace(&#x60;{${&quot;slug&quot;}}&#x60;, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (friendlyName !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;friendlyName&#x27;] &#x3D; friendlyName;
            }

            if (commonName !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;commonName&#x27;] &#x3D; commonName;
            }

            if (offset !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;offset&#x27;] &#x3D; offset;
            }

            if (limit !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;limit&#x27;] &#x3D; limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete project
         * @param {string} slug The slug of the project to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceSlugDelete: async (slug: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;slug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceSlugDelete&#x27;, &#x27;slug&#x27;, slug)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{slug}&#x60;
                .replace(&#x60;{${&quot;slug&quot;}}&#x60;, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} slug The slug of the project to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceSlugGet: async (slug: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;slug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceSlugGet&#x27;, &#x27;slug&#x27;, slug)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{slug}&#x60;
                .replace(&#x60;{${&quot;slug&quot;}}&#x60;, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} slug The slug of the project to update.
         * @param {ApiV2WorkspaceSlugPatchRequest} [apiV2WorkspaceSlugPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceSlugPatch: async (slug: string, apiV2WorkspaceSlugPatchRequest?: ApiV2WorkspaceSlugPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;slug&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceSlugPatch&#x27;, &#x27;slug&#x27;, slug)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{slug}&#x60;
                .replace(&#x60;{${&quot;slug&quot;}}&#x60;, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV2WorkspaceSlugPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return encrypted project key
         * @param {string} workspaceId The ID of the project to get the key from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceWorkspaceIdEncryptedKeyGet: async (workspaceId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV2WorkspaceWorkspaceIdEncryptedKeyGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            const localVarPath &#x3D; &#x60;/api/v2/workspace/{workspaceId}/encrypted-key&#x60;
                .replace(&#x60;{${&quot;workspaceId&quot;}}&#x60;, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV3AuthLogin1PostRequest} apiV3AuthLogin1PostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3AuthLogin1Post: async (apiV3AuthLogin1PostRequest: ApiV3AuthLogin1PostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV3AuthLogin1PostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3AuthLogin1Post&#x27;, &#x27;apiV3AuthLogin1PostRequest&#x27;, apiV3AuthLogin1PostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/auth/login1&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3AuthLogin1PostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV3AuthLogin2PostRequest} apiV3AuthLogin2PostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3AuthLogin2Post: async (apiV3AuthLogin2PostRequest: ApiV3AuthLogin2PostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV3AuthLogin2PostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3AuthLogin2Post&#x27;, &#x27;apiV3AuthLogin2PostRequest&#x27;, apiV3AuthLogin2PostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/auth/login2&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3AuthLogin2PostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV3AuthSelectOrganizationPostRequest} apiV3AuthSelectOrganizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3AuthSelectOrganizationPost: async (apiV3AuthSelectOrganizationPostRequest: ApiV3AuthSelectOrganizationPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV3AuthSelectOrganizationPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3AuthSelectOrganizationPost&#x27;, &#x27;apiV3AuthSelectOrganizationPostRequest&#x27;, apiV3AuthSelectOrganizationPostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/auth/select-organization&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3AuthSelectOrganizationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3MigrateEnvKeyPost: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v3/migrate/env-key&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Backfill secret references
         * @param {ApiV3SecretsBackfillSecretReferencesPostRequest} apiV3SecretsBackfillSecretReferencesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBackfillSecretReferencesPost: async (apiV3SecretsBackfillSecretReferencesPostRequest: ApiV3SecretsBackfillSecretReferencesPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV3SecretsBackfillSecretReferencesPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsBackfillSecretReferencesPost&#x27;, &#x27;apiV3SecretsBackfillSecretReferencesPostRequest&#x27;, apiV3SecretsBackfillSecretReferencesPostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/backfill-secret-references&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsBackfillSecretReferencesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV3SecretsBatchDeleteRequest} apiV3SecretsBatchDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBatchDelete: async (apiV3SecretsBatchDeleteRequest: ApiV3SecretsBatchDeleteRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV3SecretsBatchDeleteRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsBatchDelete&#x27;, &#x27;apiV3SecretsBatchDeleteRequest&#x27;, apiV3SecretsBatchDeleteRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/batch&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsBatchDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV3SecretsBatchPatchRequest} apiV3SecretsBatchPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBatchPatch: async (apiV3SecretsBatchPatchRequest: ApiV3SecretsBatchPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV3SecretsBatchPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsBatchPatch&#x27;, &#x27;apiV3SecretsBatchPatchRequest&#x27;, apiV3SecretsBatchPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/batch&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsBatchPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV3SecretsBatchPostRequest} apiV3SecretsBatchPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBatchPost: async (apiV3SecretsBatchPostRequest: ApiV3SecretsBatchPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV3SecretsBatchPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsBatchPost&#x27;, &#x27;apiV3SecretsBatchPostRequest&#x27;, apiV3SecretsBatchPostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/batch&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsBatchPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete many secrets
         * @param {ApiV3SecretsBatchRawDeleteRequest} apiV3SecretsBatchRawDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBatchRawDelete: async (apiV3SecretsBatchRawDeleteRequest: ApiV3SecretsBatchRawDeleteRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV3SecretsBatchRawDeleteRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsBatchRawDelete&#x27;, &#x27;apiV3SecretsBatchRawDeleteRequest&#x27;, apiV3SecretsBatchRawDeleteRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/batch/raw&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsBatchRawDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update many secrets
         * @param {ApiV3SecretsBatchRawPatchRequest} apiV3SecretsBatchRawPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBatchRawPatch: async (apiV3SecretsBatchRawPatchRequest: ApiV3SecretsBatchRawPatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV3SecretsBatchRawPatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsBatchRawPatch&#x27;, &#x27;apiV3SecretsBatchRawPatchRequest&#x27;, apiV3SecretsBatchRawPatchRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/batch/raw&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsBatchRawPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create many secrets
         * @param {ApiV3SecretsBatchRawPostRequest} apiV3SecretsBatchRawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBatchRawPost: async (apiV3SecretsBatchRawPostRequest: ApiV3SecretsBatchRawPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV3SecretsBatchRawPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsBatchRawPost&#x27;, &#x27;apiV3SecretsBatchRawPostRequest&#x27;, apiV3SecretsBatchRawPostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/batch/raw&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsBatchRawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} [secretPath] 
         * @param {ApiV3SecretsGetRecursiveEnum} [recursive] 
         * @param {ApiV3SecretsGetIncludeImportsEnum} [includeImports] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsGet: async (workspaceId: string, environment: string, secretPath?: string, recursive?: ApiV3SecretsGetRecursiveEnum, includeImports?: ApiV3SecretsGetIncludeImportsEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsGet&#x27;, &#x27;environment&#x27;, environment)
            const localVarPath &#x3D; &#x60;/api/v3/secrets&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }

            if (recursive !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;recursive&#x27;] &#x3D; recursive;
            }

            if (includeImports !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;include_imports&#x27;] &#x3D; includeImports;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV3SecretsMovePostRequest} apiV3SecretsMovePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsMovePost: async (apiV3SecretsMovePostRequest: ApiV3SecretsMovePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV3SecretsMovePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsMovePost&#x27;, &#x27;apiV3SecretsMovePostRequest&#x27;, apiV3SecretsMovePostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/move&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsMovePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List secrets
         * @param {string} [metadataFilter] The secret metadata key-value pairs to filter secrets by. When querying for multiple metadata pairs, the query is treated as an AND operation. Secret metadata format is key&amp;#x3D;value1,value&amp;#x3D;value2|key&amp;#x3D;value3,value&amp;#x3D;value4.
         * @param {string} [workspaceId] The ID of the project to list secrets from.
         * @param {string} [workspaceSlug] The slug of the project to list secrets from. This parameter is only applicable by machine identities.
         * @param {string} [environment] The slug of the environment to list secrets from.
         * @param {string} [secretPath] The secret path to list secrets from.
         * @param {ApiV3SecretsRawGetViewSecretValueEnum} [viewSecretValue] Whether or not to retrieve the secret value.
         * @param {ApiV3SecretsRawGetExpandSecretReferencesEnum} [expandSecretReferences] Whether or not to expand secret references.
         * @param {ApiV3SecretsRawGetRecursiveEnum} [recursive] Whether or not to fetch all secrets from the specified base path, and all of its subdirectories. Note, the max depth is 20 deep.
         * @param {ApiV3SecretsRawGetIncludeImportsEnum} [includeImports] Weather to include imported secrets or not.
         * @param {string} [tagSlugs] The comma separated tag slugs to filter secrets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawGet: async (metadataFilter?: string, workspaceId?: string, workspaceSlug?: string, environment?: string, secretPath?: string, viewSecretValue?: ApiV3SecretsRawGetViewSecretValueEnum, expandSecretReferences?: ApiV3SecretsRawGetExpandSecretReferencesEnum, recursive?: ApiV3SecretsRawGetRecursiveEnum, includeImports?: ApiV3SecretsRawGetIncludeImportsEnum, tagSlugs?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v3/secrets/raw&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (metadataFilter !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;metadataFilter&#x27;] &#x3D; metadataFilter;
            }

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }

            if (workspaceSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceSlug&#x27;] &#x3D; workspaceSlug;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }

            if (viewSecretValue !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;viewSecretValue&#x27;] &#x3D; viewSecretValue;
            }

            if (expandSecretReferences !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;expandSecretReferences&#x27;] &#x3D; expandSecretReferences;
            }

            if (recursive !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;recursive&#x27;] &#x3D; recursive;
            }

            if (includeImports !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;include_imports&#x27;] &#x3D; includeImports;
            }

            if (tagSlugs !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;tagSlugs&#x27;] &#x3D; tagSlugs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} secretId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawIdSecretIdGet: async (secretId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsRawIdSecretIdGet&#x27;, &#x27;secretId&#x27;, secretId)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/raw/id/{secretId}&#x60;
                .replace(&#x60;{${&quot;secretId&quot;}}&#x60;, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete secret
         * @param {string} secretName The name of the secret to delete.
         * @param {ApiV3SecretsRawSecretNameDeleteRequest} apiV3SecretsRawSecretNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawSecretNameDelete: async (secretName: string, apiV3SecretsRawSecretNameDeleteRequest: ApiV3SecretsRawSecretNameDeleteRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsRawSecretNameDelete&#x27;, &#x27;secretName&#x27;, secretName)
            // verify required parameter &#x27;apiV3SecretsRawSecretNameDeleteRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsRawSecretNameDelete&#x27;, &#x27;apiV3SecretsRawSecretNameDeleteRequest&#x27;, apiV3SecretsRawSecretNameDeleteRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/raw/{secretName}&#x60;
                .replace(&#x60;{${&quot;secretName&quot;}}&#x60;, encodeURIComponent(String(secretName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsRawSecretNameDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a secret by name
         * @param {string} secretName The name of the secret to get.
         * @param {string} [workspaceId] The ID of the project to get the secret from.
         * @param {string} [workspaceSlug] The slug of the project to get the secret from.
         * @param {string} [environment] The slug of the environment to get the secret from.
         * @param {string} [secretPath] The path of the secret to get.
         * @param {number} [version] The version of the secret to get.
         * @param {ApiV3SecretsRawSecretNameGetTypeEnum} [type] The type of the secret to get.
         * @param {ApiV3SecretsRawSecretNameGetViewSecretValueEnum} [viewSecretValue] Whether or not to retrieve the secret value.
         * @param {ApiV3SecretsRawSecretNameGetExpandSecretReferencesEnum} [expandSecretReferences] Whether or not to expand secret references.
         * @param {ApiV3SecretsRawSecretNameGetIncludeImportsEnum} [includeImports] Weather to include imported secrets or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawSecretNameGet: async (secretName: string, workspaceId?: string, workspaceSlug?: string, environment?: string, secretPath?: string, version?: number, type?: ApiV3SecretsRawSecretNameGetTypeEnum, viewSecretValue?: ApiV3SecretsRawSecretNameGetViewSecretValueEnum, expandSecretReferences?: ApiV3SecretsRawSecretNameGetExpandSecretReferencesEnum, includeImports?: ApiV3SecretsRawSecretNameGetIncludeImportsEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsRawSecretNameGet&#x27;, &#x27;secretName&#x27;, secretName)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/raw/{secretName}&#x60;
                .replace(&#x60;{${&quot;secretName&quot;}}&#x60;, encodeURIComponent(String(secretName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }

            if (workspaceSlug !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceSlug&#x27;] &#x3D; workspaceSlug;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }

            if (version !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;version&#x27;] &#x3D; version;
            }

            if (type !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;type&#x27;] &#x3D; type;
            }

            if (viewSecretValue !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;viewSecretValue&#x27;] &#x3D; viewSecretValue;
            }

            if (expandSecretReferences !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;expandSecretReferences&#x27;] &#x3D; expandSecretReferences;
            }

            if (includeImports !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;include_imports&#x27;] &#x3D; includeImports;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update secret
         * @param {string} secretName The name of the secret to update.
         * @param {ApiV3SecretsRawSecretNamePatchRequest} apiV3SecretsRawSecretNamePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawSecretNamePatch: async (secretName: string, apiV3SecretsRawSecretNamePatchRequest: ApiV3SecretsRawSecretNamePatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsRawSecretNamePatch&#x27;, &#x27;secretName&#x27;, secretName)
            // verify required parameter &#x27;apiV3SecretsRawSecretNamePatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsRawSecretNamePatch&#x27;, &#x27;apiV3SecretsRawSecretNamePatchRequest&#x27;, apiV3SecretsRawSecretNamePatchRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/raw/{secretName}&#x60;
                .replace(&#x60;{${&quot;secretName&quot;}}&#x60;, encodeURIComponent(String(secretName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsRawSecretNamePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create secret
         * @param {string} secretName The name of the secret to create.
         * @param {ApiV3SecretsRawSecretNamePostRequest} apiV3SecretsRawSecretNamePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawSecretNamePost: async (secretName: string, apiV3SecretsRawSecretNamePostRequest: ApiV3SecretsRawSecretNamePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsRawSecretNamePost&#x27;, &#x27;secretName&#x27;, secretName)
            // verify required parameter &#x27;apiV3SecretsRawSecretNamePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsRawSecretNamePost&#x27;, &#x27;apiV3SecretsRawSecretNamePostRequest&#x27;, apiV3SecretsRawSecretNamePostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/raw/{secretName}&#x60;
                .replace(&#x60;{${&quot;secretName&quot;}}&#x60;, encodeURIComponent(String(secretName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsRawSecretNamePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get secret reference tree
         * @param {string} workspaceId The ID of the project where the secret is located.
         * @param {string} environment The slug of the environment where the the secret is located.
         * @param {string} secretName The name of the secret to get the reference tree for.
         * @param {string} [secretPath] The folder path where the secret is located.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawSecretNameSecretReferenceTreeGet: async (workspaceId: string, environment: string, secretName: string, secretPath?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsRawSecretNameSecretReferenceTreeGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsRawSecretNameSecretReferenceTreeGet&#x27;, &#x27;environment&#x27;, environment)
            // verify required parameter &#x27;secretName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsRawSecretNameSecretReferenceTreeGet&#x27;, &#x27;secretName&#x27;, secretName)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/raw/{secretName}/secret-reference-tree&#x60;
                .replace(&#x60;{${&quot;secretName&quot;}}&#x60;, encodeURIComponent(String(secretName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} secretName 
         * @param {ApiV3SecretsSecretNameDeleteRequest} apiV3SecretsSecretNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsSecretNameDelete: async (secretName: string, apiV3SecretsSecretNameDeleteRequest: ApiV3SecretsSecretNameDeleteRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsSecretNameDelete&#x27;, &#x27;secretName&#x27;, secretName)
            // verify required parameter &#x27;apiV3SecretsSecretNameDeleteRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsSecretNameDelete&#x27;, &#x27;apiV3SecretsSecretNameDeleteRequest&#x27;, apiV3SecretsSecretNameDeleteRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/{secretName}&#x60;
                .replace(&#x60;{${&quot;secretName&quot;}}&#x60;, encodeURIComponent(String(secretName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsSecretNameDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} secretName 
         * @param {string} [secretPath] 
         * @param {ApiV3SecretsSecretNameGetTypeEnum} [type] 
         * @param {number} [version] 
         * @param {ApiV3SecretsSecretNameGetIncludeImportsEnum} [includeImports] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsSecretNameGet: async (workspaceId: string, environment: string, secretName: string, secretPath?: string, type?: ApiV3SecretsSecretNameGetTypeEnum, version?: number, includeImports?: ApiV3SecretsSecretNameGetIncludeImportsEnum, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;workspaceId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsSecretNameGet&#x27;, &#x27;workspaceId&#x27;, workspaceId)
            // verify required parameter &#x27;environment&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsSecretNameGet&#x27;, &#x27;environment&#x27;, environment)
            // verify required parameter &#x27;secretName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsSecretNameGet&#x27;, &#x27;secretName&#x27;, secretName)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/{secretName}&#x60;
                .replace(&#x60;{${&quot;secretName&quot;}}&#x60;, encodeURIComponent(String(secretName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            if (workspaceId !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;workspaceId&#x27;] &#x3D; workspaceId;
            }

            if (environment !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;environment&#x27;] &#x3D; environment;
            }

            if (secretPath !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;secretPath&#x27;] &#x3D; secretPath;
            }

            if (type !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;type&#x27;] &#x3D; type;
            }

            if (version !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;version&#x27;] &#x3D; version;
            }

            if (includeImports !&#x3D;&#x3D; undefined) {
                localVarQueryParameter[&#x27;include_imports&#x27;] &#x3D; includeImports;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} secretName 
         * @param {ApiV3SecretsSecretNamePatchRequest} apiV3SecretsSecretNamePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsSecretNamePatch: async (secretName: string, apiV3SecretsSecretNamePatchRequest: ApiV3SecretsSecretNamePatchRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsSecretNamePatch&#x27;, &#x27;secretName&#x27;, secretName)
            // verify required parameter &#x27;apiV3SecretsSecretNamePatchRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsSecretNamePatch&#x27;, &#x27;apiV3SecretsSecretNamePatchRequest&#x27;, apiV3SecretsSecretNamePatchRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/{secretName}&#x60;
                .replace(&#x60;{${&quot;secretName&quot;}}&#x60;, encodeURIComponent(String(secretName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;PATCH&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsSecretNamePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} secretName 
         * @param {ApiV3SecretsSecretNamePostRequest} apiV3SecretsSecretNamePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsSecretNamePost: async (secretName: string, apiV3SecretsSecretNamePostRequest: ApiV3SecretsSecretNamePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsSecretNamePost&#x27;, &#x27;secretName&#x27;, secretName)
            // verify required parameter &#x27;apiV3SecretsSecretNamePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsSecretNamePost&#x27;, &#x27;apiV3SecretsSecretNamePostRequest&#x27;, apiV3SecretsSecretNamePostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/{secretName}&#x60;
                .replace(&#x60;{${&quot;secretName&quot;}}&#x60;, encodeURIComponent(String(secretName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsSecretNamePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detach tags from a secret
         * @param {string} secretName The name of the secret to detach tags from.
         * @param {ApiV3SecretsTagsSecretNameDeleteRequest} apiV3SecretsTagsSecretNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsTagsSecretNameDelete: async (secretName: string, apiV3SecretsTagsSecretNameDeleteRequest: ApiV3SecretsTagsSecretNameDeleteRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsTagsSecretNameDelete&#x27;, &#x27;secretName&#x27;, secretName)
            // verify required parameter &#x27;apiV3SecretsTagsSecretNameDeleteRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsTagsSecretNameDelete&#x27;, &#x27;apiV3SecretsTagsSecretNameDeleteRequest&#x27;, apiV3SecretsTagsSecretNameDeleteRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/tags/{secretName}&#x60;
                .replace(&#x60;{${&quot;secretName&quot;}}&#x60;, encodeURIComponent(String(secretName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;DELETE&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsTagsSecretNameDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach tags to a secret
         * @param {string} secretName The name of the secret to attach tags to.
         * @param {ApiV3SecretsTagsSecretNamePostRequest} apiV3SecretsTagsSecretNamePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsTagsSecretNamePost: async (secretName: string, apiV3SecretsTagsSecretNamePostRequest: ApiV3SecretsTagsSecretNamePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;secretName&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsTagsSecretNamePost&#x27;, &#x27;secretName&#x27;, secretName)
            // verify required parameter &#x27;apiV3SecretsTagsSecretNamePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SecretsTagsSecretNamePost&#x27;, &#x27;apiV3SecretsTagsSecretNamePostRequest&#x27;, apiV3SecretsTagsSecretNamePostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/secrets/tags/{secretName}&#x60;
                .replace(&#x60;{${&quot;secretName&quot;}}&#x60;, encodeURIComponent(String(secretName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SecretsTagsSecretNamePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV3SignupCompleteAccountInvitePostRequest} apiV3SignupCompleteAccountInvitePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SignupCompleteAccountInvitePost: async (apiV3SignupCompleteAccountInvitePostRequest: ApiV3SignupCompleteAccountInvitePostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV3SignupCompleteAccountInvitePostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SignupCompleteAccountInvitePost&#x27;, &#x27;apiV3SignupCompleteAccountInvitePostRequest&#x27;, apiV3SignupCompleteAccountInvitePostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/signup/complete-account/invite&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SignupCompleteAccountInvitePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV3SignupCompleteAccountSignupPostRequest} apiV3SignupCompleteAccountSignupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SignupCompleteAccountSignupPost: async (apiV3SignupCompleteAccountSignupPostRequest: ApiV3SignupCompleteAccountSignupPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV3SignupCompleteAccountSignupPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SignupCompleteAccountSignupPost&#x27;, &#x27;apiV3SignupCompleteAccountSignupPostRequest&#x27;, apiV3SignupCompleteAccountSignupPostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/signup/complete-account/signup&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3SignupCompleteAccountSignupPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PasswordEmailPasswordResetPostRequest} apiV1PasswordEmailPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SignupEmailSignupPost: async (apiV1PasswordEmailPasswordResetPostRequest: ApiV1PasswordEmailPasswordResetPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PasswordEmailPasswordResetPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SignupEmailSignupPost&#x27;, &#x27;apiV1PasswordEmailPasswordResetPostRequest&#x27;, apiV1PasswordEmailPasswordResetPostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/signup/email/signup&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PasswordEmailPasswordResetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PasswordEmailPasswordResetVerifyPostRequest} apiV1PasswordEmailPasswordResetVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SignupEmailVerifyPost: async (apiV1PasswordEmailPasswordResetVerifyPostRequest: ApiV1PasswordEmailPasswordResetVerifyPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;apiV1PasswordEmailPasswordResetVerifyPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3SignupEmailVerifyPost&#x27;, &#x27;apiV1PasswordEmailPasswordResetVerifyPostRequest&#x27;, apiV1PasswordEmailPasswordResetVerifyPostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/signup/email/verify&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV1PasswordEmailPasswordResetVerifyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3UsersMeApiKeysGet: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/api/v3/users/me/api-keys&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3WorkspacesProjectIdSecretsBlindIndexStatusGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3WorkspacesProjectIdSecretsBlindIndexStatusGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v3/workspaces/{projectId}/secrets/blind-index-status&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3WorkspacesProjectIdSecretsGet: async (projectId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3WorkspacesProjectIdSecretsGet&#x27;, &#x27;projectId&#x27;, projectId)
            const localVarPath &#x3D; &#x60;/api/v3/workspaces/{projectId}/secrets&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {ApiV3WorkspacesProjectIdSecretsNamesPostRequest} apiV3WorkspacesProjectIdSecretsNamesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3WorkspacesProjectIdSecretsNamesPost: async (projectId: string, apiV3WorkspacesProjectIdSecretsNamesPostRequest: ApiV3WorkspacesProjectIdSecretsNamesPostRequest, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;projectId&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3WorkspacesProjectIdSecretsNamesPost&#x27;, &#x27;projectId&#x27;, projectId)
            // verify required parameter &#x27;apiV3WorkspacesProjectIdSecretsNamesPostRequest&#x27; is not null or undefined
            assertParamExists(&#x27;apiV3WorkspacesProjectIdSecretsNamesPost&#x27;, &#x27;apiV3WorkspacesProjectIdSecretsNamesPostRequest&#x27;, apiV3WorkspacesProjectIdSecretsNamesPostRequest)
            const localVarPath &#x3D; &#x60;/api/v3/workspaces/{projectId}/secrets/names&#x60;
                .replace(&#x60;{${&quot;projectId&quot;}}&#x60;, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(apiV3WorkspacesProjectIdSecretsNamesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssWebhookPost: async (options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            const localVarPath &#x3D; &#x60;/ss-webhook&#x60;;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} certificateTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wellKnownEstCertificateTemplateIdCacertsGet: async (certificateTemplateId: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;certificateTemplateId&#x27; is not null or undefined
            assertParamExists(&#x27;wellKnownEstCertificateTemplateIdCacertsGet&#x27;, &#x27;certificateTemplateId&#x27;, certificateTemplateId)
            const localVarPath &#x3D; &#x60;/.well-known/est/{certificateTemplateId}/cacerts&#x60;
                .replace(&#x60;{${&quot;certificateTemplateId&quot;}}&#x60;, encodeURIComponent(String(certificateTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;GET&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} certificateTemplateId 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wellKnownEstCertificateTemplateIdSimpleenrollPost: async (certificateTemplateId: string, body?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;certificateTemplateId&#x27; is not null or undefined
            assertParamExists(&#x27;wellKnownEstCertificateTemplateIdSimpleenrollPost&#x27;, &#x27;certificateTemplateId&#x27;, certificateTemplateId)
            const localVarPath &#x3D; &#x60;/.well-known/est/{certificateTemplateId}/simpleenroll&#x60;
                .replace(&#x60;{${&quot;certificateTemplateId&quot;}}&#x60;, encodeURIComponent(String(certificateTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} certificateTemplateId 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wellKnownEstCertificateTemplateIdSimplereenrollPost: async (certificateTemplateId: string, body?: string, options: RawAxiosRequestConfig &#x3D; {}): Promise&lt;RequestArgs&gt; &#x3D;&gt; {
            // verify required parameter &#x27;certificateTemplateId&#x27; is not null or undefined
            assertParamExists(&#x27;wellKnownEstCertificateTemplateIdSimplereenrollPost&#x27;, &#x27;certificateTemplateId&#x27;, certificateTemplateId)
            const localVarPath &#x3D; &#x60;/.well-known/est/{certificateTemplateId}/simplereenroll&#x60;
                .replace(&#x60;{${&quot;certificateTemplateId&quot;}}&#x60;, encodeURIComponent(String(certificateTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj &#x3D; new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions &#x3D; configuration.baseOptions;
            }

            const localVarRequestOptions &#x3D; { method: &#x27;POST&#x27;, ...baseOptions, ...options};
            const localVarHeaderParameter &#x3D; {} as any;
            const localVarQueryParameter &#x3D; {} as any;


    
            localVarHeaderParameter[&#x27;Content-Type&#x27;] &#x3D; &#x27;application/json&#x27;;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions &#x3D; baseOptions &amp;&amp; baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers &#x3D; {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data &#x3D; serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>DefaultApi - axios parameter creator</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="DefaultApiFactory"></a>
                    <span class="name">
                        <span ><b>DefaultApiFactory</b></span>
                        <a href="#DefaultApiFactory"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp &#x3D; DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStatusGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiStatusGet200Response&gt; {
            return localVarFp.apiStatusGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {string} envSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsPoliciesCountGet(projectSlug: string, envSlug: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet200Response&gt; {
            return localVarFp.apiV1AccessApprovalsPoliciesCountGet(projectSlug, envSlug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsPoliciesGet(projectSlug: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AccessApprovalsPoliciesGet200Response&gt; {
            return localVarFp.apiV1AccessApprovalsPoliciesGet(projectSlug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsPoliciesPolicyIdDelete(policyId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalsPost200Response&gt; {
            return localVarFp.apiV1AccessApprovalsPoliciesPolicyIdDelete(policyId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsPoliciesPolicyIdGet(policyId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AccessApprovalsPoliciesPolicyIdGet200Response&gt; {
            return localVarFp.apiV1AccessApprovalsPoliciesPolicyIdGet(policyId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId 
         * @param {ApiV1AccessApprovalsPoliciesPolicyIdPatchRequest} apiV1AccessApprovalsPoliciesPolicyIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsPoliciesPolicyIdPatch(policyId: string, apiV1AccessApprovalsPoliciesPolicyIdPatchRequest: ApiV1AccessApprovalsPoliciesPolicyIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalsPost200Response&gt; {
            return localVarFp.apiV1AccessApprovalsPoliciesPolicyIdPatch(policyId, apiV1AccessApprovalsPoliciesPolicyIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AccessApprovalsPoliciesPostRequest} apiV1AccessApprovalsPoliciesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsPoliciesPost(apiV1AccessApprovalsPoliciesPostRequest: ApiV1AccessApprovalsPoliciesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalsPost200Response&gt; {
            return localVarFp.apiV1AccessApprovalsPoliciesPost(apiV1AccessApprovalsPoliciesPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsRequestsCountGet(projectSlug: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AccessApprovalsRequestsCountGet200Response&gt; {
            return localVarFp.apiV1AccessApprovalsRequestsCountGet(projectSlug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {string} [authorProjectMembershipId] 
         * @param {string} [envSlug] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsRequestsGet(projectSlug: string, authorProjectMembershipId?: string, envSlug?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AccessApprovalsRequestsGet200Response&gt; {
            return localVarFp.apiV1AccessApprovalsRequestsGet(projectSlug, authorProjectMembershipId, envSlug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {ApiV1AccessApprovalsRequestsPostRequest} apiV1AccessApprovalsRequestsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsRequestsPost(projectSlug: string, apiV1AccessApprovalsRequestsPostRequest: ApiV1AccessApprovalsRequestsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AccessApprovalsRequestsPost200Response&gt; {
            return localVarFp.apiV1AccessApprovalsRequestsPost(projectSlug, apiV1AccessApprovalsRequestsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} requestId 
         * @param {ApiV1AccessApprovalsRequestsRequestIdReviewPostRequest} apiV1AccessApprovalsRequestsRequestIdReviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccessApprovalsRequestsRequestIdReviewPost(requestId: string, apiV1AccessApprovalsRequestsRequestIdReviewPostRequest: ApiV1AccessApprovalsRequestsRequestIdReviewPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AccessApprovalsRequestsRequestIdReviewPost200Response&gt; {
            return localVarFp.apiV1AccessApprovalsRequestsRequestIdReviewPost(requestId, apiV1AccessApprovalsRequestsRequestIdReviewPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete a specific privilege of an identity.
         * @param {ApiV1AdditionalPrivilegeIdentityDeleteRequest} apiV1AdditionalPrivilegeIdentityDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdditionalPrivilegeIdentityDelete(apiV1AdditionalPrivilegeIdentityDeleteRequest: ApiV1AdditionalPrivilegeIdentityDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt; {
            return localVarFp.apiV1AdditionalPrivilegeIdentityDelete(apiV1AdditionalPrivilegeIdentityDeleteRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List of a specific privilege of an identity in a project.
         * @param {string} identityId The ID of the identity to list.
         * @param {string} projectSlug The slug of the project of the identity in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdditionalPrivilegeIdentityGet(identityId: string, projectSlug: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityGet200Response&gt; {
            return localVarFp.apiV1AdditionalPrivilegeIdentityGet(identityId, projectSlug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update a specific privilege of an identity.
         * @param {ApiV1AdditionalPrivilegeIdentityPatchRequest} apiV1AdditionalPrivilegeIdentityPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdditionalPrivilegeIdentityPatch(apiV1AdditionalPrivilegeIdentityPatchRequest: ApiV1AdditionalPrivilegeIdentityPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt; {
            return localVarFp.apiV1AdditionalPrivilegeIdentityPatch(apiV1AdditionalPrivilegeIdentityPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a permanent or a non expiry specific privilege for identity.
         * @param {ApiV1AdditionalPrivilegeIdentityPermanentPostRequest} apiV1AdditionalPrivilegeIdentityPermanentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdditionalPrivilegeIdentityPermanentPost(apiV1AdditionalPrivilegeIdentityPermanentPostRequest: ApiV1AdditionalPrivilegeIdentityPermanentPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt; {
            return localVarFp.apiV1AdditionalPrivilegeIdentityPermanentPost(apiV1AdditionalPrivilegeIdentityPermanentPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Retrieve details of a specific privilege by privilege slug.
         * @param {string} identityId The ID of the identity to list.
         * @param {string} projectSlug The slug of the project of the identity in.
         * @param {string} privilegeSlug The slug of the privilege.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdditionalPrivilegeIdentityPrivilegeSlugGet(identityId: string, projectSlug: string, privilegeSlug: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt; {
            return localVarFp.apiV1AdditionalPrivilegeIdentityPrivilegeSlugGet(identityId, projectSlug, privilegeSlug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a temporary or a expiring specific privilege for identity.
         * @param {ApiV1AdditionalPrivilegeIdentityTemporaryPostRequest} apiV1AdditionalPrivilegeIdentityTemporaryPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdditionalPrivilegeIdentityTemporaryPost(apiV1AdditionalPrivilegeIdentityTemporaryPostRequest: ApiV1AdditionalPrivilegeIdentityTemporaryPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt; {
            return localVarFp.apiV1AdditionalPrivilegeIdentityTemporaryPost(apiV1AdditionalPrivilegeIdentityTemporaryPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AdminBootstrapPostRequest} apiV1AdminBootstrapPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminBootstrapPost(apiV1AdminBootstrapPostRequest: ApiV1AdminBootstrapPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdminBootstrapPost200Response&gt; {
            return localVarFp.apiV1AdminBootstrapPost(apiV1AdminBootstrapPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminConfigGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdminConfigGet200Response&gt; {
            return localVarFp.apiV1AdminConfigGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AdminConfigPatchRequest} [apiV1AdminConfigPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminConfigPatch(apiV1AdminConfigPatchRequest?: ApiV1AdminConfigPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdminConfigPatch200Response&gt; {
            return localVarFp.apiV1AdminConfigPatch(apiV1AdminConfigPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminEncryptionStrategiesGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdminEncryptionStrategiesGet200Response&gt; {
            return localVarFp.apiV1AdminEncryptionStrategiesGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AdminEncryptionStrategiesPatchRequest} apiV1AdminEncryptionStrategiesPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminEncryptionStrategiesPatch(apiV1AdminEncryptionStrategiesPatchRequest: ApiV1AdminEncryptionStrategiesPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1AdminEncryptionStrategiesPatch(apiV1AdminEncryptionStrategiesPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} [searchTerm] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminIdentityManagementIdentitiesGet(searchTerm?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdminIdentityManagementIdentitiesGet200Response&gt; {
            return localVarFp.apiV1AdminIdentityManagementIdentitiesGet(searchTerm, offset, limit, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminIdentityManagementIdentitiesIdentityIdSuperAdminAccessDelete(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdminIdentityManagementIdentitiesIdentityIdSuperAdminAccessDelete200Response&gt; {
            return localVarFp.apiV1AdminIdentityManagementIdentitiesIdentityIdSuperAdminAccessDelete(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminIntegrationsSlackConfigGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdminIntegrationsSlackConfigGet200Response&gt; {
            return localVarFp.apiV1AdminIntegrationsSlackConfigGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AdminSignupPostRequest} apiV1AdminSignupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminSignupPost(apiV1AdminSignupPostRequest: ApiV1AdminSignupPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdminSignupPost200Response&gt; {
            return localVarFp.apiV1AdminSignupPost(apiV1AdminSignupPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} [searchTerm] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [adminsOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminUserManagementUsersGet(searchTerm?: string, offset?: number, limit?: number, adminsOnly?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdminUserManagementUsersGet200Response&gt; {
            return localVarFp.apiV1AdminUserManagementUsersGet(searchTerm, offset, limit, adminsOnly, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminUserManagementUsersUserIdAdminAccessDelete(userId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdminUserManagementUsersUserIdAdminAccessDelete200Response&gt; {
            return localVarFp.apiV1AdminUserManagementUsersUserIdAdminAccessDelete(userId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminUserManagementUsersUserIdAdminAccessPatch(userId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1AdminUserManagementUsersUserIdAdminAccessPatch(userId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdminUserManagementUsersUserIdDelete(userId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdminUserManagementUsersUserIdDelete200Response&gt; {
            return localVarFp.apiV1AdminUserManagementUsersUserIdDelete(userId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the AWS Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsAvailableGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAwsAvailableGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsAwsAvailableGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified AWS Connection.
         * @param {string} connectionId The ID of the AWS Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAwsPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAwsConnectionIdDelete(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified AWS Connection by ID.
         * @param {string} connectionId The ID of the AWS Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAwsPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAwsConnectionIdGet(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AppConnectionsAwsConnectionIdKmsKeysGetRegionEnum} region 
         * @param {ApiV1AppConnectionsAwsConnectionIdKmsKeysGetDestinationEnum} destination 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsConnectionIdKmsKeysGet(region: ApiV1AppConnectionsAwsConnectionIdKmsKeysGetRegionEnum, destination: ApiV1AppConnectionsAwsConnectionIdKmsKeysGetDestinationEnum, connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAwsConnectionIdKmsKeysGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsAwsConnectionIdKmsKeysGet(region, destination, connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified AWS Connection.
         * @param {string} connectionId The ID of the AWS Connection to be updated.
         * @param {ApiV1AppConnectionsAwsConnectionIdPatchRequest} [apiV1AppConnectionsAwsConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsConnectionIdPatch(connectionId: string, apiV1AppConnectionsAwsConnectionIdPatchRequest?: ApiV1AppConnectionsAwsConnectionIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAwsPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAwsConnectionIdPatch(connectionId, apiV1AppConnectionsAwsConnectionIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified AWS Connection by name.
         * @param {string} connectionName The name of the AWS Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAwsPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAwsConnectionNameConnectionNameGet(connectionName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the AWS Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAwsGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsAwsGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create an AWS Connection for the current organization.
         * @param {ApiV1AppConnectionsAwsPostRequest} [apiV1AppConnectionsAwsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAwsPost(apiV1AppConnectionsAwsPostRequest?: ApiV1AppConnectionsAwsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAwsPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAwsPost(apiV1AppConnectionsAwsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the Azure App Configuration Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationAvailableGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationAvailableGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureAppConfigurationAvailableGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified Azure App Configuration Connection.
         * @param {string} connectionId The ID of the Azure App Configuration Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureAppConfigurationConnectionIdDelete(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Azure App Configuration Connection by ID.
         * @param {string} connectionId The ID of the Azure App Configuration Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureAppConfigurationConnectionIdGet(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified Azure App Configuration Connection.
         * @param {string} connectionId The ID of the Azure App Configuration Connection to be updated.
         * @param {ApiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest} [apiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationConnectionIdPatch(connectionId: string, apiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest?: ApiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureAppConfigurationConnectionIdPatch(connectionId, apiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Azure App Configuration Connection by name.
         * @param {string} connectionName The name of the Azure App Configuration Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureAppConfigurationConnectionNameConnectionNameGet(connectionName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the Azure App Configuration Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureAppConfigurationGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create an Azure App Configuration Connection for the current organization.
         * @param {ApiV1AppConnectionsAzureAppConfigurationPostRequest} [apiV1AppConnectionsAzureAppConfigurationPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureAppConfigurationPost(apiV1AppConnectionsAzureAppConfigurationPostRequest?: ApiV1AppConnectionsAzureAppConfigurationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureAppConfigurationPost(apiV1AppConnectionsAzureAppConfigurationPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the Azure Key Vault Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultAvailableGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultAvailableGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureKeyVaultAvailableGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified Azure Key Vault Connection.
         * @param {string} connectionId The ID of the Azure Key Vault Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureKeyVaultConnectionIdDelete(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Azure Key Vault Connection by ID.
         * @param {string} connectionId The ID of the Azure Key Vault Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureKeyVaultConnectionIdGet(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified Azure Key Vault Connection.
         * @param {string} connectionId The ID of the Azure Key Vault Connection to be updated.
         * @param {ApiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest} [apiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultConnectionIdPatch(connectionId: string, apiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest?: ApiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureKeyVaultConnectionIdPatch(connectionId, apiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Azure Key Vault Connection by name.
         * @param {string} connectionName The name of the Azure Key Vault Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureKeyVaultConnectionNameConnectionNameGet(connectionName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the Azure Key Vault Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureKeyVaultGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create an Azure Key Vault Connection for the current organization.
         * @param {ApiV1AppConnectionsAzureKeyVaultPostRequest} [apiV1AppConnectionsAzureKeyVaultPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsAzureKeyVaultPost(apiV1AppConnectionsAzureKeyVaultPostRequest?: ApiV1AppConnectionsAzureKeyVaultPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsAzureKeyVaultPost(apiV1AppConnectionsAzureKeyVaultPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the Databricks Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksAvailableGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsDatabricksAvailableGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsDatabricksAvailableGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified Databricks Connection.
         * @param {string} connectionId The ID of the Databricks Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsDatabricksPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsDatabricksConnectionIdDelete(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Databricks Connection by ID.
         * @param {string} connectionId The ID of the Databricks Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsDatabricksPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsDatabricksConnectionIdGet(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified Databricks Connection.
         * @param {string} connectionId The ID of the Databricks Connection to be updated.
         * @param {ApiV1AppConnectionsDatabricksConnectionIdPatchRequest} [apiV1AppConnectionsDatabricksConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksConnectionIdPatch(connectionId: string, apiV1AppConnectionsDatabricksConnectionIdPatchRequest?: ApiV1AppConnectionsDatabricksConnectionIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsDatabricksPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsDatabricksConnectionIdPatch(connectionId, apiV1AppConnectionsDatabricksConnectionIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksConnectionIdSecretScopesGet(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsDatabricksConnectionIdSecretScopesGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsDatabricksConnectionIdSecretScopesGet(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Databricks Connection by name.
         * @param {string} connectionName The name of the Databricks Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsDatabricksPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsDatabricksConnectionNameConnectionNameGet(connectionName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the Databricks Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsDatabricksGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsDatabricksGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a Databricks Connection for the current organization.
         * @param {ApiV1AppConnectionsDatabricksPostRequest} [apiV1AppConnectionsDatabricksPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsDatabricksPost(apiV1AppConnectionsDatabricksPostRequest?: ApiV1AppConnectionsDatabricksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsDatabricksPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsDatabricksPost(apiV1AppConnectionsDatabricksPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the GCP Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpAvailableGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGcpAvailableGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsGcpAvailableGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified GCP Connection.
         * @param {string} connectionId The ID of the GCP Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGcpPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsGcpConnectionIdDelete(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified GCP Connection by ID.
         * @param {string} connectionId The ID of the GCP Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGcpPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsGcpConnectionIdGet(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified GCP Connection.
         * @param {string} connectionId The ID of the GCP Connection to be updated.
         * @param {ApiV1AppConnectionsGcpConnectionIdPatchRequest} [apiV1AppConnectionsGcpConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpConnectionIdPatch(connectionId: string, apiV1AppConnectionsGcpConnectionIdPatchRequest?: ApiV1AppConnectionsGcpConnectionIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGcpPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsGcpConnectionIdPatch(connectionId, apiV1AppConnectionsGcpConnectionIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpConnectionIdSecretManagerProjectsGet(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV1SecretSnapshotSecretSnapshotIdGet200ResponseSecretSnapshotFolderVersionInner&gt;&gt; {
            return localVarFp.apiV1AppConnectionsGcpConnectionIdSecretManagerProjectsGet(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified GCP Connection by name.
         * @param {string} connectionName The name of the GCP Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGcpPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsGcpConnectionNameConnectionNameGet(connectionName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the GCP Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGcpGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsGcpGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a GCP Connection for the current organization.
         * @param {ApiV1AppConnectionsGcpPostRequest} [apiV1AppConnectionsGcpPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGcpPost(apiV1AppConnectionsGcpPostRequest?: ApiV1AppConnectionsGcpPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGcpPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsGcpPost(apiV1AppConnectionsGcpPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List all the App Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the GitHub Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubAvailableGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGithubAvailableGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsGithubAvailableGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified GitHub Connection.
         * @param {string} connectionId The ID of the GitHub Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGithubPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsGithubConnectionIdDelete(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} repo 
         * @param {string} owner 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionIdEnvironmentsGet(repo: string, owner: string, connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGithubConnectionIdEnvironmentsGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsGithubConnectionIdEnvironmentsGet(repo, owner, connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified GitHub Connection by ID.
         * @param {string} connectionId The ID of the GitHub Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGithubPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsGithubConnectionIdGet(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionIdOrganizationsGet(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGithubConnectionIdOrganizationsGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsGithubConnectionIdOrganizationsGet(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified GitHub Connection.
         * @param {string} connectionId The ID of the GitHub Connection to be updated.
         * @param {ApiV1AppConnectionsGithubConnectionIdPatchRequest} [apiV1AppConnectionsGithubConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionIdPatch(connectionId: string, apiV1AppConnectionsGithubConnectionIdPatchRequest?: ApiV1AppConnectionsGithubConnectionIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGithubPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsGithubConnectionIdPatch(connectionId, apiV1AppConnectionsGithubConnectionIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionIdRepositoriesGet(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGithubConnectionIdRepositoriesGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsGithubConnectionIdRepositoriesGet(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified GitHub Connection by name.
         * @param {string} connectionName The name of the GitHub Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGithubPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsGithubConnectionNameConnectionNameGet(connectionName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the GitHub Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGithubGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsGithubGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a GitHub Connection for the current organization.
         * @param {ApiV1AppConnectionsGithubPostRequest} [apiV1AppConnectionsGithubPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsGithubPost(apiV1AppConnectionsGithubPostRequest?: ApiV1AppConnectionsGithubPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsGithubPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsGithubPost(apiV1AppConnectionsGithubPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the Humanitec Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecAvailableGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsHumanitecAvailableGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsHumanitecAvailableGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified Humanitec Connection.
         * @param {string} connectionId The ID of the Humanitec Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsHumanitecPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsHumanitecConnectionIdDelete(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Humanitec Connection by ID.
         * @param {string} connectionId The ID of the Humanitec Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsHumanitecPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsHumanitecConnectionIdGet(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecConnectionIdOrganizationsGet(connectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV1AppConnectionsHumanitecConnectionIdOrganizationsGet200ResponseInner&gt;&gt; {
            return localVarFp.apiV1AppConnectionsHumanitecConnectionIdOrganizationsGet(connectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified Humanitec Connection.
         * @param {string} connectionId The ID of the Humanitec Connection to be updated.
         * @param {ApiV1AppConnectionsHumanitecConnectionIdPatchRequest} [apiV1AppConnectionsHumanitecConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecConnectionIdPatch(connectionId: string, apiV1AppConnectionsHumanitecConnectionIdPatchRequest?: ApiV1AppConnectionsHumanitecConnectionIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsHumanitecPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsHumanitecConnectionIdPatch(connectionId, apiV1AppConnectionsHumanitecConnectionIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Humanitec Connection by name.
         * @param {string} connectionName The name of the Humanitec Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsHumanitecPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsHumanitecConnectionNameConnectionNameGet(connectionName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the Humanitec Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsHumanitecGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsHumanitecGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a Humanitec Connection for the current organization.
         * @param {ApiV1AppConnectionsHumanitecPostRequest} [apiV1AppConnectionsHumanitecPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsHumanitecPost(apiV1AppConnectionsHumanitecPostRequest?: ApiV1AppConnectionsHumanitecPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsHumanitecPost200Response&gt; {
            return localVarFp.apiV1AppConnectionsHumanitecPost(apiV1AppConnectionsHumanitecPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the available App Connection Options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppConnectionsOptionsGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AppConnectionsOptionsGet200Response&gt; {
            return localVarFp.apiV1AppConnectionsOptionsGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List Audit Log Streams.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuditLogStreamsGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuditLogStreamsGet200Response&gt; {
            return localVarFp.apiV1AuditLogStreamsGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete an Audit Log Stream by ID.
         * @param {string} id The ID of the audit log stream to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuditLogStreamsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuditLogStreamsPost200Response&gt; {
            return localVarFp.apiV1AuditLogStreamsIdDelete(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get an Audit Log Stream by ID.
         * @param {string} id The ID of the audit log stream to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuditLogStreamsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuditLogStreamsIdGet200Response&gt; {
            return localVarFp.apiV1AuditLogStreamsIdGet(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update an Audit Log Stream by ID.
         * @param {string} id The ID of the audit log stream to update.
         * @param {ApiV1AuditLogStreamsIdPatchRequest} [apiV1AuditLogStreamsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuditLogStreamsIdPatch(id: string, apiV1AuditLogStreamsIdPatchRequest?: ApiV1AuditLogStreamsIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuditLogStreamsPost200Response&gt; {
            return localVarFp.apiV1AuditLogStreamsIdPatch(id, apiV1AuditLogStreamsIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create an Audit Log Stream.
         * @param {ApiV1AuditLogStreamsPostRequest} apiV1AuditLogStreamsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuditLogStreamsPost(apiV1AuditLogStreamsPostRequest: ApiV1AuditLogStreamsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuditLogStreamsPost200Response&gt; {
            return localVarFp.apiV1AuditLogStreamsPost(apiV1AuditLogStreamsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete AWS Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAwsAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthAwsAuthIdentitiesIdentityIdDelete(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Retrieve AWS Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAwsAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthAwsAuthIdentitiesIdentityIdGet(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update AWS Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAwsAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthAwsAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Attach AWS Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthAwsAuthIdentitiesIdentityIdPostRequest} [apiV1AuthAwsAuthIdentitiesIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAwsAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthAwsAuthIdentitiesIdentityIdPostRequest?: ApiV1AuthAwsAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthAwsAuthIdentitiesIdentityIdPost(identityId, apiV1AuthAwsAuthIdentitiesIdentityIdPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Login with AWS Auth
         * @param {ApiV1AuthAwsAuthLoginPostRequest} apiV1AuthAwsAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAwsAuthLoginPost(apiV1AuthAwsAuthLoginPostRequest: ApiV1AuthAwsAuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt; {
            return localVarFp.apiV1AuthAwsAuthLoginPost(apiV1AuthAwsAuthLoginPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete Azure Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAzureAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthAzureAuthIdentitiesIdentityIdDelete(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Retrieve Azure Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAzureAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthAzureAuthIdentitiesIdentityIdGet(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update Azure Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAzureAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthAzureAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Attach Azure Auth configuration onto identity
         * @param {string} identityId The ID of the identity to login.
         * @param {ApiV1AuthAzureAuthIdentitiesIdentityIdPostRequest} apiV1AuthAzureAuthIdentitiesIdentityIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAzureAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthAzureAuthIdentitiesIdentityIdPostRequest: ApiV1AuthAzureAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthAzureAuthIdentitiesIdentityIdPost(identityId, apiV1AuthAzureAuthIdentitiesIdentityIdPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Login with Azure Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAzureAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt; {
            return localVarFp.apiV1AuthAzureAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthCheckAuthPost(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthCheckAuthPost200Response&gt; {
            return localVarFp.apiV1AuthCheckAuthPost(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete GCP Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthGcpAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthGcpAuthIdentitiesIdentityIdDelete(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Retrieve GCP Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthGcpAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthGcpAuthIdentitiesIdentityIdGet(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update GCP Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthGcpAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthGcpAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Attach GCP Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequest} apiV1AuthGcpAuthIdentitiesIdentityIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthGcpAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthGcpAuthIdentitiesIdentityIdPostRequest: ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthGcpAuthIdentitiesIdentityIdPost(identityId, apiV1AuthGcpAuthIdentitiesIdentityIdPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Login with GCP Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthGcpAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt; {
            return localVarFp.apiV1AuthGcpAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete JWT Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthJwtAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthJwtAuthIdentitiesIdentityIdDelete200Response&gt; {
            return localVarFp.apiV1AuthJwtAuthIdentitiesIdentityIdDelete(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Retrieve JWT Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthJwtAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthJwtAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthJwtAuthIdentitiesIdentityIdGet(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update JWT Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthJwtAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthJwtAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthJwtAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Attach JWT Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequest} [apiV1AuthJwtAuthIdentitiesIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthJwtAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthJwtAuthIdentitiesIdentityIdPostRequest?: ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthJwtAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthJwtAuthIdentitiesIdentityIdPost(identityId, apiV1AuthJwtAuthIdentitiesIdentityIdPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Login with JWT Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthJwtAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt; {
            return localVarFp.apiV1AuthJwtAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete Kubernetes Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthKubernetesAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthKubernetesAuthIdentitiesIdentityIdDelete200Response&gt; {
            return localVarFp.apiV1AuthKubernetesAuthIdentitiesIdentityIdDelete(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Retrieve Kubernetes Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthKubernetesAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthKubernetesAuthIdentitiesIdentityIdGet(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update Kubernetes Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthKubernetesAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthKubernetesAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Attach Kubernetes Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest} apiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthKubernetesAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest: ApiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthKubernetesAuthIdentitiesIdentityIdPost(identityId, apiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Login with Kubernetes Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthKubernetesAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt; {
            return localVarFp.apiV1AuthKubernetesAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV1AuthLogoutPost(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete OIDC Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthOidcAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthOidcAuthIdentitiesIdentityIdDelete200Response&gt; {
            return localVarFp.apiV1AuthOidcAuthIdentitiesIdentityIdDelete(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Retrieve OIDC Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthOidcAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthOidcAuthIdentitiesIdentityIdGet(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update OIDC Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthOidcAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthOidcAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Attach OIDC Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthOidcAuthIdentitiesIdentityIdPostRequest} apiV1AuthOidcAuthIdentitiesIdentityIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthOidcAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthOidcAuthIdentitiesIdentityIdPostRequest: ApiV1AuthOidcAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthOidcAuthIdentitiesIdentityIdPost(identityId, apiV1AuthOidcAuthIdentitiesIdentityIdPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Login with OIDC Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthOidcAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt; {
            return localVarFp.apiV1AuthOidcAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete Token Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthTokenAuthIdentitiesIdentityIdDelete(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Retrieve Token Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthTokenAuthIdentitiesIdentityIdGet(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update Token Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthTokenAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Attach Token Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthTokenAuthIdentitiesIdentityIdPostRequest} [apiV1AuthTokenAuthIdentitiesIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthTokenAuthIdentitiesIdentityIdPostRequest?: ApiV1AuthTokenAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthTokenAuthIdentitiesIdentityIdPost(identityId, apiV1AuthTokenAuthIdentitiesIdentityIdPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get tokens for identity with Token Auth
         * @param {string} identityId The ID of the identity to list token metadata for.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th token.
         * @param {number} [limit] The number of tokens to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthIdentitiesIdentityIdTokensGet(identityId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensGet200Response&gt; {
            return localVarFp.apiV1AuthTokenAuthIdentitiesIdentityIdTokensGet(identityId, offset, limit, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create token for identity with Token Auth
         * @param {string} identityId The ID of the identity to create the token for.
         * @param {ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest} [apiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthIdentitiesIdentityIdTokensPost(identityId: string, apiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest?: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt; {
            return localVarFp.apiV1AuthTokenAuthIdentitiesIdentityIdTokensPost(identityId, apiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update token for identity with Token Auth
         * @param {string} tokenId The ID of the token to update metadata for.
         * @param {ApiV1AuthTokenAuthTokensTokenIdPatchRequest} [apiV1AuthTokenAuthTokensTokenIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthTokensTokenIdPatch(tokenId: string, apiV1AuthTokenAuthTokensTokenIdPatchRequest?: ApiV1AuthTokenAuthTokensTokenIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthTokensTokenIdPatch200Response&gt; {
            return localVarFp.apiV1AuthTokenAuthTokensTokenIdPatch(tokenId, apiV1AuthTokenAuthTokensTokenIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Revoke token for identity with Token Auth
         * @param {string} tokenId The ID of the token to revoke.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenAuthTokensTokenIdRevokePost(tokenId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV1AuthTokenAuthTokensTokenIdRevokePost(tokenId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenPost(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenPost200Response&gt; {
            return localVarFp.apiV1AuthTokenPost(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Renew access token
         * @param {ApiV1AuthTokenRenewPostRequest} apiV1AuthTokenRenewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenRenewPost(apiV1AuthTokenRenewPostRequest: ApiV1AuthTokenRenewPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt; {
            return localVarFp.apiV1AuthTokenRenewPost(apiV1AuthTokenRenewPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Revoke access token
         * @param {ApiV1AuthTokenRevokePostRequest} apiV1AuthTokenRevokePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTokenRevokePost(apiV1AuthTokenRevokePostRequest: ApiV1AuthTokenRevokePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV1AuthTokenRevokePost(apiV1AuthTokenRevokePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get Universal Auth Client Secret for identity
         * @param {string} identityId The ID of the identity to get the client secret from.
         * @param {string} clientSecretId The ID of the client secret to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet(identityId: string, clientSecretId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet200Response&gt; {
            return localVarFp.apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet(identityId, clientSecretId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Revoke Universal Auth Client Secrets for identity
         * @param {string} identityId The ID of the identity to revoke the client secret from.
         * @param {string} clientSecretId The ID of the client secret to revoke.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdRevokePost(identityId: string, clientSecretId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet200Response&gt; {
            return localVarFp.apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdRevokePost(identityId, clientSecretId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List Universal Auth Client Secrets for identity
         * @param {string} identityId The ID of the identity to list client secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet200Response&gt; {
            return localVarFp.apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create Universal Auth Client Secret for identity
         * @param {string} identityId The ID of the identity to create a client secret for.
         * @param {ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest} [apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost(identityId: string, apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest?: ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost200Response&gt; {
            return localVarFp.apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost(identityId, apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete Universal Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthUniversalAuthIdentitiesIdentityIdDelete(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Retrieve Universal Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthUniversalAuthIdentitiesIdentityIdGet(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update Universal Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthUniversalAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Attach Universal Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest} [apiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest?: ApiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1AuthUniversalAuthIdentitiesIdentityIdPost(identityId, apiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Login with Universal Auth
         * @param {ApiV1AuthUniversalAuthLoginPostRequest} apiV1AuthUniversalAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthUniversalAuthLoginPost(apiV1AuthUniversalAuthLoginPostRequest: ApiV1AuthUniversalAuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt; {
            return localVarFp.apiV1AuthUniversalAuthLoginPost(apiV1AuthUniversalAuthLoginPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} botId 
         * @param {ApiV1BotBotIdActivePatchRequest} apiV1BotBotIdActivePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BotBotIdActivePatch(botId: string, apiV1BotBotIdActivePatchRequest: ApiV1BotBotIdActivePatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1BotProjectIdGet200Response&gt; {
            return localVarFp.apiV1BotBotIdActivePatch(botId, apiV1BotBotIdActivePatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BotProjectIdGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1BotProjectIdGet200Response&gt; {
            return localVarFp.apiV1BotProjectIdGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} environment 
         * @param {string} [secretPath] 
         * @param {ApiV1DashboardAccessibleSecretsGetFilterByActionEnum} [filterByAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardAccessibleSecretsGet(projectId: string, environment: string, secretPath?: string, filterByAction?: ApiV1DashboardAccessibleSecretsGetFilterByActionEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DashboardAccessibleSecretsGet200Response&gt; {
            return localVarFp.apiV1DashboardAccessibleSecretsGet(projectId, environment, secretPath, filterByAction, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} environment 
         * @param {string} keys 
         * @param {string} [secretPath] 
         * @param {ApiV1FoldersGetRecursiveParameter} [viewSecretValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardSecretsByKeysGet(projectId: string, environment: string, keys: string, secretPath?: string, viewSecretValue?: ApiV1FoldersGetRecursiveParameter, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DashboardSecretsByKeysGet200Response&gt; {
            return localVarFp.apiV1DashboardSecretsByKeysGet(projectId, environment, keys, secretPath, viewSecretValue, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} environments 
         * @param {string} [secretPath] 
         * @param {string} [search] 
         * @param {string} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardSecretsDeepSearchGet(projectId: string, environments: string, secretPath?: string, search?: string, tags?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DashboardSecretsDeepSearchGet200Response&gt; {
            return localVarFp.apiV1DashboardSecretsDeepSearchGet(projectId, environments, secretPath, search, tags, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List project secrets details
         * @param {string} projectId The ID of the project to list secrets/folders from.
         * @param {string} environment The slug of the environment to list secrets/folders from.
         * @param {string} [secretPath] The secret path to list secrets/folders from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th secret/folder.
         * @param {number} [limit] The number of secrets/folders to return.
         * @param {ApiV1DashboardSecretsDetailsGetOrderByEnum} [orderBy] The column to order secrets/folders by.
         * @param {ApiV1DashboardSecretsDetailsGetOrderDirectionEnum} [orderDirection] The direction to order secrets/folders in.
         * @param {string} [search] The text string to filter secret keys and folder names by.
         * @param {string} [tags] The tags to filter secrets by (comma separated, ie \&amp;#39;tags&amp;#x3D;billing,engineering\&amp;#39;).
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [viewSecretValue] 
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeSecrets] Whether to include project secrets in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeFolders] Whether to include project folders in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeDynamicSecrets] Whether to include dynamic project secrets in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeImports] Whether to include project secret imports in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardSecretsDetailsGet(projectId: string, environment: string, secretPath?: string, offset?: number, limit?: number, orderBy?: ApiV1DashboardSecretsDetailsGetOrderByEnum, orderDirection?: ApiV1DashboardSecretsDetailsGetOrderDirectionEnum, search?: string, tags?: string, viewSecretValue?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeSecrets?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeFolders?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeDynamicSecrets?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeImports?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DashboardSecretsDetailsGet200Response&gt; {
            return localVarFp.apiV1DashboardSecretsDetailsGet(projectId, environment, secretPath, offset, limit, orderBy, orderDirection, search, tags, viewSecretValue, includeSecrets, includeFolders, includeDynamicSecrets, includeImports, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List project secrets overview
         * @param {string} projectId The ID of the project to list secrets/folders from.
         * @param {string} environments The slugs of the environments to list secrets/folders from (comma separated, ie \&amp;#39;environments&amp;#x3D;dev,staging,prod\&amp;#39;).
         * @param {string} [secretPath] The secret path to list secrets/folders from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th secret/folder.
         * @param {number} [limit] The number of secrets/folders to return.
         * @param {ApiV1DashboardSecretsOverviewGetOrderByEnum} [orderBy] The column to order secrets/folders by.
         * @param {ApiV1DashboardSecretsOverviewGetOrderDirectionEnum} [orderDirection] The direction to order secrets/folders in.
         * @param {string} [search] The text string to filter secret keys and folder names by.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeSecrets] Whether to include project secrets in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeFolders] Whether to include project folders in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeImports] Whether to include project secret imports in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeDynamicSecrets] Whether to include dynamic project secrets in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DashboardSecretsOverviewGet(projectId: string, environments: string, secretPath?: string, offset?: number, limit?: number, orderBy?: ApiV1DashboardSecretsOverviewGetOrderByEnum, orderDirection?: ApiV1DashboardSecretsOverviewGetOrderDirectionEnum, search?: string, includeSecrets?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeFolders?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeImports?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeDynamicSecrets?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DashboardSecretsOverviewGet200Response&gt; {
            return localVarFp.apiV1DashboardSecretsOverviewGet(projectId, environments, secretPath, offset, limit, orderBy, orderDirection, search, includeSecrets, includeFolders, includeImports, includeDynamicSecrets, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1DynamicSecretsEntraIdUsersPostRequest} apiV1DynamicSecretsEntraIdUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsEntraIdUsersPost(apiV1DynamicSecretsEntraIdUsersPostRequest: ApiV1DynamicSecretsEntraIdUsersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV1DynamicSecretsEntraIdUsersPost200ResponseInner&gt;&gt; {
            return localVarFp.apiV1DynamicSecretsEntraIdUsersPost(apiV1DynamicSecretsEntraIdUsersPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project to create dynamic secret in.
         * @param {string} environmentSlug The slug of the environment to list folders from.
         * @param {string} [path] The path to list folders from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsGet(projectSlug: string, environmentSlug: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DynamicSecretsGet200Response&gt; {
            return localVarFp.apiV1DynamicSecretsGet(projectSlug, environmentSlug, path, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} leaseId The ID of the dynamic secret lease.
         * @param {ApiV1DynamicSecretsLeasesLeaseIdDeleteRequest} apiV1DynamicSecretsLeasesLeaseIdDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsLeasesLeaseIdDelete(leaseId: string, apiV1DynamicSecretsLeasesLeaseIdDeleteRequest: ApiV1DynamicSecretsLeasesLeaseIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DynamicSecretsLeasesLeaseIdDelete200Response&gt; {
            return localVarFp.apiV1DynamicSecretsLeasesLeaseIdDelete(leaseId, apiV1DynamicSecretsLeasesLeaseIdDeleteRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project to create dynamic secret in.
         * @param {string} environmentSlug The slug of the environment to list folders from.
         * @param {string} leaseId The ID of the dynamic secret lease.
         * @param {string} [path] The path to list folders from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsLeasesLeaseIdGet(projectSlug: string, environmentSlug: string, leaseId: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DynamicSecretsLeasesLeaseIdGet200Response&gt; {
            return localVarFp.apiV1DynamicSecretsLeasesLeaseIdGet(projectSlug, environmentSlug, leaseId, path, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} leaseId The ID of the dynamic secret lease.
         * @param {ApiV1DynamicSecretsLeasesLeaseIdRenewPostRequest} apiV1DynamicSecretsLeasesLeaseIdRenewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsLeasesLeaseIdRenewPost(leaseId: string, apiV1DynamicSecretsLeasesLeaseIdRenewPostRequest: ApiV1DynamicSecretsLeasesLeaseIdRenewPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DynamicSecretsLeasesLeaseIdDelete200Response&gt; {
            return localVarFp.apiV1DynamicSecretsLeasesLeaseIdRenewPost(leaseId, apiV1DynamicSecretsLeasesLeaseIdRenewPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1DynamicSecretsLeasesPostRequest} apiV1DynamicSecretsLeasesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsLeasesPost(apiV1DynamicSecretsLeasesPostRequest: ApiV1DynamicSecretsLeasesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DynamicSecretsLeasesPost200Response&gt; {
            return localVarFp.apiV1DynamicSecretsLeasesPost(apiV1DynamicSecretsLeasesPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} name The name of the dynamic secret.
         * @param {ApiV1DynamicSecretsNameDeleteRequest} apiV1DynamicSecretsNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsNameDelete(name: string, apiV1DynamicSecretsNameDeleteRequest: ApiV1DynamicSecretsNameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DynamicSecretsPost200Response&gt; {
            return localVarFp.apiV1DynamicSecretsNameDelete(name, apiV1DynamicSecretsNameDeleteRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project to create dynamic secret in.
         * @param {string} environmentSlug The slug of the environment to list folders from.
         * @param {string} name The name of the dynamic secret.
         * @param {string} [path] The path to list folders from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsNameGet(projectSlug: string, environmentSlug: string, name: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DynamicSecretsNameGet200Response&gt; {
            return localVarFp.apiV1DynamicSecretsNameGet(projectSlug, environmentSlug, name, path, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project to create dynamic secret in.
         * @param {string} environmentSlug The slug of the environment to list folders from.
         * @param {string} name The name of the dynamic secret.
         * @param {string} [path] The path to list folders from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsNameLeasesGet(projectSlug: string, environmentSlug: string, name: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DynamicSecretsNameLeasesGet200Response&gt; {
            return localVarFp.apiV1DynamicSecretsNameLeasesGet(projectSlug, environmentSlug, name, path, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} name The name of the dynamic secret.
         * @param {ApiV1DynamicSecretsNamePatchRequest} apiV1DynamicSecretsNamePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsNamePatch(name: string, apiV1DynamicSecretsNamePatchRequest: ApiV1DynamicSecretsNamePatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DynamicSecretsPost200Response&gt; {
            return localVarFp.apiV1DynamicSecretsNamePatch(name, apiV1DynamicSecretsNamePatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1DynamicSecretsPostRequest} apiV1DynamicSecretsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DynamicSecretsPost(apiV1DynamicSecretsPostRequest: ApiV1DynamicSecretsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1DynamicSecretsPost200Response&gt; {
            return localVarFp.apiV1DynamicSecretsPost(apiV1DynamicSecretsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalGroupMappingsGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV1ExternalGroupMappingsGet200ResponseInner&gt;&gt; {
            return localVarFp.apiV1ExternalGroupMappingsGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ExternalGroupMappingsPutRequest} apiV1ExternalGroupMappingsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalGroupMappingsPut(apiV1ExternalGroupMappingsPutRequest: ApiV1ExternalGroupMappingsPutRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV1ExternalGroupMappingsGet200ResponseInner&gt;&gt; {
            return localVarFp.apiV1ExternalGroupMappingsPut(apiV1ExternalGroupMappingsPutRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ExternalKmsGcpKeysPostRequest} [apiV1ExternalKmsGcpKeysPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsGcpKeysPost(apiV1ExternalKmsGcpKeysPostRequest?: ApiV1ExternalKmsGcpKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ExternalKmsGcpKeysPost200Response&gt; {
            return localVarFp.apiV1ExternalKmsGcpKeysPost(apiV1ExternalKmsGcpKeysPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ExternalKmsGet200Response&gt; {
            return localVarFp.apiV1ExternalKmsGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ExternalKmsPost200Response&gt; {
            return localVarFp.apiV1ExternalKmsIdDelete(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ExternalKmsIdGet200Response&gt; {
            return localVarFp.apiV1ExternalKmsIdGet(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1ExternalKmsIdPatchRequest} apiV1ExternalKmsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsIdPatch(id: string, apiV1ExternalKmsIdPatchRequest: ApiV1ExternalKmsIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ExternalKmsPost200Response&gt; {
            return localVarFp.apiV1ExternalKmsIdPatch(id, apiV1ExternalKmsIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsNameNameGet(name: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ExternalKmsIdGet200Response&gt; {
            return localVarFp.apiV1ExternalKmsNameNameGet(name, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ExternalKmsPostRequest} apiV1ExternalKmsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ExternalKmsPost(apiV1ExternalKmsPostRequest: ApiV1ExternalKmsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ExternalKmsPost200Response&gt; {
            return localVarFp.apiV1ExternalKmsPost(apiV1ExternalKmsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update folders by batch
         * @param {ApiV1FoldersBatchPatchRequest} apiV1FoldersBatchPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FoldersBatchPatch(apiV1FoldersBatchPatchRequest: ApiV1FoldersBatchPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1FoldersBatchPatch200Response&gt; {
            return localVarFp.apiV1FoldersBatchPatch(apiV1FoldersBatchPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete a folder
         * @param {string} folderIdOrName The ID or name of the folder to delete.
         * @param {ApiV1FoldersFolderIdOrNameDeleteRequest} apiV1FoldersFolderIdOrNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FoldersFolderIdOrNameDelete(folderIdOrName: string, apiV1FoldersFolderIdOrNameDeleteRequest: ApiV1FoldersFolderIdOrNameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1FoldersPost200Response&gt; {
            return localVarFp.apiV1FoldersFolderIdOrNameDelete(folderIdOrName, apiV1FoldersFolderIdOrNameDeleteRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update folder
         * @param {string} folderId The ID of the folder to update.
         * @param {ApiV1FoldersFolderIdPatchRequest} apiV1FoldersFolderIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FoldersFolderIdPatch(folderId: string, apiV1FoldersFolderIdPatchRequest: ApiV1FoldersFolderIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1FoldersPost200Response&gt; {
            return localVarFp.apiV1FoldersFolderIdPatch(folderId, apiV1FoldersFolderIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get folders
         * @param {string} workspaceId The ID of the project to list folders from.
         * @param {string} environment The slug of the environment to list folders from.
         * @param {string} [path] The path to list folders from.
         * @param {string} [directory] The directory to list folders from. (Deprecated in favor of path)
         * @param {ApiV1FoldersGetRecursiveParameter} [recursive] Whether or not to fetch all folders from the specified base path, and all of its subdirectories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FoldersGet(workspaceId: string, environment: string, path?: string, directory?: string, recursive?: ApiV1FoldersGetRecursiveParameter, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1FoldersGet200Response&gt; {
            return localVarFp.apiV1FoldersGet(workspaceId, environment, path, directory, recursive, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get folder by id
         * @param {string} id The ID of the folder to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FoldersIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1FoldersIdGet200Response&gt; {
            return localVarFp.apiV1FoldersIdGet(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create folders
         * @param {ApiV1FoldersPostRequest} apiV1FoldersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FoldersPost(apiV1FoldersPostRequest: ApiV1FoldersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1FoldersPost200Response&gt; {
            return localVarFp.apiV1FoldersPost(apiV1FoldersPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1GatewaysExchangeCertPostRequest} apiV1GatewaysExchangeCertPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysExchangeCertPost(apiV1GatewaysExchangeCertPostRequest: ApiV1GatewaysExchangeCertPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GatewaysExchangeCertPost200Response&gt; {
            return localVarFp.apiV1GatewaysExchangeCertPost(apiV1GatewaysExchangeCertPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysGet(projectId?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GatewaysGet200Response&gt; {
            return localVarFp.apiV1GatewaysGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysHeartbeatPost(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV1GatewaysHeartbeatPost(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GatewaysIdDelete200Response&gt; {
            return localVarFp.apiV1GatewaysIdDelete(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GatewaysIdGet200Response&gt; {
            return localVarFp.apiV1GatewaysIdGet(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1GatewaysIdPatchRequest} [apiV1GatewaysIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysIdPatch(id: string, apiV1GatewaysIdPatchRequest?: ApiV1GatewaysIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GatewaysIdDelete200Response&gt; {
            return localVarFp.apiV1GatewaysIdPatch(id, apiV1GatewaysIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysProjectsProjectIdGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GatewaysProjectsProjectIdGet200Response&gt; {
            return localVarFp.apiV1GatewaysProjectsProjectIdGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GatewaysRegisterIdentityPost(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GatewaysRegisterIdentityPost200Response&gt; {
            return localVarFp.apiV1GatewaysRegisterIdentityPost(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV1GroupsGet200ResponseInner&gt;&gt; {
            return localVarFp.apiV1GroupsGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The ID of the group to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GroupsGet200ResponseInner&gt; {
            return localVarFp.apiV1GroupsIdDelete(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The ID of the group to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GroupsGet200ResponseInner&gt; {
            return localVarFp.apiV1GroupsIdGet(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The ID of the group to update.
         * @param {ApiV1GroupsIdPatchRequest} [apiV1GroupsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsIdPatch(id: string, apiV1GroupsIdPatchRequest?: ApiV1GroupsIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GroupsGet200ResponseInner&gt; {
            return localVarFp.apiV1GroupsIdPatch(id, apiV1GroupsIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The ID of the group to list users for.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th user.
         * @param {number} [limit] The number of users to return.
         * @param {string} [username] The username to search for.
         * @param {string} [search] The text string that user email or name will be filtered by.
         * @param {ApiV1GroupsIdUsersGetFilterEnum} [filter] Whether to filter the list of returned users. \&amp;#39;existingMembers\&amp;#39; will only return existing users in the group, \&amp;#39;nonMembers\&amp;#39; will only return users not in the group, undefined will return all users in the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsIdUsersGet(id: string, offset?: number, limit?: number, username?: string, search?: string, filter?: ApiV1GroupsIdUsersGetFilterEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GroupsIdUsersGet200Response&gt; {
            return localVarFp.apiV1GroupsIdUsersGet(id, offset, limit, username, search, filter, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The ID of the group to remove the user from.
         * @param {string} username The username of the user to remove from the group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsIdUsersUsernameDelete(id: string, username: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GroupsIdUsersUsernamePost200Response&gt; {
            return localVarFp.apiV1GroupsIdUsersUsernameDelete(id, username, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The ID of the group to add the user to.
         * @param {string} username The username of the user to add to the group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsIdUsersUsernamePost(id: string, username: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GroupsIdUsersUsernamePost200Response&gt; {
            return localVarFp.apiV1GroupsIdUsersUsernamePost(id, username, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1GroupsPostRequest} apiV1GroupsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1GroupsPost(apiV1GroupsPostRequest: ApiV1GroupsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1GroupsGet200ResponseInner&gt; {
            return localVarFp.apiV1GroupsPost(apiV1GroupsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List identities
         * @param {string} orgId The ID of the organization to list identities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IdentitiesGet(orgId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IdentitiesGet200Response&gt; {
            return localVarFp.apiV1IdentitiesGet(orgId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete identity
         * @param {string} identityId The ID of the identity to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IdentitiesIdentityIdDelete200Response&gt; {
            return localVarFp.apiV1IdentitiesIdentityIdDelete(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get an identity by id
         * @param {string} identityId The ID of the identity to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IdentitiesIdentityIdGet200Response&gt; {
            return localVarFp.apiV1IdentitiesIdentityIdGet(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List project memberships that identity with id is part of
         * @param {string} identityId The ID of the identity to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IdentitiesIdentityIdIdentityMembershipsGet(identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IdentitiesIdentityIdIdentityMembershipsGet200Response&gt; {
            return localVarFp.apiV1IdentitiesIdentityIdIdentityMembershipsGet(identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update identity
         * @param {string} identityId The ID of the identity to update.
         * @param {ApiV1IdentitiesIdentityIdPatchRequest} [apiV1IdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IdentitiesIdentityIdPatch(identityId: string, apiV1IdentitiesIdentityIdPatchRequest?: ApiV1IdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IdentitiesIdentityIdDelete200Response&gt; {
            return localVarFp.apiV1IdentitiesIdentityIdPatch(identityId, apiV1IdentitiesIdentityIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create identity
         * @param {ApiV1IdentitiesPostRequest} apiV1IdentitiesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IdentitiesPost(apiV1IdentitiesPostRequest: ApiV1IdentitiesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IdentitiesPost200Response&gt; {
            return localVarFp.apiV1IdentitiesPost(apiV1IdentitiesPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create the integration authentication object required for syncing secrets.
         * @param {ApiV1IntegrationAuthAccessTokenPostRequest} apiV1IntegrationAuthAccessTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthAccessTokenPost(apiV1IntegrationAuthAccessTokenPostRequest: ApiV1IntegrationAuthAccessTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthAccessTokenPost(apiV1IntegrationAuthAccessTokenPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove all integration\&#x27;s auth object from the project.
         * @param {string} integration The slug of the integration to be unauthorized.
         * @param {string} projectId The ID of the project to delete the integration auth from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthDelete(integration: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthDelete200Response&gt; {
            return localVarFp.apiV1IntegrationAuthDelete(integration, projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {string} [teamId] 
         * @param {string} [azureDevOpsOrgName] 
         * @param {string} [workspaceSlug] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdAppsGet(integrationAuthId: string, teamId?: string, azureDevOpsOrgName?: string, workspaceSlug?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdAppsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdAppsGet(integrationAuthId, teamId, azureDevOpsOrgName, workspaceSlug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} region 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet(region: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet(region, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceSlug 
         * @param {string} repoSlug 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdBitbucketEnvironmentsGet(workspaceSlug: string, repoSlug: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdBitbucketEnvironmentsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdBitbucketEnvironmentsGet(workspaceSlug, repoSlug, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet(integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet(integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet(accountId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet(accountId, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdCircleciOrganizationsGet(integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdCircleciOrganizationsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdCircleciOrganizationsGet(integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove an integration auth object by object id.
         * @param {string} integrationAuthId The ID of integration authentication object to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdDelete(integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdDelete(integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {ApiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest} apiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdDuplicatePost(integrationAuthId: string, apiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest: ApiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdDuplicatePost(integrationAuthId, apiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get details of an integration authorization by auth object id.
         * @param {string} integrationAuthId The ID of integration authentication object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdGet(integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdGet(integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} repoOwner 
         * @param {string} repoName 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet(repoOwner: string, repoName: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet(repoOwner, repoName, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet(integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet(integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet(integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet(integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet(appId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet(appId, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGetScopeEnum} scope 
         * @param {string} spaceId 
         * @param {string} resourceId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGet(scope: ApiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGetScopeEnum, spaceId: string, resourceId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGet(scope, spaceId, resourceId, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdOctopusDeploySpacesGet(integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdOctopusDeploySpacesGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdOctopusDeploySpacesGet(integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the integration authentication object required for syncing secrets.
         * @param {string} integrationAuthId The ID of integration authentication object to update.
         * @param {ApiV1IntegrationAuthIntegrationAuthIdPatchRequest} [apiV1IntegrationAuthIntegrationAuthIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdPatch(integrationAuthId: string, apiV1IntegrationAuthIntegrationAuthIdPatchRequest?: ApiV1IntegrationAuthIntegrationAuthIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdPatch(integrationAuthId, apiV1IntegrationAuthIntegrationAuthIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} environmentId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet(environmentId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet(environmentId, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} environmentId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet(environmentId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet(environmentId, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet(projectId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet(projectId, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} environmentId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet(environmentId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet(environmentId, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdQoveryOrgsGet(integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdQoveryOrgsGet(integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet(orgId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet(orgId, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdRailwayEnvironmentsGet(appId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdRailwayEnvironmentsGet(appId, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet(appId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet(appId, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet(appId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet(appId, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdTeamsGet(integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdTeamsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdTeamsGet(integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet(appId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet(appId, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} teamId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationAuthIdVercelCustomEnvironmentsGet(teamId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdVercelCustomEnvironmentsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationAuthIdVercelCustomEnvironmentsGet(teamId, integrationAuthId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List of integrations available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthIntegrationOptionsGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationOptionsGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthIntegrationOptionsGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1IntegrationAuthOauthTokenPostRequest} apiV1IntegrationAuthOauthTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationAuthOauthTokenPost(apiV1IntegrationAuthOauthTokenPostRequest: ApiV1IntegrationAuthOauthTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGet200Response&gt; {
            return localVarFp.apiV1IntegrationAuthOauthTokenPost(apiV1IntegrationAuthOauthTokenPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove an integration using the integration object ID
         * @param {string} integrationId The ID of the integration object.
         * @param {ApiV1IntegrationIntegrationIdDeleteShouldDeleteIntegrationSecretsEnum} [shouldDeleteIntegrationSecrets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationIntegrationIdDelete(integrationId: string, shouldDeleteIntegrationSecrets?: ApiV1IntegrationIntegrationIdDeleteShouldDeleteIntegrationSecretsEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationIntegrationIdDelete200Response&gt; {
            return localVarFp.apiV1IntegrationIntegrationIdDelete(integrationId, shouldDeleteIntegrationSecrets, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get an integration by integration id
         * @param {string} integrationId The ID of the integration object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationIntegrationIdGet(integrationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationPost200Response&gt; {
            return localVarFp.apiV1IntegrationIntegrationIdGet(integrationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update an integration by integration id
         * @param {string} integrationId The ID of the integration object.
         * @param {ApiV1IntegrationIntegrationIdPatchRequest} [apiV1IntegrationIntegrationIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationIntegrationIdPatch(integrationId: string, apiV1IntegrationIntegrationIdPatchRequest?: ApiV1IntegrationIntegrationIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationPost200Response&gt; {
            return localVarFp.apiV1IntegrationIntegrationIdPatch(integrationId, apiV1IntegrationIntegrationIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Manually trigger sync of an integration by integration id
         * @param {string} integrationId The ID of the integration object to manually sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationIntegrationIdSyncPost(integrationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationIntegrationIdDelete200Response&gt; {
            return localVarFp.apiV1IntegrationIntegrationIdSyncPost(integrationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create an integration to sync secrets.
         * @param {ApiV1IntegrationPostRequest} apiV1IntegrationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1IntegrationPost(apiV1IntegrationPostRequest: ApiV1IntegrationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1IntegrationPost200Response&gt; {
            return localVarFp.apiV1IntegrationPost(apiV1IntegrationPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1InviteOrgSignupPostRequest} apiV1InviteOrgSignupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1InviteOrgSignupPost(apiV1InviteOrgSignupPostRequest: ApiV1InviteOrgSignupPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1InviteOrgSignupPost200Response&gt; {
            return localVarFp.apiV1InviteOrgSignupPost(apiV1InviteOrgSignupPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1InviteOrgSignupResendPostRequest} apiV1InviteOrgSignupResendPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1InviteOrgSignupResendPost(apiV1InviteOrgSignupResendPostRequest: ApiV1InviteOrgSignupResendPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1InviteOrgSignupResendPost200Response&gt; {
            return localVarFp.apiV1InviteOrgSignupResendPost(apiV1InviteOrgSignupResendPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1InviteOrgVerifyPostRequest} apiV1InviteOrgVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1InviteOrgVerifyPost(apiV1InviteOrgVerifyPostRequest: ApiV1InviteOrgVerifyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1InviteOrgVerifyPost200Response&gt; {
            return localVarFp.apiV1InviteOrgVerifyPost(apiV1InviteOrgVerifyPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List KMIP clients
         * @param {string} projectId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {ApiV1KmipClientsGetOrderByEnum} [orderBy] 
         * @param {ApiV1KmipClientsGetOrderDirectionEnum} [orderDirection] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipClientsGet(projectId: string, offset?: number, limit?: number, orderBy?: ApiV1KmipClientsGetOrderByEnum, orderDirection?: ApiV1KmipClientsGetOrderDirectionEnum, search?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipClientsGet200Response&gt; {
            return localVarFp.apiV1KmipClientsGet(projectId, offset, limit, orderBy, orderDirection, search, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1KmipClientsIdCertificatesPostRequest} apiV1KmipClientsIdCertificatesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipClientsIdCertificatesPost(id: string, apiV1KmipClientsIdCertificatesPostRequest: ApiV1KmipClientsIdCertificatesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipClientsIdCertificatesPost200Response&gt; {
            return localVarFp.apiV1KmipClientsIdCertificatesPost(id, apiV1KmipClientsIdCertificatesPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipClientsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipClientsGet200ResponseKmipClientsInner&gt; {
            return localVarFp.apiV1KmipClientsIdDelete(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipClientsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipClientsGet200ResponseKmipClientsInner&gt; {
            return localVarFp.apiV1KmipClientsIdGet(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1KmipClientsIdPatchRequest} apiV1KmipClientsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipClientsIdPatch(id: string, apiV1KmipClientsIdPatchRequest: ApiV1KmipClientsIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipClientsGet200ResponseKmipClientsInner&gt; {
            return localVarFp.apiV1KmipClientsIdPatch(id, apiV1KmipClientsIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1KmipClientsPostRequest} apiV1KmipClientsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipClientsPost(apiV1KmipClientsPostRequest: ApiV1KmipClientsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipClientsGet200ResponseKmipClientsInner&gt; {
            return localVarFp.apiV1KmipClientsPost(apiV1KmipClientsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipGet200Response&gt; {
            return localVarFp.apiV1KmipGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1KmipPostRequest} apiV1KmipPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipPost(apiV1KmipPostRequest: ApiV1KmipPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipGet200Response&gt; {
            return localVarFp.apiV1KmipPost(apiV1KmipPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1KmipServerRegistrationPostRequest} apiV1KmipServerRegistrationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipServerRegistrationPost(apiV1KmipServerRegistrationPostRequest: ApiV1KmipServerRegistrationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipServerRegistrationPost200Response&gt; {
            return localVarFp.apiV1KmipServerRegistrationPost(apiV1KmipServerRegistrationPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * KMIP endpoint for activating managed object
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecActivatePost(apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipSpecActivatePost200Response&gt; {
            return localVarFp.apiV1KmipSpecActivatePost(apiV1SecretRotationsRestartPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * KMIP endpoint for creating managed objects
         * @param {ApiV1KmipSpecCreatePostRequest} apiV1KmipSpecCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecCreatePost(apiV1KmipSpecCreatePostRequest: ApiV1KmipSpecCreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipSpecCreatePost200Response&gt; {
            return localVarFp.apiV1KmipSpecCreatePost(apiV1KmipSpecCreatePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * KMIP endpoint for destroying managed objects
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecDestroyPost(apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretRotationsRestartPostRequest&gt; {
            return localVarFp.apiV1KmipSpecDestroyPost(apiV1SecretRotationsRestartPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * KMIP endpoint for getting attributes of managed object
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecGetAttributesPost(apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipSpecGetAttributesPost200Response&gt; {
            return localVarFp.apiV1KmipSpecGetAttributesPost(apiV1SecretRotationsRestartPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * KMIP endpoint for getting managed objects
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecGetPost(apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipSpecGetPost200Response&gt; {
            return localVarFp.apiV1KmipSpecGetPost(apiV1SecretRotationsRestartPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * KMIP endpoint for locating managed objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecLocatePost(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipSpecLocatePost200Response&gt; {
            return localVarFp.apiV1KmipSpecLocatePost(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * KMIP endpoint for registering managed object
         * @param {ApiV1KmipSpecRegisterPostRequest} apiV1KmipSpecRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecRegisterPost(apiV1KmipSpecRegisterPostRequest: ApiV1KmipSpecRegisterPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretRotationsRestartPostRequest&gt; {
            return localVarFp.apiV1KmipSpecRegisterPost(apiV1KmipSpecRegisterPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * KMIP endpoint for revoking managed object
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmipSpecRevokePost(apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmipSpecRevokePost200Response&gt; {
            return localVarFp.apiV1KmipSpecRevokePost(apiV1SecretRotationsRestartPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List KMS keys
         * @param {string} projectId The ID of the project to list keys from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th key.
         * @param {number} [limit] The number of keys to return.
         * @param {ApiV1KmsKeysGetOrderByEnum} [orderBy] The column to order keys by.
         * @param {ApiV1KmsKeysGetOrderDirectionEnum} [orderDirection] The direction to order keys in.
         * @param {string} [search] The text string to filter key names by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysGet(projectId: string, offset?: number, limit?: number, orderBy?: ApiV1KmsKeysGetOrderByEnum, orderDirection?: ApiV1KmsKeysGetOrderDirectionEnum, search?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmsKeysGet200Response&gt; {
            return localVarFp.apiV1KmsKeysGet(projectId, offset, limit, orderBy, orderDirection, search, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Decrypt data with KMS key
         * @param {string} keyId The ID of the key to decrypt the data with.
         * @param {ApiV1KmsKeysKeyIdDecryptPostRequest} apiV1KmsKeysKeyIdDecryptPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysKeyIdDecryptPost(keyId: string, apiV1KmsKeysKeyIdDecryptPostRequest: ApiV1KmsKeysKeyIdDecryptPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmsKeysKeyIdDecryptPost200Response&gt; {
            return localVarFp.apiV1KmsKeysKeyIdDecryptPost(keyId, apiV1KmsKeysKeyIdDecryptPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete KMS key
         * @param {string} keyId The ID of the key to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysKeyIdDelete(keyId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmsKeysPost200Response&gt; {
            return localVarFp.apiV1KmsKeysKeyIdDelete(keyId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Encrypt data with KMS key
         * @param {string} keyId The ID of the key to encrypt the data with.
         * @param {ApiV1KmsKeysKeyIdEncryptPostRequest} apiV1KmsKeysKeyIdEncryptPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysKeyIdEncryptPost(keyId: string, apiV1KmsKeysKeyIdEncryptPostRequest: ApiV1KmsKeysKeyIdEncryptPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmsKeysKeyIdEncryptPost200Response&gt; {
            return localVarFp.apiV1KmsKeysKeyIdEncryptPost(keyId, apiV1KmsKeysKeyIdEncryptPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get KMS key by ID
         * @param {string} keyId The ID of the KMS key to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysKeyIdGet(keyId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmsKeysPost200Response&gt; {
            return localVarFp.apiV1KmsKeysKeyIdGet(keyId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update KMS key
         * @param {string} keyId The ID of the key to be updated.
         * @param {ApiV1KmsKeysKeyIdPatchRequest} [apiV1KmsKeysKeyIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysKeyIdPatch(keyId: string, apiV1KmsKeysKeyIdPatchRequest?: ApiV1KmsKeysKeyIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmsKeysPost200Response&gt; {
            return localVarFp.apiV1KmsKeysKeyIdPatch(keyId, apiV1KmsKeysKeyIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get KMS key by Name
         * @param {string} projectId The ID of the project the key belongs to.
         * @param {string} keyName The name of the KMS key to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysKeyNameKeyNameGet(projectId: string, keyName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmsKeysPost200Response&gt; {
            return localVarFp.apiV1KmsKeysKeyNameKeyNameGet(projectId, keyName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create KMS key
         * @param {ApiV1KmsKeysPostRequest} apiV1KmsKeysPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1KmsKeysPost(apiV1KmsKeysPostRequest: ApiV1KmsKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1KmsKeysPost200Response&gt; {
            return localVarFp.apiV1KmsKeysPost(apiV1KmsKeysPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} configId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigConfigIdGroupMapsGet(configId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV1LdapConfigConfigIdGroupMapsGet200ResponseInner&gt;&gt; {
            return localVarFp.apiV1LdapConfigConfigIdGroupMapsGet(configId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} configId 
         * @param {string} groupMapId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigConfigIdGroupMapsGroupMapIdDelete(configId: string, groupMapId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1LdapConfigConfigIdGroupMapsPost200Response&gt; {
            return localVarFp.apiV1LdapConfigConfigIdGroupMapsGroupMapIdDelete(configId, groupMapId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} configId 
         * @param {ApiV1LdapConfigConfigIdGroupMapsPostRequest} apiV1LdapConfigConfigIdGroupMapsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigConfigIdGroupMapsPost(configId: string, apiV1LdapConfigConfigIdGroupMapsPostRequest: ApiV1LdapConfigConfigIdGroupMapsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1LdapConfigConfigIdGroupMapsPost200Response&gt; {
            return localVarFp.apiV1LdapConfigConfigIdGroupMapsPost(configId, apiV1LdapConfigConfigIdGroupMapsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} configId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigConfigIdTestConnectionPost(configId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;boolean&gt; {
            return localVarFp.apiV1LdapConfigConfigIdTestConnectionPost(configId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1LdapConfigGet200Response&gt; {
            return localVarFp.apiV1LdapConfigGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1LdapConfigPatchRequest} apiV1LdapConfigPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigPatch(apiV1LdapConfigPatchRequest: ApiV1LdapConfigPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1LdapConfigPost200Response&gt; {
            return localVarFp.apiV1LdapConfigPatch(apiV1LdapConfigPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1LdapConfigPostRequest} apiV1LdapConfigPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapConfigPost(apiV1LdapConfigPostRequest: ApiV1LdapConfigPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1LdapConfigPost200Response&gt; {
            return localVarFp.apiV1LdapConfigPost(apiV1LdapConfigPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1LdapLoginPostRequest} apiV1LdapLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LdapLoginPost(apiV1LdapLoginPostRequest: ApiV1LdapLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1LdapLoginPost(apiV1LdapLoginPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationAdminProjectsGet(search?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationAdminProjectsGet200Response&gt; {
            return localVarFp.apiV1OrganizationAdminProjectsGet(search, offset, limit, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response&gt; {
            return localVarFp.apiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get all audit logs for an organization
         * @param {string} [projectId] Optionally filter logs by project ID. If not provided, logs from the entire organization will be returned.
         * @param {ApiV1OrganizationAuditLogsGetActorTypeEnum} [actorType] 
         * @param {string} [secretPath] The path of the secret to query audit logs for. Note that the projectId parameter must also be provided.
         * @param {string} [eventType] 
         * @param {ApiV1OrganizationAuditLogsGetUserAgentTypeEnum} [userAgentType] Choose which consuming application to export audit logs for.
         * @param {string} [eventMetadata] Filter by event metadata key-value pairs. Formatted as &amp;#x60;key1&amp;#x3D;value1,key2&amp;#x3D;value2&amp;#x60;, with comma-separation.
         * @param {string} [startDate] The date to start the export from.
         * @param {string} [endDate] The date to end the export at.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th audit log.
         * @param {number} [limit] The number of audit logs to return.
         * @param {string} [actor] The actor to filter the audit logs by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationAuditLogsGet(projectId?: string, actorType?: ApiV1OrganizationAuditLogsGetActorTypeEnum, secretPath?: string, eventType?: string, userAgentType?: ApiV1OrganizationAuditLogsGetUserAgentTypeEnum, eventMetadata?: string, startDate?: string, endDate?: string, offset?: number, limit?: number, actor?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationAuditLogsGet200Response&gt; {
            return localVarFp.apiV1OrganizationAuditLogsGet(projectId, actorType, secretPath, eventType, userAgentType, eventMetadata, startDate, endDate, offset, limit, actor, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationGet200Response&gt; {
            return localVarFp.apiV1OrganizationGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdGet200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId The ID of the organization to list groups for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdGroupsGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdGroupsGet200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdGroupsGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdIncidentContactOrgGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdIncidentContactOrgGet200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdIncidentContactOrgGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} incidentContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdIncidentContactOrgIncidentContactIdDelete(organizationId: string, incidentContactId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdIncidentContactOrgPost200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdIncidentContactOrgIncidentContactIdDelete(organizationId, incidentContactId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1PasswordEmailPasswordResetPostRequest} apiV1PasswordEmailPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdIncidentContactOrgPost(organizationId: string, apiV1PasswordEmailPasswordResetPostRequest: ApiV1PasswordEmailPasswordResetPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdIncidentContactOrgPost200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdIncidentContactOrgPost(organizationId, apiV1PasswordEmailPasswordResetPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdIntegrationAuthorizationsGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdIntegrationAuthorizationsGet200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdIntegrationAuthorizationsGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationOrganizationIdPatchRequest} [apiV1OrganizationOrganizationIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdPatch(organizationId: string, apiV1OrganizationOrganizationIdPatchRequest?: ApiV1OrganizationOrganizationIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdPatch200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdPatch(organizationId, apiV1OrganizationOrganizationIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdPermissionsGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdPermissionsGet200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdPermissionsGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdRolesGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdRolesGet200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdRolesGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationOrganizationIdRolesPostRequest} apiV1OrganizationOrganizationIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdRolesPost(organizationId: string, apiV1OrganizationOrganizationIdRolesPostRequest: ApiV1OrganizationOrganizationIdRolesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdRolesPost200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdRolesPost(organizationId, apiV1OrganizationOrganizationIdRolesPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdRolesRoleIdDelete(organizationId: string, roleId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdRolesPost200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdRolesRoleIdDelete(organizationId, roleId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdRolesRoleIdGet(organizationId: string, roleId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdRolesPost200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdRolesRoleIdGet(organizationId, roleId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} roleId 
         * @param {ApiV1OrganizationOrganizationIdRolesRoleIdPatchRequest} [apiV1OrganizationOrganizationIdRolesRoleIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdRolesRoleIdPatch(organizationId: string, roleId: string, apiV1OrganizationOrganizationIdRolesRoleIdPatchRequest?: ApiV1OrganizationOrganizationIdRolesRoleIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdRolesPost200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdRolesRoleIdPatch(organizationId, roleId, apiV1OrganizationOrganizationIdRolesRoleIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationOrganizationIdUsersGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdUsersGet200Response&gt; {
            return localVarFp.apiV1OrganizationOrganizationIdUsersGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdBillingDetailsGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationsOrganizationIdBillingDetailsPatchRequest} [apiV1OrganizationsOrganizationIdBillingDetailsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsPatch(organizationId: string, apiV1OrganizationsOrganizationIdBillingDetailsPatchRequest?: ApiV1OrganizationsOrganizationIdBillingDetailsPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdBillingDetailsPatch(organizationId, apiV1OrganizationsOrganizationIdBillingDetailsPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} pmtMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPmtMethodIdDelete(organizationId: string, pmtMethodId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPmtMethodIdDelete(organizationId, pmtMethodId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest} apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPost(organizationId: string, apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest: ApiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPost(organizationId, apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest} apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPost(organizationId: string, apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest: ApiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPost(organizationId, apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} taxId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsTaxIdDelete(organizationId: string, taxId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsTaxIdDelete(organizationId, taxId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdCustomerPortalSessionPost(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdCustomerPortalSessionPost(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdInvoicesGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdInvoicesGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdLicensesGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdLicensesGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdPlanBillingGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdPlanBillingGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdPlanGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationsOrganizationIdPlanGet200Response&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdPlanGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdPlanTableGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdPlanTableGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} [workspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdPlansGet(organizationId: string, workspaceId?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdPlansGet(organizationId, workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1OrganizationsOrganizationIdPlansTableGetBillingCycleEnum} billingCycle 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdPlansTableGet(billingCycle: ApiV1OrganizationsOrganizationIdPlansTableGetBillingCycleEnum, organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdPlansTableGet(billingCycle, organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationsOrganizationIdSessionTrialPostRequest} apiV1OrganizationsOrganizationIdSessionTrialPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OrganizationsOrganizationIdSessionTrialPost(organizationId: string, apiV1OrganizationsOrganizationIdSessionTrialPostRequest: ApiV1OrganizationsOrganizationIdSessionTrialPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1OrganizationsOrganizationIdSessionTrialPost(organizationId, apiV1OrganizationsOrganizationIdSessionTrialPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordBackupPrivateKeyGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PasswordBackupPrivateKeyGet200Response&gt; {
            return localVarFp.apiV1PasswordBackupPrivateKeyGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PasswordBackupPrivateKeyPostRequest} apiV1PasswordBackupPrivateKeyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordBackupPrivateKeyPost(apiV1PasswordBackupPrivateKeyPostRequest: ApiV1PasswordBackupPrivateKeyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PasswordBackupPrivateKeyGet200Response&gt; {
            return localVarFp.apiV1PasswordBackupPrivateKeyPost(apiV1PasswordBackupPrivateKeyPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PasswordChangePasswordPostRequest} apiV1PasswordChangePasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordChangePasswordPost(apiV1PasswordChangePasswordPostRequest: ApiV1PasswordChangePasswordPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV1PasswordChangePasswordPost(apiV1PasswordChangePasswordPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PasswordEmailPasswordResetPostRequest} apiV1PasswordEmailPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordEmailPasswordResetPost(apiV1PasswordEmailPasswordResetPostRequest: ApiV1PasswordEmailPasswordResetPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV1PasswordEmailPasswordResetPost(apiV1PasswordEmailPasswordResetPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PasswordEmailPasswordResetVerifyPostRequest} apiV1PasswordEmailPasswordResetVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordEmailPasswordResetVerifyPost(apiV1PasswordEmailPasswordResetVerifyPostRequest: ApiV1PasswordEmailPasswordResetVerifyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PasswordEmailPasswordResetVerifyPost200Response&gt; {
            return localVarFp.apiV1PasswordEmailPasswordResetVerifyPost(apiV1PasswordEmailPasswordResetVerifyPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordEmailPasswordSetupPost(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV1PasswordEmailPasswordSetupPost(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PasswordPasswordResetPostRequest} apiV1PasswordPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordPasswordResetPost(apiV1PasswordPasswordResetPostRequest: ApiV1PasswordPasswordResetPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV1PasswordPasswordResetPost(apiV1PasswordPasswordResetPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PasswordPasswordSetupPostRequest} apiV1PasswordPasswordSetupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordPasswordSetupPost(apiV1PasswordPasswordSetupPostRequest: ApiV1PasswordPasswordSetupPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV1PasswordPasswordSetupPost(apiV1PasswordPasswordSetupPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PasswordSrp1PostRequest} apiV1PasswordSrp1PostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PasswordSrp1Post(apiV1PasswordSrp1PostRequest: ApiV1PasswordSrp1PostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PasswordSrp1Post200Response&gt; {
            return localVarFp.apiV1PasswordSrp1Post(apiV1PasswordSrp1PostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete PKI alert
         * @param {string} alertId The ID of the alert to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiAlertsAlertIdDelete(alertId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiAlertsPost200Response&gt; {
            return localVarFp.apiV1PkiAlertsAlertIdDelete(alertId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get PKI alert
         * @param {string} alertId The ID of the alert to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiAlertsAlertIdGet(alertId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiAlertsPost200Response&gt; {
            return localVarFp.apiV1PkiAlertsAlertIdGet(alertId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update PKI alert
         * @param {string} alertId The ID of the alert to update.
         * @param {ApiV1PkiAlertsAlertIdPatchRequest} [apiV1PkiAlertsAlertIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiAlertsAlertIdPatch(alertId: string, apiV1PkiAlertsAlertIdPatchRequest?: ApiV1PkiAlertsAlertIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiAlertsPost200Response&gt; {
            return localVarFp.apiV1PkiAlertsAlertIdPatch(alertId, apiV1PkiAlertsAlertIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create PKI alert
         * @param {ApiV1PkiAlertsPostRequest} apiV1PkiAlertsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiAlertsPost(apiV1PkiAlertsPostRequest: ApiV1PkiAlertsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiAlertsPost200Response&gt; {
            return localVarFp.apiV1PkiAlertsPost(apiV1PkiAlertsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get list of past and current CA certificates for a CA
         * @param {string} caId The ID of the CA to get the CA certificates for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdCaCertificatesGet(caId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV1PkiCaCaIdCaCertificatesGet200ResponseInner&gt;&gt; {
            return localVarFp.apiV1PkiCaCaIdCaCertificatesGet(caId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get current CA cert and cert chain of a CA
         * @param {string} caId The ID of the CA to get the certificate body and certificate chain from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdCertificateGet(caId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaCaIdCertificateGet200Response&gt; {
            return localVarFp.apiV1PkiCaCaIdCertificateGet(caId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get list of certificate templates for the CA
         * @param {string} caId The ID of the CA to issue the certificate from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdCertificateTemplatesGet(caId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaCaIdCertificateTemplatesGet200Response&gt; {
            return localVarFp.apiV1PkiCaCaIdCertificateTemplatesGet(caId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get DER-encoded certificate of CA
         * @param {string} caId The ID of the CA to get the CA certificate from.
         * @param {string} caCertId The ID of the CA certificate to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdCertificatesCaCertIdDerGet(caId: string, caCertId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1PkiCaCaIdCertificatesCaCertIdDerGet(caId, caCertId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get list of CRLs of the CA
         * @param {string} caId The ID of the CA to get the certificate revocation lists (CRLs) for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdCrlsGet(caId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV1PkiCaCaIdCrlsGet200ResponseInner&gt;&gt; {
            return localVarFp.apiV1PkiCaCaIdCrlsGet(caId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get CA CSR
         * @param {string} caId The ID of the CA to generate CSR from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdCsrGet(caId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaCaIdCsrGet200Response&gt; {
            return localVarFp.apiV1PkiCaCaIdCsrGet(caId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete CA
         * @param {string} caId The ID of the CA to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdDelete(caId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaPost200Response&gt; {
            return localVarFp.apiV1PkiCaCaIdDelete(caId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get CA
         * @param {string} caId The ID of the CA to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdGet(caId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaPost200Response&gt; {
            return localVarFp.apiV1PkiCaCaIdGet(caId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Import certificate and chain to CA
         * @param {string} caId The ID of the CA to import the certificate for.
         * @param {ApiV1PkiCaCaIdImportCertificatePostRequest} apiV1PkiCaCaIdImportCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdImportCertificatePost(caId: string, apiV1PkiCaCaIdImportCertificatePostRequest: ApiV1PkiCaCaIdImportCertificatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaCaIdImportCertificatePost200Response&gt; {
            return localVarFp.apiV1PkiCaCaIdImportCertificatePost(caId, apiV1PkiCaCaIdImportCertificatePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Issue certificate from CA
         * @param {string} caId The ID of the CA to issue the certificate from.
         * @param {ApiV1PkiCaCaIdIssueCertificatePostRequest} apiV1PkiCaCaIdIssueCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdIssueCertificatePost(caId: string, apiV1PkiCaCaIdIssueCertificatePostRequest: ApiV1PkiCaCaIdIssueCertificatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaCaIdIssueCertificatePost200Response&gt; {
            return localVarFp.apiV1PkiCaCaIdIssueCertificatePost(caId, apiV1PkiCaCaIdIssueCertificatePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update CA
         * @param {string} caId The ID of the CA to update.
         * @param {ApiV1PkiCaCaIdPatchRequest} [apiV1PkiCaCaIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdPatch(caId: string, apiV1PkiCaCaIdPatchRequest?: ApiV1PkiCaCaIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaPost200Response&gt; {
            return localVarFp.apiV1PkiCaCaIdPatch(caId, apiV1PkiCaCaIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Perform CA certificate renewal
         * @param {string} caId The ID of the CA to renew the CA certificate for.
         * @param {ApiV1PkiCaCaIdRenewPostRequest} apiV1PkiCaCaIdRenewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdRenewPost(caId: string, apiV1PkiCaCaIdRenewPostRequest: ApiV1PkiCaCaIdRenewPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaCaIdRenewPost200Response&gt; {
            return localVarFp.apiV1PkiCaCaIdRenewPost(caId, apiV1PkiCaCaIdRenewPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Sign certificate from CA
         * @param {string} caId The ID of the CA to issue the certificate from.
         * @param {ApiV1PkiCaCaIdSignCertificatePostRequest} apiV1PkiCaCaIdSignCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdSignCertificatePost(caId: string, apiV1PkiCaCaIdSignCertificatePostRequest: ApiV1PkiCaCaIdSignCertificatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaCaIdSignCertificatePost200Response&gt; {
            return localVarFp.apiV1PkiCaCaIdSignCertificatePost(caId, apiV1PkiCaCaIdSignCertificatePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create intermediate CA certificate from parent CA
         * @param {string} caId The ID of the CA to sign the intermediate certificate with.
         * @param {ApiV1PkiCaCaIdSignIntermediatePostRequest} apiV1PkiCaCaIdSignIntermediatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaCaIdSignIntermediatePost(caId: string, apiV1PkiCaCaIdSignIntermediatePostRequest: ApiV1PkiCaCaIdSignIntermediatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaCaIdSignIntermediatePost200Response&gt; {
            return localVarFp.apiV1PkiCaCaIdSignIntermediatePost(caId, apiV1PkiCaCaIdSignIntermediatePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create CA
         * @param {ApiV1PkiCaPostRequest} apiV1PkiCaPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCaPost(apiV1PkiCaPostRequest: ApiV1PkiCaPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaPost200Response&gt; {
            return localVarFp.apiV1PkiCaPost(apiV1PkiCaPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the certificate template to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesCertificateTemplateIdDelete(certificateTemplateId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdGet200Response&gt; {
            return localVarFp.apiV1PkiCertificateTemplatesCertificateTemplateIdDelete(certificateTemplateId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get Certificate Template EST configuration
         * @param {string} certificateTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigGet(certificateTemplateId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigGet200Response&gt; {
            return localVarFp.apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigGet(certificateTemplateId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update Certificate Template EST configuration
         * @param {string} certificateTemplateId 
         * @param {ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest} [apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatch(certificateTemplateId: string, apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest?: ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPost200Response&gt; {
            return localVarFp.apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatch(certificateTemplateId, apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create Certificate Template EST configuration
         * @param {string} certificateTemplateId 
         * @param {ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest} apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPost(certificateTemplateId: string, apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest: ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPost200Response&gt; {
            return localVarFp.apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPost(certificateTemplateId, apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the certificate template to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesCertificateTemplateIdGet(certificateTemplateId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdGet200Response&gt; {
            return localVarFp.apiV1PkiCertificateTemplatesCertificateTemplateIdGet(certificateTemplateId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the certificate template to update.
         * @param {ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest} [apiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesCertificateTemplateIdPatch(certificateTemplateId: string, apiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest?: ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdGet200Response&gt; {
            return localVarFp.apiV1PkiCertificateTemplatesCertificateTemplateIdPatch(certificateTemplateId, apiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PkiCertificateTemplatesPostRequest} apiV1PkiCertificateTemplatesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificateTemplatesPost(apiV1PkiCertificateTemplatesPostRequest: ApiV1PkiCertificateTemplatesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdGet200Response&gt; {
            return localVarFp.apiV1PkiCertificateTemplatesPost(apiV1PkiCertificateTemplatesPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Issue certificate
         * @param {ApiV1PkiCertificatesIssueCertificatePostRequest} apiV1PkiCertificatesIssueCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificatesIssueCertificatePost(apiV1PkiCertificatesIssueCertificatePostRequest: ApiV1PkiCertificatesIssueCertificatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaCaIdIssueCertificatePost200Response&gt; {
            return localVarFp.apiV1PkiCertificatesIssueCertificatePost(apiV1PkiCertificatesIssueCertificatePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get certificate body of certificate
         * @param {string} serialNumber The serial number of the certificate to get the certificate body and certificate chain for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificatesSerialNumberCertificateGet(serialNumber: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCertificatesSerialNumberCertificateGet200Response&gt; {
            return localVarFp.apiV1PkiCertificatesSerialNumberCertificateGet(serialNumber, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete certificate
         * @param {string} serialNumber The serial number of the certificate to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificatesSerialNumberDelete(serialNumber: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCertificatesSerialNumberGet200Response&gt; {
            return localVarFp.apiV1PkiCertificatesSerialNumberDelete(serialNumber, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get certificate
         * @param {string} serialNumber The serial number of the certificate to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificatesSerialNumberGet(serialNumber: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCertificatesSerialNumberGet200Response&gt; {
            return localVarFp.apiV1PkiCertificatesSerialNumberGet(serialNumber, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Revoke
         * @param {string} serialNumber The serial number of the certificate to revoke. The revoked certificate will be added to the certificate revocation list (CRL) of the CA.
         * @param {ApiV1PkiCertificatesSerialNumberRevokePostRequest} apiV1PkiCertificatesSerialNumberRevokePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificatesSerialNumberRevokePost(serialNumber: string, apiV1PkiCertificatesSerialNumberRevokePostRequest: ApiV1PkiCertificatesSerialNumberRevokePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCertificatesSerialNumberRevokePost200Response&gt; {
            return localVarFp.apiV1PkiCertificatesSerialNumberRevokePost(serialNumber, apiV1PkiCertificatesSerialNumberRevokePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Sign certificate
         * @param {ApiV1PkiCertificatesSignCertificatePostRequest} apiV1PkiCertificatesSignCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCertificatesSignCertificatePost(apiV1PkiCertificatesSignCertificatePostRequest: ApiV1PkiCertificatesSignCertificatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCaCaIdSignCertificatePost200Response&gt; {
            return localVarFp.apiV1PkiCertificatesSignCertificatePost(apiV1PkiCertificatesSignCertificatePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete PKI collection
         * @param {string} collectionId The ID of the PKI collection to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsCollectionIdDelete(collectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCollectionsPost200Response&gt; {
            return localVarFp.apiV1PkiCollectionsCollectionIdDelete(collectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get PKI collection
         * @param {string} collectionId The ID of the PKI collection to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsCollectionIdGet(collectionId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCollectionsPost200Response&gt; {
            return localVarFp.apiV1PkiCollectionsCollectionIdGet(collectionId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove item from PKI collection
         * @param {string} collectionId The ID of the PKI collection to delete the item from.
         * @param {string} collectionItemId The ID of the PKI collection item to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete(collectionId: string, collectionItemId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete200Response&gt; {
            return localVarFp.apiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete(collectionId, collectionItemId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get items in PKI collection
         * @param {string} collectionId The ID of the PKI collection to list items from.
         * @param {ApiV1PkiCollectionsCollectionIdItemsGetTypeEnum} [type] The type of the PKI collection item to list.
         * @param {number} [offset] The offset to start from.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsCollectionIdItemsGet(collectionId: string, type?: ApiV1PkiCollectionsCollectionIdItemsGetTypeEnum, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCollectionsCollectionIdItemsGet200Response&gt; {
            return localVarFp.apiV1PkiCollectionsCollectionIdItemsGet(collectionId, type, offset, limit, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Add item to PKI collection
         * @param {string} collectionId The ID of the PKI collection to add the item to.
         * @param {ApiV1PkiCollectionsCollectionIdItemsPostRequest} apiV1PkiCollectionsCollectionIdItemsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsCollectionIdItemsPost(collectionId: string, apiV1PkiCollectionsCollectionIdItemsPostRequest: ApiV1PkiCollectionsCollectionIdItemsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCollectionsCollectionIdItemsPost200Response&gt; {
            return localVarFp.apiV1PkiCollectionsCollectionIdItemsPost(collectionId, apiV1PkiCollectionsCollectionIdItemsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update PKI collection
         * @param {string} collectionId The ID of the PKI collection to update.
         * @param {ApiV1PkiCollectionsCollectionIdPatchRequest} [apiV1PkiCollectionsCollectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsCollectionIdPatch(collectionId: string, apiV1PkiCollectionsCollectionIdPatchRequest?: ApiV1PkiCollectionsCollectionIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCollectionsPost200Response&gt; {
            return localVarFp.apiV1PkiCollectionsCollectionIdPatch(collectionId, apiV1PkiCollectionsCollectionIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create PKI collection
         * @param {ApiV1PkiCollectionsPostRequest} apiV1PkiCollectionsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCollectionsPost(apiV1PkiCollectionsPostRequest: ApiV1PkiCollectionsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PkiCollectionsPost200Response&gt; {
            return localVarFp.apiV1PkiCollectionsPost(apiV1PkiCollectionsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get CRL in DER format
         * @param {string} crlId The ID of the certificate revocation list (CRL) to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCrlCrlIdDerGet(crlId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1PkiCrlCrlIdDerGet(crlId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get CRL in DER format (deprecated)
         * @param {string} crlId The ID of the certificate revocation list (CRL) to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PkiCrlCrlIdGet(crlId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV1PkiCrlCrlIdGet(crlId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List project templates for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProjectTemplatesGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ProjectTemplatesGet200Response&gt; {
            return localVarFp.apiV1ProjectTemplatesGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a project template.
         * @param {ApiV1ProjectTemplatesPostRequest} apiV1ProjectTemplatesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProjectTemplatesPost(apiV1ProjectTemplatesPostRequest: ApiV1ProjectTemplatesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ProjectTemplatesPost200Response&gt; {
            return localVarFp.apiV1ProjectTemplatesPost(apiV1ProjectTemplatesPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete a project template.
         * @param {string} templateId The ID of the project template to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProjectTemplatesTemplateIdDelete(templateId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ProjectTemplatesPost200Response&gt; {
            return localVarFp.apiV1ProjectTemplatesTemplateIdDelete(templateId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get a project template by ID.
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProjectTemplatesTemplateIdGet(templateId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ProjectTemplatesPost200Response&gt; {
            return localVarFp.apiV1ProjectTemplatesTemplateIdGet(templateId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update a project template.
         * @param {string} templateId The ID of the project template to be updated.
         * @param {ApiV1ProjectTemplatesTemplateIdPatchRequest} [apiV1ProjectTemplatesTemplateIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ProjectTemplatesTemplateIdPatch(templateId: string, apiV1ProjectTemplatesTemplateIdPatchRequest?: ApiV1ProjectTemplatesTemplateIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ProjectTemplatesPost200Response&gt; {
            return localVarFp.apiV1ProjectTemplatesTemplateIdPatch(templateId, apiV1ProjectTemplatesTemplateIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RateLimitGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1RateLimitGet200Response&gt; {
            return localVarFp.apiV1RateLimitGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1RateLimitPutRequest} apiV1RateLimitPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RateLimitPut(apiV1RateLimitPutRequest: ApiV1RateLimitPutRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1RateLimitGet200Response&gt; {
            return localVarFp.apiV1RateLimitPut(apiV1RateLimitPutRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {number} [startIndex] 
         * @param {number} [count] 
         * @param {string} [filter] 
         * @param {string} [excludedAttributes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimGroupsGet(startIndex?: number, count?: number, filter?: string, excludedAttributes?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ScimGroupsGet200Response&gt; {
            return localVarFp.apiV1ScimGroupsGet(startIndex, count, filter, excludedAttributes, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimGroupsGroupIdDelete(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;object&gt; {
            return localVarFp.apiV1ScimGroupsGroupIdDelete(groupId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimGroupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ScimGroupsGet200ResponseResourcesInner&gt; {
            return localVarFp.apiV1ScimGroupsGroupIdGet(groupId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ApiV1ScimUsersOrgMembershipIdPatchRequest} apiV1ScimUsersOrgMembershipIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimGroupsGroupIdPatch(groupId: string, apiV1ScimUsersOrgMembershipIdPatchRequest: ApiV1ScimUsersOrgMembershipIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ScimGroupsGet200ResponseResourcesInner&gt; {
            return localVarFp.apiV1ScimGroupsGroupIdPatch(groupId, apiV1ScimUsersOrgMembershipIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ApiV1ScimGroupsGroupIdPutRequest} apiV1ScimGroupsGroupIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimGroupsGroupIdPut(groupId: string, apiV1ScimGroupsGroupIdPutRequest: ApiV1ScimGroupsGroupIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ScimGroupsGet200ResponseResourcesInner&gt; {
            return localVarFp.apiV1ScimGroupsGroupIdPut(groupId, apiV1ScimGroupsGroupIdPutRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ScimGroupsPostRequest} apiV1ScimGroupsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimGroupsPost(apiV1ScimGroupsPostRequest: ApiV1ScimGroupsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ScimGroupsGet200ResponseResourcesInner&gt; {
            return localVarFp.apiV1ScimGroupsPost(apiV1ScimGroupsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimScimTokensGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ScimScimTokensGet200Response&gt; {
            return localVarFp.apiV1ScimScimTokensGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ScimScimTokensPostRequest} apiV1ScimScimTokensPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimScimTokensPost(apiV1ScimScimTokensPostRequest: ApiV1ScimScimTokensPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ScimScimTokensPost200Response&gt; {
            return localVarFp.apiV1ScimScimTokensPost(apiV1ScimScimTokensPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} scimTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimScimTokensScimTokenIdDelete(scimTokenId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ScimScimTokensScimTokenIdDelete200Response&gt; {
            return localVarFp.apiV1ScimScimTokensScimTokenIdDelete(scimTokenId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {number} [startIndex] 
         * @param {number} [count] 
         * @param {string} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimUsersGet(startIndex?: number, count?: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ScimUsersGet200Response&gt; {
            return localVarFp.apiV1ScimUsersGet(startIndex, count, filter, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgMembershipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimUsersOrgMembershipIdDelete(orgMembershipId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;object&gt; {
            return localVarFp.apiV1ScimUsersOrgMembershipIdDelete(orgMembershipId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgMembershipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimUsersOrgMembershipIdGet(orgMembershipId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ScimUsersGet200ResponseResourcesInner&gt; {
            return localVarFp.apiV1ScimUsersOrgMembershipIdGet(orgMembershipId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgMembershipId 
         * @param {ApiV1ScimUsersOrgMembershipIdPatchRequest} apiV1ScimUsersOrgMembershipIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimUsersOrgMembershipIdPatch(orgMembershipId: string, apiV1ScimUsersOrgMembershipIdPatchRequest: ApiV1ScimUsersOrgMembershipIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ScimUsersGet200ResponseResourcesInner&gt; {
            return localVarFp.apiV1ScimUsersOrgMembershipIdPatch(orgMembershipId, apiV1ScimUsersOrgMembershipIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgMembershipId 
         * @param {ApiV1ScimUsersOrgMembershipIdPutRequest} apiV1ScimUsersOrgMembershipIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimUsersOrgMembershipIdPut(orgMembershipId: string, apiV1ScimUsersOrgMembershipIdPutRequest: ApiV1ScimUsersOrgMembershipIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ScimUsersOrgMembershipIdPut200Response&gt; {
            return localVarFp.apiV1ScimUsersOrgMembershipIdPut(orgMembershipId, apiV1ScimUsersOrgMembershipIdPutRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ScimUsersPostRequest} apiV1ScimUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ScimUsersPost(apiV1ScimUsersPostRequest: ApiV1ScimUsersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1ScimUsersGet200ResponseResourcesInner&gt; {
            return localVarFp.apiV1ScimUsersPost(apiV1ScimUsersPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalRequestsCountGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalRequestsCountGet200Response&gt; {
            return localVarFp.apiV1SecretApprovalRequestsCountGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [environment] 
         * @param {string} [committer] 
         * @param {ApiV1SecretApprovalRequestsGetStatusEnum} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalRequestsGet(workspaceId: string, environment?: string, committer?: string, status?: ApiV1SecretApprovalRequestsGetStatusEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalRequestsGet200Response&gt; {
            return localVarFp.apiV1SecretApprovalRequestsGet(workspaceId, environment, committer, status, limit, offset, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalRequestsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalRequestsIdGet200Response&gt; {
            return localVarFp.apiV1SecretApprovalRequestsIdGet(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretApprovalRequestsIdMergePostRequest} [apiV1SecretApprovalRequestsIdMergePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalRequestsIdMergePost(id: string, apiV1SecretApprovalRequestsIdMergePostRequest?: ApiV1SecretApprovalRequestsIdMergePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalRequestsIdMergePost200Response&gt; {
            return localVarFp.apiV1SecretApprovalRequestsIdMergePost(id, apiV1SecretApprovalRequestsIdMergePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretApprovalRequestsIdReviewPostRequest} apiV1SecretApprovalRequestsIdReviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalRequestsIdReviewPost(id: string, apiV1SecretApprovalRequestsIdReviewPostRequest: ApiV1SecretApprovalRequestsIdReviewPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalRequestsIdReviewPost200Response&gt; {
            return localVarFp.apiV1SecretApprovalRequestsIdReviewPost(id, apiV1SecretApprovalRequestsIdReviewPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretApprovalRequestsIdStatusPostRequest} apiV1SecretApprovalRequestsIdStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalRequestsIdStatusPost(id: string, apiV1SecretApprovalRequestsIdStatusPostRequest: ApiV1SecretApprovalRequestsIdStatusPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalRequestsIdMergePost200Response&gt; {
            return localVarFp.apiV1SecretApprovalRequestsIdStatusPost(id, apiV1SecretApprovalRequestsIdStatusPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} secretPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalsBoardGet(workspaceId: string, environment: string, secretPath: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalsBoardGet200Response&gt; {
            return localVarFp.apiV1SecretApprovalsBoardGet(workspaceId, environment, secretPath, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalsGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalsGet200Response&gt; {
            return localVarFp.apiV1SecretApprovalsGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SecretApprovalsPostRequest} apiV1SecretApprovalsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalsPost(apiV1SecretApprovalsPostRequest: ApiV1SecretApprovalsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalsPost200Response&gt; {
            return localVarFp.apiV1SecretApprovalsPost(apiV1SecretApprovalsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} sapId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalsSapIdDelete(sapId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalsPost200Response&gt; {
            return localVarFp.apiV1SecretApprovalsSapIdDelete(sapId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} sapId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalsSapIdGet(sapId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalsSapIdGet200Response&gt; {
            return localVarFp.apiV1SecretApprovalsSapIdGet(sapId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} sapId 
         * @param {ApiV1SecretApprovalsSapIdPatchRequest} apiV1SecretApprovalsSapIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretApprovalsSapIdPatch(sapId: string, apiV1SecretApprovalsSapIdPatchRequest: ApiV1SecretApprovalsSapIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretApprovalsPost200Response&gt; {
            return localVarFp.apiV1SecretApprovalsSapIdPatch(sapId, apiV1SecretApprovalsSapIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get secret imports
         * @param {string} workspaceId The ID of the project to list secret imports from.
         * @param {string} environment The slug of the environment to list secret imports from.
         * @param {string} [path] The path to list secret imports from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsGet(workspaceId: string, environment: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretImportsGet200Response&gt; {
            return localVarFp.apiV1SecretImportsGet(workspaceId, environment, path, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create secret imports
         * @param {ApiV1SecretImportsPostRequest} apiV1SecretImportsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsPost(apiV1SecretImportsPostRequest: ApiV1SecretImportsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretImportsPost200Response&gt; {
            return localVarFp.apiV1SecretImportsPost(apiV1SecretImportsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete secret imports
         * @param {string} secretImportId The ID of the secret import to delete.
         * @param {ApiV1SecretImportsSecretImportIdDeleteRequest} apiV1SecretImportsSecretImportIdDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsSecretImportIdDelete(secretImportId: string, apiV1SecretImportsSecretImportIdDeleteRequest: ApiV1SecretImportsSecretImportIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretImportsPost200Response&gt; {
            return localVarFp.apiV1SecretImportsSecretImportIdDelete(secretImportId, apiV1SecretImportsSecretImportIdDeleteRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get single secret import
         * @param {string} secretImportId The ID of the secret import to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsSecretImportIdGet(secretImportId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretImportsSecretImportIdGet200Response&gt; {
            return localVarFp.apiV1SecretImportsSecretImportIdGet(secretImportId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update secret imports
         * @param {string} secretImportId The ID of the secret import to update.
         * @param {ApiV1SecretImportsSecretImportIdPatchRequest} apiV1SecretImportsSecretImportIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsSecretImportIdPatch(secretImportId: string, apiV1SecretImportsSecretImportIdPatchRequest: ApiV1SecretImportsSecretImportIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretImportsPost200Response&gt; {
            return localVarFp.apiV1SecretImportsSecretImportIdPatch(secretImportId, apiV1SecretImportsSecretImportIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Resync secret replication of secret imports
         * @param {string} secretImportId The ID of the secret import to update.
         * @param {ApiV1SecretImportsSecretImportIdReplicationResyncPostRequest} apiV1SecretImportsSecretImportIdReplicationResyncPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsSecretImportIdReplicationResyncPost(secretImportId: string, apiV1SecretImportsSecretImportIdReplicationResyncPostRequest: ApiV1SecretImportsSecretImportIdReplicationResyncPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV1SecretImportsSecretImportIdReplicationResyncPost(secretImportId, apiV1SecretImportsSecretImportIdReplicationResyncPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsSecretsGet(workspaceId: string, environment: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretImportsSecretsGet200Response&gt; {
            return localVarFp.apiV1SecretImportsSecretsGet(workspaceId, environment, path, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretImportsSecretsRawGet(workspaceId: string, environment: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretImportsSecretsRawGet200Response&gt; {
            return localVarFp.apiV1SecretImportsSecretsRawGet(workspaceId, environment, path, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretRotationProvidersWorkspaceIdGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretRotationProvidersWorkspaceIdGet200Response&gt; {
            return localVarFp.apiV1SecretRotationProvidersWorkspaceIdGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretRotationsGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretRotationsGet200Response&gt; {
            return localVarFp.apiV1SecretRotationsGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretRotationsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretRotationsRestartPost200Response&gt; {
            return localVarFp.apiV1SecretRotationsIdDelete(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SecretRotationsPostRequest} apiV1SecretRotationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretRotationsPost(apiV1SecretRotationsPostRequest: ApiV1SecretRotationsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretRotationsPost200Response&gt; {
            return localVarFp.apiV1SecretRotationsPost(apiV1SecretRotationsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretRotationsRestartPost(apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretRotationsRestartPost200Response&gt; {
            return localVarFp.apiV1SecretRotationsRestartPost(apiV1SecretRotationsRestartPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest} apiV1SecretScanningCreateInstallationSessionOrganizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretScanningCreateInstallationSessionOrganizationPost(apiV1SecretScanningCreateInstallationSessionOrganizationPostRequest: ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretScanningCreateInstallationSessionOrganizationPost200Response&gt; {
            return localVarFp.apiV1SecretScanningCreateInstallationSessionOrganizationPost(apiV1SecretScanningCreateInstallationSessionOrganizationPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet200Response&gt; {
            return localVarFp.apiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SecretScanningLinkInstallationPostRequest} apiV1SecretScanningLinkInstallationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretScanningLinkInstallationPost(apiV1SecretScanningLinkInstallationPostRequest: ApiV1SecretScanningLinkInstallationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretScanningLinkInstallationPost200Response&gt; {
            return localVarFp.apiV1SecretScanningLinkInstallationPost(apiV1SecretScanningLinkInstallationPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string | null} [repositoryNames] 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksExportGetResolvedStatusEnum} [resolvedStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretScanningOrganizationOrganizationIdRisksExportGet(organizationId: string, repositoryNames?: string | null, resolvedStatus?: ApiV1SecretScanningOrganizationOrganizationIdRisksExportGetResolvedStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretScanningOrganizationOrganizationIdRisksExportGet200Response&gt; {
            return localVarFp.apiV1SecretScanningOrganizationOrganizationIdRisksExportGet(organizationId, repositoryNames, resolvedStatus, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderByEnum} [orderBy] 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderDirectionEnum} [orderDirection] 
         * @param {string | null} [repositoryNames] 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksGetResolvedStatusEnum} [resolvedStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretScanningOrganizationOrganizationIdRisksGet(organizationId: string, offset?: number, limit?: number, orderBy?: ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderByEnum, orderDirection?: ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderDirectionEnum, repositoryNames?: string | null, resolvedStatus?: ApiV1SecretScanningOrganizationOrganizationIdRisksGetResolvedStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretScanningOrganizationOrganizationIdRisksGet200Response&gt; {
            return localVarFp.apiV1SecretScanningOrganizationOrganizationIdRisksGet(organizationId, offset, limit, orderBy, orderDirection, repositoryNames, resolvedStatus, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} riskId 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest} apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPost(organizationId: string, riskId: string, apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest: ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretScanningOrganizationOrganizationIdRisksExportGet200ResponseRisksInner&gt; {
            return localVarFp.apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPost(organizationId, riskId, apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {number} offset 
         * @param {number} limit 
         * @param {string} secretId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSecretIdSecretVersionsGet(offset: number, limit: number, secretId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSecretIdSecretVersionsGet200Response&gt; {
            return localVarFp.apiV1SecretSecretIdSecretVersionsGet(offset, limit, secretId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingRequestsGet(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSharingSharedGet200Response&gt; {
            return localVarFp.apiV1SecretSharingRequestsGet(offset, limit, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingRequestsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSharingRequestsIdDelete200Response&gt; {
            return localVarFp.apiV1SecretSharingRequestsIdDelete(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingRequestsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSharingRequestsIdGet200Response&gt; {
            return localVarFp.apiV1SecretSharingRequestsIdGet(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingRequestsIdRevealValuePost(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSharingRequestsIdRevealValuePost200Response&gt; {
            return localVarFp.apiV1SecretSharingRequestsIdRevealValuePost(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretSharingRequestsIdSetValuePostRequest} apiV1SecretSharingRequestsIdSetValuePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingRequestsIdSetValuePost(id: string, apiV1SecretSharingRequestsIdSetValuePostRequest: ApiV1SecretSharingRequestsIdSetValuePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSharingRequestsIdDelete200Response&gt; {
            return localVarFp.apiV1SecretSharingRequestsIdSetValuePost(id, apiV1SecretSharingRequestsIdSetValuePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SecretSharingRequestsPostRequest} apiV1SecretSharingRequestsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingRequestsPost(apiV1SecretSharingRequestsPostRequest: ApiV1SecretSharingRequestsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretRotationsRestartPostRequest&gt; {
            return localVarFp.apiV1SecretSharingRequestsPost(apiV1SecretSharingRequestsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingSharedGet(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSharingSharedGet200Response&gt; {
            return localVarFp.apiV1SecretSharingSharedGet(offset, limit, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SecretSharingSharedPostRequest} apiV1SecretSharingSharedPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingSharedPost(apiV1SecretSharingSharedPostRequest: ApiV1SecretSharingSharedPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretRotationsRestartPostRequest&gt; {
            return localVarFp.apiV1SecretSharingSharedPost(apiV1SecretSharingSharedPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretSharingSharedPublicIdPostRequest} [apiV1SecretSharingSharedPublicIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingSharedPublicIdPost(id: string, apiV1SecretSharingSharedPublicIdPostRequest?: ApiV1SecretSharingSharedPublicIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSharingSharedPublicIdPost200Response&gt; {
            return localVarFp.apiV1SecretSharingSharedPublicIdPost(id, apiV1SecretSharingSharedPublicIdPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SecretSharingSharedPublicPostRequest} apiV1SecretSharingSharedPublicPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingSharedPublicPost(apiV1SecretSharingSharedPublicPostRequest: ApiV1SecretSharingSharedPublicPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretRotationsRestartPostRequest&gt; {
            return localVarFp.apiV1SecretSharingSharedPublicPost(apiV1SecretSharingSharedPublicPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} sharedSecretId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSharingSharedSharedSecretIdDelete(sharedSecretId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSharingSharedGet200ResponseSecretsInner&gt; {
            return localVarFp.apiV1SecretSharingSharedSharedSecretIdDelete(sharedSecretId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} secretSnapshotId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSnapshotSecretSnapshotIdGet(secretSnapshotId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSnapshotSecretSnapshotIdGet200Response&gt; {
            return localVarFp.apiV1SecretSnapshotSecretSnapshotIdGet(secretSnapshotId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Roll back project secrets to those captured in a secret snapshot version.
         * @param {string} secretSnapshotId The ID of the snapshot to rollback to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSnapshotSecretSnapshotIdRollbackPost(secretSnapshotId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSnapshotSecretSnapshotIdRollbackPost200Response&gt; {
            return localVarFp.apiV1SecretSnapshotSecretSnapshotIdRollbackPost(secretSnapshotId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the AWS Parameter Store Syncs for the specified project.
         * @param {string} projectId The ID of the project to list AWS Parameter Store Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStoreGet200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsParameterStoreGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create an AWS Parameter Store Sync for the specified project environment.
         * @param {ApiV1SecretSyncsAwsParameterStorePostRequest} apiV1SecretSyncsAwsParameterStorePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStorePost(apiV1SecretSyncsAwsParameterStorePostRequest: ApiV1SecretSyncsAwsParameterStorePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsParameterStorePost(apiV1SecretSyncsAwsParameterStorePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified AWS Parameter Store Sync.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to be deleted.
         * @param {ApiV1SecretSyncsAwsParameterStoreSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsAwsParameterStoreSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsParameterStoreSyncIdDelete(syncId, removeSecrets, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified AWS Parameter Store Sync by ID.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsParameterStoreSyncIdGet(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Import secrets from the specified AWS Parameter Store Sync destination.
         * @param {ApiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or AWS Parameter Store.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPost(importBehavior, syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified AWS Parameter Store Sync.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to be updated.
         * @param {ApiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest} [apiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncIdPatch(syncId: string, apiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest?: ApiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsParameterStoreSyncIdPatch(syncId, apiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove previously synced secrets from the specified AWS Parameter Store Sync destination.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsParameterStoreSyncIdRemoveSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Trigger a sync for the specified AWS Parameter Store Sync.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsParameterStoreSyncIdSyncSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified AWS Parameter Store Sync by name and project ID.
         * @param {string} projectId The ID of the project the AWS Parameter Store Sync is associated with.
         * @param {string} syncName The name of the AWS Parameter Store Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsParameterStoreSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsParameterStoreSyncNameSyncNameGet(projectId, syncName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the AWS Secrets Manager Syncs for the specified project.
         * @param {string} projectId The ID of the project to list AWS Secrets Manager Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerGet200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsSecretsManagerGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create an AWS Secrets Manager Sync for the specified project environment.
         * @param {ApiV1SecretSyncsAwsSecretsManagerPostRequest} apiV1SecretSyncsAwsSecretsManagerPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerPost(apiV1SecretSyncsAwsSecretsManagerPostRequest: ApiV1SecretSyncsAwsSecretsManagerPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsSecretsManagerPost(apiV1SecretSyncsAwsSecretsManagerPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified AWS Secrets Manager Sync.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to be deleted.
         * @param {ApiV1SecretSyncsAwsSecretsManagerSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsAwsSecretsManagerSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsSecretsManagerSyncIdDelete(syncId, removeSecrets, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified AWS Secrets Manager Sync by ID.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsSecretsManagerSyncIdGet(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Import secrets from the specified AWS Secrets Manager Sync destination.
         * @param {ApiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or AWS Secrets Manager.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPost(importBehavior, syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified AWS Secrets Manager Sync.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to be updated.
         * @param {ApiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest} [apiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncIdPatch(syncId: string, apiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest?: ApiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsSecretsManagerSyncIdPatch(syncId, apiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove previously synced secrets from the specified AWS Secrets Manager Sync destination.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsSecretsManagerSyncIdRemoveSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Trigger a sync for the specified AWS Secrets Manager Sync.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsSecretsManagerSyncIdSyncSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified AWS Secrets Manager Sync by name and project ID.
         * @param {string} projectId The ID of the project the AWS Secrets Manager Sync is associated with.
         * @param {string} syncName The name of the AWS Secrets Manager Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAwsSecretsManagerSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAwsSecretsManagerSyncNameSyncNameGet(projectId, syncName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the Azure App Configuration Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Azure App Configuration Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationGet200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureAppConfigurationGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create an Azure App Configuration Sync for the specified project environment.
         * @param {ApiV1SecretSyncsAzureAppConfigurationPostRequest} apiV1SecretSyncsAzureAppConfigurationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationPost(apiV1SecretSyncsAzureAppConfigurationPostRequest: ApiV1SecretSyncsAzureAppConfigurationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureAppConfigurationPost(apiV1SecretSyncsAzureAppConfigurationPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified Azure App Configuration Sync.
         * @param {string} syncId The ID of the Azure App Configuration Sync to be deleted.
         * @param {ApiV1SecretSyncsAzureAppConfigurationSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsAzureAppConfigurationSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureAppConfigurationSyncIdDelete(syncId, removeSecrets, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Azure App Configuration Sync by ID.
         * @param {string} syncId The ID of the Azure App Configuration Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureAppConfigurationSyncIdGet(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Import secrets from the specified Azure App Configuration Sync destination.
         * @param {ApiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or Azure App Configuration.
         * @param {string} syncId The ID of the Azure App Configuration Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPost(importBehavior, syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified Azure App Configuration Sync.
         * @param {string} syncId The ID of the Azure App Configuration Sync to be updated.
         * @param {ApiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest} [apiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncIdPatch(syncId: string, apiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest?: ApiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureAppConfigurationSyncIdPatch(syncId, apiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove previously synced secrets from the specified Azure App Configuration Sync destination.
         * @param {string} syncId The ID of the Azure App Configuration Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureAppConfigurationSyncIdRemoveSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Trigger a sync for the specified Azure App Configuration Sync.
         * @param {string} syncId The ID of the Azure App Configuration Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureAppConfigurationSyncIdSyncSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Azure App Configuration Sync by name and project ID.
         * @param {string} projectId The ID of the project the Azure App Configuration Sync is associated with.
         * @param {string} syncName The name of the Azure App Configuration Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureAppConfigurationSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureAppConfigurationSyncNameSyncNameGet(projectId, syncName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the Azure Key Vault Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Azure Key Vault Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultGet200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureKeyVaultGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create an Azure Key Vault Sync for the specified project environment.
         * @param {ApiV1SecretSyncsAzureKeyVaultPostRequest} apiV1SecretSyncsAzureKeyVaultPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultPost(apiV1SecretSyncsAzureKeyVaultPostRequest: ApiV1SecretSyncsAzureKeyVaultPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureKeyVaultPost(apiV1SecretSyncsAzureKeyVaultPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified Azure Key Vault Sync.
         * @param {string} syncId The ID of the Azure Key Vault Sync to be deleted.
         * @param {ApiV1SecretSyncsAzureKeyVaultSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsAzureKeyVaultSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureKeyVaultSyncIdDelete(syncId, removeSecrets, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Azure Key Vault Sync by ID.
         * @param {string} syncId The ID of the Azure Key Vault Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureKeyVaultSyncIdGet(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Import secrets from the specified Azure Key Vault Sync destination.
         * @param {ApiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or Azure Key Vault.
         * @param {string} syncId The ID of the Azure Key Vault Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPost(importBehavior, syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified Azure Key Vault Sync.
         * @param {string} syncId The ID of the Azure Key Vault Sync to be updated.
         * @param {ApiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest} [apiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncIdPatch(syncId: string, apiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest?: ApiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureKeyVaultSyncIdPatch(syncId, apiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove previously synced secrets from the specified Azure Key Vault Sync destination.
         * @param {string} syncId The ID of the Azure Key Vault Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureKeyVaultSyncIdRemoveSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Trigger a sync for the specified Azure Key Vault Sync.
         * @param {string} syncId The ID of the Azure Key Vault Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureKeyVaultSyncIdSyncSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Azure Key Vault Sync by name and project ID.
         * @param {string} projectId The ID of the project the Azure Key Vault Sync is associated with.
         * @param {string} syncName The name of the Azure Key Vault Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsAzureKeyVaultSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsAzureKeyVaultSyncNameSyncNameGet(projectId, syncName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the Databricks Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Databricks Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsDatabricksGet200Response&gt; {
            return localVarFp.apiV1SecretSyncsDatabricksGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a Databricks Sync for the specified project environment.
         * @param {ApiV1SecretSyncsDatabricksPostRequest} apiV1SecretSyncsDatabricksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksPost(apiV1SecretSyncsDatabricksPostRequest: ApiV1SecretSyncsDatabricksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsDatabricksPost(apiV1SecretSyncsDatabricksPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified Databricks Sync.
         * @param {string} syncId The ID of the Databricks Sync to be deleted.
         * @param {ApiV1SecretSyncsDatabricksSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsDatabricksSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsDatabricksSyncIdDelete(syncId, removeSecrets, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Databricks Sync by ID.
         * @param {string} syncId The ID of the Databricks Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsDatabricksSyncIdGet(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Import secrets from the specified Databricks Sync destination.
         * @param {ApiV1SecretSyncsDatabricksSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or Databricks.
         * @param {string} syncId The ID of the Databricks Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsDatabricksSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsDatabricksSyncIdImportSecretsPost(importBehavior, syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified Databricks Sync.
         * @param {string} syncId The ID of the Databricks Sync to be updated.
         * @param {ApiV1SecretSyncsDatabricksSyncIdPatchRequest} [apiV1SecretSyncsDatabricksSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncIdPatch(syncId: string, apiV1SecretSyncsDatabricksSyncIdPatchRequest?: ApiV1SecretSyncsDatabricksSyncIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsDatabricksSyncIdPatch(syncId, apiV1SecretSyncsDatabricksSyncIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove previously synced secrets from the specified Databricks Sync destination.
         * @param {string} syncId The ID of the Databricks Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsDatabricksSyncIdRemoveSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Trigger a sync for the specified Databricks Sync.
         * @param {string} syncId The ID of the Databricks Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsDatabricksSyncIdSyncSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Databricks Sync by name and project ID.
         * @param {string} projectId The ID of the project the Databricks Sync is associated with.
         * @param {string} syncName The name of the Databricks Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsDatabricksSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsDatabricksSyncNameSyncNameGet(projectId, syncName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the GCP Secret Manager Syncs for the specified project.
         * @param {string} projectId The ID of the project to list GCP Secret Manager Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerGet200Response&gt; {
            return localVarFp.apiV1SecretSyncsGcpSecretManagerGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a GCP Secret Manager Sync for the specified project environment.
         * @param {ApiV1SecretSyncsGcpSecretManagerPostRequest} apiV1SecretSyncsGcpSecretManagerPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerPost(apiV1SecretSyncsGcpSecretManagerPostRequest: ApiV1SecretSyncsGcpSecretManagerPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGcpSecretManagerPost(apiV1SecretSyncsGcpSecretManagerPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified GCP Secret Manager Sync.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to be deleted.
         * @param {ApiV1SecretSyncsGcpSecretManagerSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsGcpSecretManagerSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGcpSecretManagerSyncIdDelete(syncId, removeSecrets, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified GCP Secret Manager Sync by ID.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGcpSecretManagerSyncIdGet(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Import secrets from the specified GCP Secret Manager Sync destination.
         * @param {ApiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or GCP Secret Manager.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPost(importBehavior, syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified GCP Secret Manager Sync.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to be updated.
         * @param {ApiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest} [apiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncIdPatch(syncId: string, apiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest?: ApiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGcpSecretManagerSyncIdPatch(syncId, apiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove previously synced secrets from the specified GCP Secret Manager Sync destination.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGcpSecretManagerSyncIdRemoveSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Trigger a sync for the specified GCP Secret Manager Sync.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGcpSecretManagerSyncIdSyncSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified GCP Secret Manager Sync by name and project ID.
         * @param {string} projectId The ID of the project the GCP Secret Manager Sync is associated with.
         * @param {string} syncName The name of the GCP Secret Manager Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGcpSecretManagerSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGcpSecretManagerSyncNameSyncNameGet(projectId, syncName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List all the Secret Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Secret Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGet200Response&gt; {
            return localVarFp.apiV1SecretSyncsGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the GitHub Syncs for the specified project.
         * @param {string} projectId The ID of the project to list GitHub Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGithubGet200Response&gt; {
            return localVarFp.apiV1SecretSyncsGithubGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a GitHub Sync for the specified project environment.
         * @param {ApiV1SecretSyncsGithubPostRequest} apiV1SecretSyncsGithubPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubPost(apiV1SecretSyncsGithubPostRequest: ApiV1SecretSyncsGithubPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGithubPost(apiV1SecretSyncsGithubPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified GitHub Sync.
         * @param {string} syncId The ID of the GitHub Sync to be deleted.
         * @param {ApiV1SecretSyncsGithubSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsGithubSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGithubSyncIdDelete(syncId, removeSecrets, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified GitHub Sync by ID.
         * @param {string} syncId The ID of the GitHub Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGithubSyncIdGet(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Import secrets from the specified GitHub Sync destination.
         * @param {ApiV1SecretSyncsGithubSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or GitHub.
         * @param {string} syncId The ID of the GitHub Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsGithubSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGithubSyncIdImportSecretsPost(importBehavior, syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified GitHub Sync.
         * @param {string} syncId The ID of the GitHub Sync to be updated.
         * @param {ApiV1SecretSyncsGithubSyncIdPatchRequest} [apiV1SecretSyncsGithubSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncIdPatch(syncId: string, apiV1SecretSyncsGithubSyncIdPatchRequest?: ApiV1SecretSyncsGithubSyncIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGithubSyncIdPatch(syncId, apiV1SecretSyncsGithubSyncIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove previously synced secrets from the specified GitHub Sync destination.
         * @param {string} syncId The ID of the GitHub Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGithubSyncIdRemoveSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Trigger a sync for the specified GitHub Sync.
         * @param {string} syncId The ID of the GitHub Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGithubSyncIdSyncSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified GitHub Sync by name and project ID.
         * @param {string} projectId The ID of the project the GitHub Sync is associated with.
         * @param {string} syncName The name of the GitHub Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsGithubSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsGithubSyncNameSyncNameGet(projectId, syncName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the Humanitec Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Humanitec Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsHumanitecGet200Response&gt; {
            return localVarFp.apiV1SecretSyncsHumanitecGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a Humanitec Sync for the specified project environment.
         * @param {ApiV1SecretSyncsHumanitecPostRequest} apiV1SecretSyncsHumanitecPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecPost(apiV1SecretSyncsHumanitecPostRequest: ApiV1SecretSyncsHumanitecPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsHumanitecPost(apiV1SecretSyncsHumanitecPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified Humanitec Sync.
         * @param {string} syncId The ID of the Humanitec Sync to be deleted.
         * @param {ApiV1SecretSyncsHumanitecSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsHumanitecSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsHumanitecSyncIdDelete(syncId, removeSecrets, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Humanitec Sync by ID.
         * @param {string} syncId The ID of the Humanitec Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsHumanitecSyncIdGet(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Import secrets from the specified Humanitec Sync destination.
         * @param {ApiV1SecretSyncsHumanitecSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or Humanitec.
         * @param {string} syncId The ID of the Humanitec Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsHumanitecSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsHumanitecSyncIdImportSecretsPost(importBehavior, syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update the specified Humanitec Sync.
         * @param {string} syncId The ID of the Humanitec Sync to be updated.
         * @param {ApiV1SecretSyncsHumanitecSyncIdPatchRequest} [apiV1SecretSyncsHumanitecSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncIdPatch(syncId: string, apiV1SecretSyncsHumanitecSyncIdPatchRequest?: ApiV1SecretSyncsHumanitecSyncIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsHumanitecSyncIdPatch(syncId, apiV1SecretSyncsHumanitecSyncIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove previously synced secrets from the specified Humanitec Sync destination.
         * @param {string} syncId The ID of the Humanitec Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsHumanitecSyncIdRemoveSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Trigger a sync for the specified Humanitec Sync.
         * @param {string} syncId The ID of the Humanitec Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsHumanitecSyncIdSyncSecretsPost(syncId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get the specified Humanitec Sync by name and project ID.
         * @param {string} projectId The ID of the project the Humanitec Sync is associated with.
         * @param {string} syncName The name of the Humanitec Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsHumanitecSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt; {
            return localVarFp.apiV1SecretSyncsHumanitecSyncNameSyncNameGet(projectId, syncName, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List the available Secret Sync Options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretSyncsOptionsGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretSyncsOptionsGet200Response&gt; {
            return localVarFp.apiV1SecretSyncsOptionsGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get list of users, machine identities, and groups with access to a secret
         * @param {string} workspaceId The ID of the project where the secret is located.
         * @param {string} environment The slug of the environment where the the secret is located.
         * @param {string} secretName The name of the secret to get the access list for.
         * @param {string} [secretPath] The folder path where the secret is located.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SecretsSecretNameAccessListGet(workspaceId: string, environment: string, secretName: string, secretPath?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SecretsSecretNameAccessListGet200Response&gt; {
            return localVarFp.apiV1SecretsSecretNameAccessListGet(workspaceId, environment, secretName, secretPath, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create SSH CA
         * @param {ApiV1SshCaPostRequest} apiV1SshCaPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCaPost(apiV1SshCaPostRequest: ApiV1SshCaPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SshCaPost200Response&gt; {
            return localVarFp.apiV1SshCaPost(apiV1SshCaPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get list of certificate templates for the SSH CA
         * @param {string} sshCaId The ID of the SSH CA to get the certificate templates for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCaSshCaIdCertificateTemplatesGet(sshCaId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SshCaSshCaIdCertificateTemplatesGet200Response&gt; {
            return localVarFp.apiV1SshCaSshCaIdCertificateTemplatesGet(sshCaId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete SSH CA
         * @param {string} sshCaId The ID of the SSH CA to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCaSshCaIdDelete(sshCaId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SshCaSshCaIdDelete200Response&gt; {
            return localVarFp.apiV1SshCaSshCaIdDelete(sshCaId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get SSH CA
         * @param {string} sshCaId The ID of the SSH CA to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCaSshCaIdGet(sshCaId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SshCaPost200Response&gt; {
            return localVarFp.apiV1SshCaSshCaIdGet(sshCaId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update SSH CA
         * @param {string} sshCaId The ID of the SSH CA to update.
         * @param {ApiV1SshCaSshCaIdPatchRequest} [apiV1SshCaSshCaIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCaSshCaIdPatch(sshCaId: string, apiV1SshCaSshCaIdPatchRequest?: ApiV1SshCaSshCaIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SshCaPost200Response&gt; {
            return localVarFp.apiV1SshCaSshCaIdPatch(sshCaId, apiV1SshCaSshCaIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get public key of SSH CA
         * @param {string} sshCaId The ID of the SSH CA to get the public key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCaSshCaIdPublicKeyGet(sshCaId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;string&gt; {
            return localVarFp.apiV1SshCaSshCaIdPublicKeyGet(sshCaId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the SSH certificate template to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCertificateTemplatesCertificateTemplateIdDelete(certificateTemplateId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SshCaSshCaIdCertificateTemplatesGet200ResponseCertificateTemplatesInner&gt; {
            return localVarFp.apiV1SshCertificateTemplatesCertificateTemplateIdDelete(certificateTemplateId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the SSH certificate template to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCertificateTemplatesCertificateTemplateIdGet(certificateTemplateId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SshCaSshCaIdCertificateTemplatesGet200ResponseCertificateTemplatesInner&gt; {
            return localVarFp.apiV1SshCertificateTemplatesCertificateTemplateIdGet(certificateTemplateId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the SSH certificate template to update.
         * @param {ApiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest} [apiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCertificateTemplatesCertificateTemplateIdPatch(certificateTemplateId: string, apiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest?: ApiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SshCaSshCaIdCertificateTemplatesGet200ResponseCertificateTemplatesInner&gt; {
            return localVarFp.apiV1SshCertificateTemplatesCertificateTemplateIdPatch(certificateTemplateId, apiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SshCertificateTemplatesPostRequest} apiV1SshCertificateTemplatesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCertificateTemplatesPost(apiV1SshCertificateTemplatesPostRequest: ApiV1SshCertificateTemplatesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SshCaSshCaIdCertificateTemplatesGet200ResponseCertificateTemplatesInner&gt; {
            return localVarFp.apiV1SshCertificateTemplatesPost(apiV1SshCertificateTemplatesPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Issue SSH credentials (certificate + key)
         * @param {ApiV1SshCertificatesIssuePostRequest} apiV1SshCertificatesIssuePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCertificatesIssuePost(apiV1SshCertificatesIssuePostRequest: ApiV1SshCertificatesIssuePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SshCertificatesIssuePost200Response&gt; {
            return localVarFp.apiV1SshCertificatesIssuePost(apiV1SshCertificatesIssuePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Sign SSH public key
         * @param {ApiV1SshCertificatesSignPostRequest} apiV1SshCertificatesSignPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SshCertificatesSignPost(apiV1SshCertificatesSignPostRequest: ApiV1SshCertificatesSignPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SshCertificatesSignPost200Response&gt; {
            return localVarFp.apiV1SshCertificatesSignPost(apiV1SshCertificatesSignPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoConfigGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SsoConfigGet200Response&gt; {
            return localVarFp.apiV1SsoConfigGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SsoConfigPatchRequest} apiV1SsoConfigPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoConfigPatch(apiV1SsoConfigPatchRequest: ApiV1SsoConfigPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SsoConfigPost200Response&gt; {
            return localVarFp.apiV1SsoConfigPatch(apiV1SsoConfigPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SsoConfigPostRequest} apiV1SsoConfigPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoConfigPost(apiV1SsoConfigPostRequest: ApiV1SsoConfigPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SsoConfigPost200Response&gt; {
            return localVarFp.apiV1SsoConfigPost(apiV1SsoConfigPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoGithubGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoGithubGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoGitlabGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoGitlabGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoGoogleGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoGoogleGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcCallbackGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoOidcCallbackGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcConfigGet(orgSlug: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SsoOidcConfigGet200Response&gt; {
            return localVarFp.apiV1SsoOidcConfigGet(orgSlug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SsoOidcConfigPatchRequest} apiV1SsoOidcConfigPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcConfigPatch(apiV1SsoOidcConfigPatchRequest: ApiV1SsoOidcConfigPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SsoOidcConfigPatch200Response&gt; {
            return localVarFp.apiV1SsoOidcConfigPatch(apiV1SsoOidcConfigPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SsoOidcConfigPostRequest} apiV1SsoOidcConfigPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcConfigPost(apiV1SsoOidcConfigPostRequest: ApiV1SsoOidcConfigPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SsoOidcConfigPost200Response&gt; {
            return localVarFp.apiV1SsoOidcConfigPost(apiV1SsoOidcConfigPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcLoginErrorGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoOidcLoginErrorGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgSlug 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcLoginGet(orgSlug: string, callbackPort?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoOidcLoginGet(orgSlug, callbackPort, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoOidcManageGroupMembershipsGet(orgId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SsoOidcManageGroupMembershipsGet200Response&gt; {
            return localVarFp.apiV1SsoOidcManageGroupMembershipsGet(orgId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoRedirectGithubGet(callbackPort?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoRedirectGithubGet(callbackPort, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoRedirectGitlabGet(callbackPort?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoRedirectGitlabGet(callbackPort, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoRedirectGoogleGet(callbackPort?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoRedirectGoogleGet(callbackPort, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgSlug 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoRedirectOrganizationsOrgSlugGet(orgSlug: string, callbackPort?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoRedirectOrganizationsOrgSlugGet(orgSlug, callbackPort, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgSlug 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoRedirectSaml2OrganizationsOrgSlugGet(orgSlug: string, callbackPort?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoRedirectSaml2OrganizationsOrgSlugGet(orgSlug, callbackPort, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} samlConfigId 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoRedirectSaml2SamlConfigIdGet(samlConfigId: string, callbackPort?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoRedirectSaml2SamlConfigIdGet(samlConfigId, callbackPort, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} samlConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoSaml2SamlConfigIdPost(samlConfigId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoSaml2SamlConfigIdPost(samlConfigId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1SsoTokenExchangePostRequest} apiV1SsoTokenExchangePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SsoTokenExchangePost(apiV1SsoTokenExchangePostRequest: ApiV1SsoTokenExchangePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1SsoTokenExchangePost(apiV1SsoTokenExchangePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserActionGet(action: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1UserActionGet200Response&gt; {
            return localVarFp.apiV1UserActionGet(action, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserActionPostRequest} apiV1UserActionPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserActionPost(apiV1UserActionPostRequest: ApiV1UserActionPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1UserActionPost200Response&gt; {
            return localVarFp.apiV1UserActionPost(apiV1UserActionPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserEngagementMeWishPostRequest} apiV1UserEngagementMeWishPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserEngagementMeWishPost(apiV1UserEngagementMeWishPostRequest: ApiV1UserEngagementMeWishPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;object&gt; {
            return localVarFp.apiV1UserEngagementMeWishPost(apiV1UserEngagementMeWishPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1UserGet200Response&gt; {
            return localVarFp.apiV1UserGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeProjectFavoritesGet(orgId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1UserMeProjectFavoritesGet200Response&gt; {
            return localVarFp.apiV1UserMeProjectFavoritesGet(orgId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserMeProjectFavoritesPutRequest} apiV1UserMeProjectFavoritesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeProjectFavoritesPut(apiV1UserMeProjectFavoritesPutRequest: ApiV1UserMeProjectFavoritesPutRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1UserMeProjectFavoritesPut(apiV1UserMeProjectFavoritesPutRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeTotpDelete(options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1UserMeTotpDelete(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeTotpGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1UserMeTotpGet200Response&gt; {
            return localVarFp.apiV1UserMeTotpGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeTotpRecoveryCodesPost(options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1UserMeTotpRecoveryCodesPost(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeTotpRegisterPost(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1UserMeTotpRegisterPost200Response&gt; {
            return localVarFp.apiV1UserMeTotpRegisterPost(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserMeTotpVerifyPostRequest} apiV1UserMeTotpVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeTotpVerifyPost(apiV1UserMeTotpVerifyPostRequest: ApiV1UserMeTotpVerifyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;object&gt; {
            return localVarFp.apiV1UserMeTotpVerifyPost(apiV1UserMeTotpVerifyPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMeUsernameGroupsGet(username: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV1UserMeUsernameGroupsGet200ResponseInner&gt;&gt; {
            return localVarFp.apiV1UserMeUsernameGroupsGet(username, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserPrivateKeyGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1UserPrivateKeyGet200Response&gt; {
            return localVarFp.apiV1UserPrivateKeyGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectMembershipId Project membership ID of user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProjectAdditionalPrivilegeGet(projectMembershipId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1UserProjectAdditionalPrivilegeGet200Response&gt; {
            return localVarFp.apiV1UserProjectAdditionalPrivilegeGet(projectMembershipId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserProjectAdditionalPrivilegePostRequest} apiV1UserProjectAdditionalPrivilegePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProjectAdditionalPrivilegePost(apiV1UserProjectAdditionalPrivilegePostRequest: ApiV1UserProjectAdditionalPrivilegePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1UserProjectAdditionalPrivilegePost200Response&gt; {
            return localVarFp.apiV1UserProjectAdditionalPrivilegePost(apiV1UserProjectAdditionalPrivilegePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} privilegeId The ID of privilege object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProjectAdditionalPrivilegePrivilegeIdDelete(privilegeId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1UserProjectAdditionalPrivilegePost200Response&gt; {
            return localVarFp.apiV1UserProjectAdditionalPrivilegePrivilegeIdDelete(privilegeId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} privilegeId The ID of privilege object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProjectAdditionalPrivilegePrivilegeIdGet(privilegeId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1UserProjectAdditionalPrivilegePost200Response&gt; {
            return localVarFp.apiV1UserProjectAdditionalPrivilegePrivilegeIdGet(privilegeId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} privilegeId The ID of privilege object.
         * @param {ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest} [apiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProjectAdditionalPrivilegePrivilegeIdPatch(privilegeId: string, apiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest?: ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1UserProjectAdditionalPrivilegePost200Response&gt; {
            return localVarFp.apiV1UserProjectAdditionalPrivilegePrivilegeIdPatch(privilegeId, apiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserUserIdUnlockGet(token: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1UserUserIdUnlockGet(token, userId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [environment] 
         * @param {string} [secretPath] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WebhooksGet(workspaceId: string, environment?: string, secretPath?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WebhooksGet200Response&gt; {
            return localVarFp.apiV1WebhooksGet(workspaceId, environment, secretPath, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1WebhooksPostRequest} apiV1WebhooksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WebhooksPost(apiV1WebhooksPostRequest: ApiV1WebhooksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WebhooksPost200Response&gt; {
            return localVarFp.apiV1WebhooksPost(apiV1WebhooksPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WebhooksWebhookIdDelete(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1WebhooksWebhookIdDelete(webhookId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {ApiV1WebhooksWebhookIdPatchRequest} [apiV1WebhooksWebhookIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WebhooksWebhookIdPatch(webhookId: string, apiV1WebhooksWebhookIdPatchRequest?: ApiV1WebhooksWebhookIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WebhooksPost200Response&gt; {
            return localVarFp.apiV1WebhooksWebhookIdPatch(webhookId, apiV1WebhooksWebhookIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WebhooksWebhookIdTestPost(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WebhooksPost200Response&gt; {
            return localVarFp.apiV1WebhooksWebhookIdTestPost(webhookId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV1WorkflowIntegrationsGet200ResponseInner&gt;&gt; {
            return localVarFp.apiV1WorkflowIntegrationsGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV1WorkflowIntegrationsSlackGet200ResponseInner&gt;&gt; {
            return localVarFp.apiV1WorkflowIntegrationsSlackGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackIdChannelsGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV1GatewaysGet200ResponseGatewaysInnerIdentity&gt;&gt; {
            return localVarFp.apiV1WorkflowIntegrationsSlackIdChannelsGet(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkflowIntegrationsSlackGet200ResponseInner&gt; {
            return localVarFp.apiV1WorkflowIntegrationsSlackIdDelete(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkflowIntegrationsSlackGet200ResponseInner&gt; {
            return localVarFp.apiV1WorkflowIntegrationsSlackIdGet(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1WorkflowIntegrationsSlackIdPatchRequest} [apiV1WorkflowIntegrationsSlackIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackIdPatch(id: string, apiV1WorkflowIntegrationsSlackIdPatchRequest?: ApiV1WorkflowIntegrationsSlackIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkflowIntegrationsSlackGet200ResponseInner&gt; {
            return localVarFp.apiV1WorkflowIntegrationsSlackIdPatch(id, apiV1WorkflowIntegrationsSlackIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} slug 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackInstallGet(slug: string, description?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;string&gt; {
            return localVarFp.apiV1WorkflowIntegrationsSlackInstallGet(slug, description, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackOauthRedirectGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV1WorkflowIntegrationsSlackOauthRedirectGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowIntegrationsSlackReinstallGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;string&gt; {
            return localVarFp.apiV1WorkflowIntegrationsSlackReinstallGet(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get Environment by ID
         * @param {string} envId The ID of the environment to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceEnvironmentsEnvIdGet(envId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet200Response&gt; {
            return localVarFp.apiV1WorkspaceEnvironmentsEnvIdGet(envId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1WorkspaceGetIncludeRolesEnum} [includeRoles] 
         * @param {ApiV1WorkspaceGetTypeEnum} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceGet(includeRoles?: ApiV1WorkspaceGetIncludeRolesEnum, type?: ApiV1WorkspaceGetTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceGet200Response&gt; {
            return localVarFp.apiV1WorkspaceGet(includeRoles, type, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdPermissionsGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectIdPermissionsGet200Response&gt; {
            return localVarFp.apiV1WorkspaceProjectIdPermissionsGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId The ID of the project to list tags from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdTagsGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectIdTagsGet200Response&gt; {
            return localVarFp.apiV1WorkspaceProjectIdTagsGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId The ID of the project to create the tag in.
         * @param {ApiV1WorkspaceProjectIdTagsPostRequest} apiV1WorkspaceProjectIdTagsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdTagsPost(projectId: string, apiV1WorkspaceProjectIdTagsPostRequest: ApiV1WorkspaceProjectIdTagsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectIdTagsPost200Response&gt; {
            return localVarFp.apiV1WorkspaceProjectIdTagsPost(projectId, apiV1WorkspaceProjectIdTagsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId The ID of the project to get tags from.
         * @param {string} tagSlug The slug of the tag to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdTagsSlugTagSlugGet(projectId: string, tagSlug: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectIdTagsTagIdGet200Response&gt; {
            return localVarFp.apiV1WorkspaceProjectIdTagsSlugTagSlugGet(projectId, tagSlug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId The ID of the project to delete the tag from.
         * @param {string} tagId The ID of the tag to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdTagsTagIdDelete(projectId: string, tagId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectIdTagsPost200Response&gt; {
            return localVarFp.apiV1WorkspaceProjectIdTagsTagIdDelete(projectId, tagId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId The ID of the project to get tags from.
         * @param {string} tagId The ID of the tag to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdTagsTagIdGet(projectId: string, tagId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectIdTagsTagIdGet200Response&gt; {
            return localVarFp.apiV1WorkspaceProjectIdTagsTagIdGet(projectId, tagId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId The ID of the project to update the tag in.
         * @param {string} tagId The ID of the tag to get details.
         * @param {ApiV1WorkspaceProjectIdTagsTagIdPatchRequest} apiV1WorkspaceProjectIdTagsTagIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectIdTagsTagIdPatch(projectId: string, tagId: string, apiV1WorkspaceProjectIdTagsTagIdPatchRequest: ApiV1WorkspaceProjectIdTagsTagIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectIdTagsPost200Response&gt; {
            return localVarFp.apiV1WorkspaceProjectIdTagsTagIdPatch(projectId, tagId, apiV1WorkspaceProjectIdTagsTagIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List project role
         * @param {string} projectSlug The slug of the project to list the roles of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectSlugRolesGet(projectSlug: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesGet200Response&gt; {
            return localVarFp.apiV1WorkspaceProjectSlugRolesGet(projectSlug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a project role
         * @param {string} projectSlug Slug of the project to create the role for.
         * @param {ApiV1WorkspaceProjectSlugRolesPostRequest} apiV1WorkspaceProjectSlugRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectSlugRolesPost(projectSlug: string, apiV1WorkspaceProjectSlugRolesPostRequest: ApiV1WorkspaceProjectSlugRolesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesPost200Response&gt; {
            return localVarFp.apiV1WorkspaceProjectSlugRolesPost(projectSlug, apiV1WorkspaceProjectSlugRolesPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete a project role
         * @param {string} projectSlug The slug of the project to delete this role for.
         * @param {string} roleId The ID of the role to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectSlugRolesRoleIdDelete(projectSlug: string, roleId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesPost200Response&gt; {
            return localVarFp.apiV1WorkspaceProjectSlugRolesRoleIdDelete(projectSlug, roleId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update a project role
         * @param {string} projectSlug The slug of the project to update the role for.
         * @param {string} roleId The ID of the role to update
         * @param {ApiV1WorkspaceProjectSlugRolesRoleIdPatchRequest} [apiV1WorkspaceProjectSlugRolesRoleIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectSlugRolesRoleIdPatch(projectSlug: string, roleId: string, apiV1WorkspaceProjectSlugRolesRoleIdPatchRequest?: ApiV1WorkspaceProjectSlugRolesRoleIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesPost200Response&gt; {
            return localVarFp.apiV1WorkspaceProjectSlugRolesRoleIdPatch(projectSlug, roleId, apiV1WorkspaceProjectSlugRolesRoleIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project.
         * @param {string} slug The slug of the role to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceProjectSlugRolesSlugSlugGet(projectSlug: string, slug: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesSlugSlugGet200Response&gt; {
            return localVarFp.apiV1WorkspaceProjectSlugRolesSlugSlugGet(projectSlug, slug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return audit logs
         * @param {string} workspaceId Optionally filter logs by project ID. If not provided, logs from the entire organization will be returned.
         * @param {ApiV1WorkspaceWorkspaceIdAuditLogsGetEventTypeEnum} [eventType] The type of the event to export.
         * @param {ApiV1WorkspaceWorkspaceIdAuditLogsGetUserAgentTypeEnum} [userAgentType] Choose which consuming application to export audit logs for.
         * @param {string} [startDate] The date to start the export from.
         * @param {string} [endDate] The date to end the export at.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th audit log.
         * @param {number} [limit] The number of audit logs to return.
         * @param {string} [actor] The actor to filter the audit logs by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdAuditLogsGet(workspaceId: string, eventType?: ApiV1WorkspaceWorkspaceIdAuditLogsGetEventTypeEnum, userAgentType?: ApiV1WorkspaceWorkspaceIdAuditLogsGetUserAgentTypeEnum, startDate?: string, endDate?: string, offset?: number, limit?: number, actor?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdAuditLogsGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdAuditLogsGet(workspaceId, eventType, userAgentType, startDate, endDate, offset, limit, actor, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List integration auth objects for a workspace.
         * @param {string} workspaceId The ID of the project to list integration auths for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdAuthorizationsGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdIntegrationAuthorizationsGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdAuthorizationsGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest} apiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdAutoCapitalizationPost(workspaceId: string, apiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest: ApiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdNamePost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdAutoCapitalizationPost(workspaceId, apiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete project
         * @param {string} workspaceId The ID of the project to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdDelete(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdDelete200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdDelete(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdEnvironmentFolderTreeGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;{ [key: string]: ApiV1WorkspaceWorkspaceIdEnvironmentFolderTreeGet200ResponseValue; }&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdEnvironmentFolderTreeGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get Environment
         * @param {string} workspaceId The ID of the project the environment belongs to.
         * @param {string} envId The ID of the environment to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet(workspaceId: string, envId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet(workspaceId, envId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete environment
         * @param {string} workspaceId The ID of the project to delete the environment from.
         * @param {string} id The ID of the environment to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdEnvironmentsIdDelete(workspaceId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdEnvironmentsIdDelete(workspaceId, id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update environment
         * @param {string} workspaceId The ID of the project to update the environment in.
         * @param {string} id The ID of the environment to update.
         * @param {ApiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest} [apiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdEnvironmentsIdPatch(workspaceId: string, id: string, apiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest?: ApiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdEnvironmentsIdPatch(workspaceId, id, apiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create environment
         * @param {string} workspaceId The ID of the project to create the environment in.
         * @param {ApiV1WorkspaceWorkspaceIdEnvironmentsPostRequest} apiV1WorkspaceWorkspaceIdEnvironmentsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdEnvironmentsPost(workspaceId: string, apiV1WorkspaceWorkspaceIdEnvironmentsPostRequest: ApiV1WorkspaceWorkspaceIdEnvironmentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdEnvironmentsPost(workspaceId, apiV1WorkspaceWorkspaceIdEnvironmentsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get project
         * @param {string} workspaceId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List integrations for a project.
         * @param {string} workspaceId The ID of the project to list integrations for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdIntegrationsGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdIntegrationsGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdIntegrationsGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdKeyPostRequest} apiV1WorkspaceWorkspaceIdKeyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdKeyPost(workspaceId: string, apiV1WorkspaceWorkspaceIdKeyPostRequest: ApiV1WorkspaceWorkspaceIdKeyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdKeyPost(workspaceId, apiV1WorkspaceWorkspaceIdKeyPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdKeysGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdKeysGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdKeysGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdKmsBackupGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdKmsBackupGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdKmsBackupGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdKmsBackupPostRequest} apiV1WorkspaceWorkspaceIdKmsBackupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdKmsBackupPost(workspaceId: string, apiV1WorkspaceWorkspaceIdKmsBackupPostRequest: ApiV1WorkspaceWorkspaceIdKmsBackupPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdKmsGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdKmsBackupPost(workspaceId, apiV1WorkspaceWorkspaceIdKmsBackupPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdKmsGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdKmsGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdKmsGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdKmsPatchRequest} apiV1WorkspaceWorkspaceIdKmsPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdKmsPatch(workspaceId: string, apiV1WorkspaceWorkspaceIdKmsPatchRequest: ApiV1WorkspaceWorkspaceIdKmsPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdKmsGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdKmsPatch(workspaceId, apiV1WorkspaceWorkspaceIdKmsPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdLeaveDelete(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdLeaveDelete(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return project user memberships
         * @param {string} workspaceId The ID of the project to get memberships from.
         * @param {ApiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest} apiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMembershipsDetailsPost(workspaceId: string, apiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest: ApiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsDetailsPost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdMembershipsDetailsPost(workspaceId, apiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return project user memberships
         * @param {string} workspaceId The ID of the project to get memberships from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMembershipsGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdMembershipsGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete project user membership
         * @param {string} workspaceId 
         * @param {string} membershipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMembershipsMembershipIdDelete(workspaceId: string, membershipId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdMembershipsMembershipIdDelete(workspaceId, membershipId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return project user membership
         * @param {string} workspaceId The ID of the project to get memberships from.
         * @param {string} membershipId The ID of the user\&amp;#39;s project membership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMembershipsMembershipIdGet(workspaceId: string, membershipId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdMembershipsMembershipIdGet(workspaceId, membershipId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update project user membership
         * @param {string} workspaceId The ID of the project to update the membership for.
         * @param {string} membershipId The ID of the membership to update.
         * @param {ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest} apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch(workspaceId: string, membershipId: string, apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest: ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch(workspaceId, membershipId, apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdMembershipsPostRequest} apiV1WorkspaceWorkspaceIdMembershipsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMembershipsPost(workspaceId: string, apiV1WorkspaceWorkspaceIdMembershipsPostRequest: ApiV1WorkspaceWorkspaceIdMembershipsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsPost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdMembershipsPost(workspaceId, apiV1WorkspaceWorkspaceIdMembershipsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdMigrateV3Post(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdMigrateV3Post(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdNamePostRequest} apiV1WorkspaceWorkspaceIdNamePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdNamePost(workspaceId: string, apiV1WorkspaceWorkspaceIdNamePostRequest: ApiV1WorkspaceWorkspaceIdNamePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdNamePost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdNamePost(workspaceId, apiV1WorkspaceWorkspaceIdNamePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update project
         * @param {string} workspaceId The ID of the project to update.
         * @param {ApiV1WorkspaceWorkspaceIdPatchRequest} [apiV1WorkspaceWorkspaceIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdPatch(workspaceId: string, apiV1WorkspaceWorkspaceIdPatchRequest?: ApiV1WorkspaceWorkspaceIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdPatch200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdPatch(workspaceId, apiV1WorkspaceWorkspaceIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} environment 
         * @param {string} workspaceId 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet(environment: string, workspaceId: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet(environment, workspaceId, path, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return project secret snapshots ids
         * @param {string} environment The environment to get snapshots from.
         * @param {string} workspaceId The ID of the project to get snapshots from.
         * @param {string} [path] The secret path to get snapshots from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th snapshot.
         * @param {number} [limit] The number of snapshots to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdSecretSnapshotsGet(environment: string, workspaceId: string, path?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdSecretSnapshotsGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdSecretSnapshotsGet(environment, workspaceId, path, offset, limit, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdServiceTokenDataGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdServiceTokenDataGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdServiceTokenDataGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdSlackConfigGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdSlackConfigGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdSlackConfigGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdSlackConfigPutRequest} apiV1WorkspaceWorkspaceIdSlackConfigPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdSlackConfigPut(workspaceId: string, apiV1WorkspaceWorkspaceIdSlackConfigPutRequest: ApiV1WorkspaceWorkspaceIdSlackConfigPutRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdSlackConfigGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdSlackConfigPut(workspaceId, apiV1WorkspaceWorkspaceIdSlackConfigPutRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdTrustedIpsGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdTrustedIpsGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdTrustedIpsGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdTrustedIpsPostRequest} apiV1WorkspaceWorkspaceIdTrustedIpsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdTrustedIpsPost(workspaceId: string, apiV1WorkspaceWorkspaceIdTrustedIpsPostRequest: ApiV1WorkspaceWorkspaceIdTrustedIpsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdTrustedIpsPost(workspaceId, apiV1WorkspaceWorkspaceIdTrustedIpsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} trustedIpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdDelete(workspaceId: string, trustedIpId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdDelete(workspaceId, trustedIpId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} trustedIpId 
         * @param {ApiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest} apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatch(workspaceId: string, trustedIpId: string, apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest: ApiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatch(workspaceId, trustedIpId, apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdUsersGetIncludeGroupMembersEnum} [includeGroupMembers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceIdUsersGet(workspaceId: string, includeGroupMembers?: ApiV1WorkspaceWorkspaceIdUsersGetIncludeGroupMembersEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdUsersGet200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceIdUsersGet(workspaceId, includeGroupMembers, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceSlug 
         * @param {ApiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest} apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPut(workspaceSlug: string, apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest: ApiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdNamePost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPut(workspaceSlug, apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceSlug 
         * @param {ApiV1WorkspaceWorkspaceSlugVersionLimitPutRequest} apiV1WorkspaceWorkspaceSlugVersionLimitPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkspaceWorkspaceSlugVersionLimitPut(workspaceSlug: string, apiV1WorkspaceWorkspaceSlugVersionLimitPutRequest: ApiV1WorkspaceWorkspaceSlugVersionLimitPutRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdNamePost200Response&gt; {
            return localVarFp.apiV1WorkspaceWorkspaceSlugVersionLimitPut(workspaceSlug, apiV1WorkspaceWorkspaceSlugVersionLimitPutRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AuthMfaCheckTotpGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2AuthMfaCheckTotpGet200Response&gt; {
            return localVarFp.apiV2AuthMfaCheckTotpGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AuthMfaSendPost(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV2AuthMfaSendPost(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV2AuthMfaVerifyPostRequest} apiV2AuthMfaVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AuthMfaVerifyPost(apiV2AuthMfaVerifyPostRequest: ApiV2AuthMfaVerifyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2AuthMfaVerifyPost200Response&gt; {
            return localVarFp.apiV2AuthMfaVerifyPost(apiV2AuthMfaVerifyPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List privileges for the specified identity by project.
         * @param {string} identityId The ID of the identity to list.
         * @param {string} projectId The ID of the project that the identity is in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2IdentityProjectAdditionalPrivilegeGet(identityId: string, projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2IdentityProjectAdditionalPrivilegeGet200Response&gt; {
            return localVarFp.apiV2IdentityProjectAdditionalPrivilegeGet(identityId, projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete the specified identity privilege.
         * @param {string} id The ID of the identity privilege.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2IdentityProjectAdditionalPrivilegeIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt; {
            return localVarFp.apiV2IdentityProjectAdditionalPrivilegeIdDelete(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Retrieve details of a specific privilege by id.
         * @param {string} id The ID of the identity privilege.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2IdentityProjectAdditionalPrivilegeIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt; {
            return localVarFp.apiV2IdentityProjectAdditionalPrivilegeIdGet(id, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update a specific identity privilege.
         * @param {string} id The ID of the identity privilege.
         * @param {ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequest} apiV2IdentityProjectAdditionalPrivilegeIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2IdentityProjectAdditionalPrivilegeIdPatch(id: string, apiV2IdentityProjectAdditionalPrivilegeIdPatchRequest: ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt; {
            return localVarFp.apiV2IdentityProjectAdditionalPrivilegeIdPatch(id, apiV2IdentityProjectAdditionalPrivilegeIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Add an additional privilege for identity.
         * @param {ApiV2IdentityProjectAdditionalPrivilegePostRequest} apiV2IdentityProjectAdditionalPrivilegePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2IdentityProjectAdditionalPrivilegePost(apiV2IdentityProjectAdditionalPrivilegePostRequest: ApiV2IdentityProjectAdditionalPrivilegePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt; {
            return localVarFp.apiV2IdentityProjectAdditionalPrivilegePost(apiV2IdentityProjectAdditionalPrivilegePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Retrieve details of a specific privilege by slug.
         * @param {string} identityId The ID of the identity to list.
         * @param {string} projectSlug The slug of the project of the identity in.
         * @param {string} privilegeSlug The slug of the privilege.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2IdentityProjectAdditionalPrivilegeSlugPrivilegeSlugGet(identityId: string, projectSlug: string, privilegeSlug: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt; {
            return localVarFp.apiV2IdentityProjectAdditionalPrivilegeSlugPrivilegeSlugGet(identityId, projectSlug, privilegeSlug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return organization identity memberships
         * @param {string} orgId The ID of the organization to get identity memberships from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th identity membership.
         * @param {number} [limit] The number of identity memberships to return.
         * @param {ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderByEnum} [orderBy] The column to order identity memberships by.
         * @param {ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderDirectionEnum} [orderDirection] The direction identity memberships will be sorted in.
         * @param {string} [search] The text string that identity membership names will be filtered by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrgIdIdentityMembershipsGet(orgId: string, offset?: number, limit?: number, orderBy?: ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderByEnum, orderDirection?: ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderDirectionEnum, search?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2OrganizationsOrgIdIdentityMembershipsGet200Response&gt; {
            return localVarFp.apiV2OrganizationsOrgIdIdentityMembershipsGet(orgId, offset, limit, orderBy, orderDirection, search, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdDelete(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2OrganizationsOrganizationIdDelete200Response&gt; {
            return localVarFp.apiV2OrganizationsOrganizationIdDelete(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return organization user memberships
         * @param {string} organizationId The ID of the organization to get memberships from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdMembershipsGet(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2OrganizationsOrganizationIdMembershipsGet200Response&gt; {
            return localVarFp.apiV2OrganizationsOrganizationIdMembershipsGet(organizationId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete organization user memberships
         * @param {string} organizationId The ID of the organization to delete the membership from.
         * @param {string} membershipId The ID of the membership to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete(organizationId: string, membershipId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete200Response&gt; {
            return localVarFp.apiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete(organizationId, membershipId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get organization user membership
         * @param {string} organizationId The ID of the organization to get the membership for.
         * @param {string} membershipId The ID of the membership to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdMembershipsMembershipIdGet(organizationId: string, membershipId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2OrganizationsOrganizationIdMembershipsMembershipIdGet200Response&gt; {
            return localVarFp.apiV2OrganizationsOrganizationIdMembershipsMembershipIdGet(organizationId, membershipId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update organization user memberships
         * @param {string} organizationId The ID of the organization to update the membership for.
         * @param {string} membershipId The ID of the membership to update.
         * @param {ApiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest} [apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatch(organizationId: string, membershipId: string, apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest?: ApiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete200Response&gt; {
            return localVarFp.apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatch(organizationId, membershipId, apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get project memberships given organization membership
         * @param {string} organizationId The ID of the organization to delete the membership from.
         * @param {string} membershipId The ID of the membership to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet(organizationId: string, membershipId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet200Response&gt; {
            return localVarFp.apiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet(organizationId, membershipId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return projects in organization that user is apart of
         * @param {string} organizationId The ID of the organization to get projects from.
         * @param {ApiV2OrganizationsOrganizationIdWorkspacesGetTypeEnum} [type] The type of project to filter by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsOrganizationIdWorkspacesGet(organizationId: string, type?: ApiV2OrganizationsOrganizationIdWorkspacesGetTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2OrganizationsOrganizationIdWorkspacesGet200Response&gt; {
            return localVarFp.apiV2OrganizationsOrganizationIdWorkspacesGet(organizationId, type, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV2OrganizationsPostRequest} apiV2OrganizationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsPost(apiV2OrganizationsPostRequest: ApiV2OrganizationsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdGet200Response&gt; {
            return localVarFp.apiV2OrganizationsPost(apiV2OrganizationsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2OrganizationsPrivilegeSystemUpgradePost(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationOrganizationIdGet200Response&gt; {
            return localVarFp.apiV2OrganizationsPrivilegeSystemUpgradePost(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV2PasswordPasswordResetPostRequest} apiV2PasswordPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2PasswordPasswordResetPost(apiV2PasswordPasswordResetPostRequest: ApiV2PasswordPasswordResetPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV2PasswordPasswordResetPost(apiV2PasswordPasswordResetPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV2PasswordUserPasswordResetPostRequest} apiV2PasswordUserPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2PasswordUserPasswordResetPost(apiV2PasswordUserPasswordResetPostRequest: ApiV2PasswordUserPasswordResetPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV2PasswordUserPasswordResetPost(apiV2PasswordUserPasswordResetPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return Infisical Token data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ServiceTokenGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2ServiceTokenGet200Response&gt; {
            return localVarFp.apiV2ServiceTokenGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV2ServiceTokenPostRequest} apiV2ServiceTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ServiceTokenPost(apiV2ServiceTokenPostRequest: ApiV2ServiceTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2ServiceTokenPost200Response&gt; {
            return localVarFp.apiV2ServiceTokenPost(apiV2ServiceTokenPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} serviceTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ServiceTokenServiceTokenIdDelete(serviceTokenId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2ServiceTokenServiceTokenIdDelete200Response&gt; {
            return localVarFp.apiV2ServiceTokenServiceTokenIdDelete(serviceTokenId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} apiKeyDataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeApiKeysApiKeyDataIdDelete(apiKeyDataId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2UsersMeApiKeysApiKeyDataIdDelete200Response&gt; {
            return localVarFp.apiV2UsersMeApiKeysApiKeyDataIdDelete(apiKeyDataId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeApiKeysGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV2UsersMeApiKeysGet200ResponseInner&gt;&gt; {
            return localVarFp.apiV2UsersMeApiKeysGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV2UsersMeApiKeysPostRequest} apiV2UsersMeApiKeysPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeApiKeysPost(apiV2UsersMeApiKeysPostRequest: ApiV2UsersMeApiKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2UsersMeApiKeysPost200Response&gt; {
            return localVarFp.apiV2UsersMeApiKeysPost(apiV2UsersMeApiKeysPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV2UsersMeAuthMethodsPutRequest} apiV2UsersMeAuthMethodsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeAuthMethodsPut(apiV2UsersMeAuthMethodsPutRequest: ApiV2UsersMeAuthMethodsPutRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2UsersMeMfaPatch200Response&gt; {
            return localVarFp.apiV2UsersMeAuthMethodsPut(apiV2UsersMeAuthMethodsPutRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeDelete(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2UsersMeMfaPatch200Response&gt; {
            return localVarFp.apiV2UsersMeDelete(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV2UsersMeEmailsCodePostRequest} apiV2UsersMeEmailsCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeEmailsCodePost(apiV2UsersMeEmailsCodePostRequest: ApiV2UsersMeEmailsCodePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;object&gt; {
            return localVarFp.apiV2UsersMeEmailsCodePost(apiV2UsersMeEmailsCodePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV2UsersMeEmailsVerifyPostRequest} apiV2UsersMeEmailsVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeEmailsVerifyPost(apiV2UsersMeEmailsVerifyPostRequest: ApiV2UsersMeEmailsVerifyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;object&gt; {
            return localVarFp.apiV2UsersMeEmailsVerifyPost(apiV2UsersMeEmailsVerifyPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Retrieve the current user on the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1UserGet200Response&gt; {
            return localVarFp.apiV2UsersMeGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV2UsersMeMfaPatchRequest} [apiV2UsersMeMfaPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeMfaPatch(apiV2UsersMeMfaPatchRequest?: ApiV2UsersMeMfaPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2UsersMeMfaPatch200Response&gt; {
            return localVarFp.apiV2UsersMeMfaPatch(apiV2UsersMeMfaPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV2UsersMeNamePatchRequest} apiV2UsersMeNamePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeNamePatch(apiV2UsersMeNamePatchRequest: ApiV2UsersMeNamePatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2UsersMeMfaPatch200Response&gt; {
            return localVarFp.apiV2UsersMeNamePatch(apiV2UsersMeNamePatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return organizations that current user is part of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeOrganizationsGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2UsersMeOrganizationsGet200Response&gt; {
            return localVarFp.apiV2UsersMeOrganizationsGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeSessionsDelete(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV2UsersMeSessionsDelete(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2UsersMeSessionsGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;Array&lt;ApiV2UsersMeSessionsGet200ResponseInner&gt;&gt; {
            return localVarFp.apiV2UsersMeSessionsGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a new project
         * @param {ApiV2WorkspacePostRequest} apiV2WorkspacePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspacePost(apiV2WorkspacePostRequest: ApiV2WorkspacePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspacePost200Response&gt; {
            return localVarFp.apiV2WorkspacePost(apiV2WorkspacePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdCertificateTemplatesGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdCertificateTemplatesGet200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdCertificateTemplatesGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return list of groups in project
         * @param {string} projectId The ID of the project to list groups for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdGroupsGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdGroupsGet200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdGroupsGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove group from project
         * @param {string} projectId The ID of the project to delete the group from.
         * @param {string} groupId The ID of the group to delete from the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdGroupsGroupIdDelete(projectId: string, groupId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdGroupsGroupIdOrNamePost200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdGroupsGroupIdDelete(projectId, groupId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return project group
         * @param {string} projectId 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdGroupsGroupIdGet(projectId: string, groupId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdGroupsGroupIdGet200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdGroupsGroupIdGet(projectId, groupId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Add group to project
         * @param {string} projectId The ID of the project to add the group to.
         * @param {string} groupIdOrName The ID or name of the group to add to the project.
         * @param {ApiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest} [apiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdGroupsGroupIdOrNamePost(projectId: string, groupIdOrName: string, apiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest?: ApiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdGroupsGroupIdOrNamePost200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdGroupsGroupIdOrNamePost(projectId, groupIdOrName, apiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update group in project
         * @param {string} projectId The ID of the project to update the group in.
         * @param {string} groupId The ID of the group to update in the project.
         * @param {ApiV2WorkspaceProjectIdGroupsGroupIdPatchRequest} apiV2WorkspaceProjectIdGroupsGroupIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdGroupsGroupIdPatch(projectId: string, groupId: string, apiV2WorkspaceProjectIdGroupsGroupIdPatchRequest: ApiV2WorkspaceProjectIdGroupsGroupIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdGroupsGroupIdPatch(projectId, groupId, apiV2WorkspaceProjectIdGroupsGroupIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return project identity memberships
         * @param {string} projectId The ID of the project to get identity memberships from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th identity membership.
         * @param {number} [limit] The number of identity memberships to return.
         * @param {ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderByEnum} [orderBy] The column to order identity memberships by.
         * @param {ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderDirectionEnum} [orderDirection] The direction identity memberships will be sorted in.
         * @param {string} [search] The text string that identity membership names will be filtered by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdIdentityMembershipsGet(projectId: string, offset?: number, limit?: number, orderBy?: ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderByEnum, orderDirection?: ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderDirectionEnum, search?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdIdentityMembershipsGet200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdIdentityMembershipsGet(projectId, offset, limit, orderBy, orderDirection, search, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete project identity memberships
         * @param {string} projectId The ID of the project to delete the identity membership from.
         * @param {string} identityId The ID of the identity to delete the membership from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdDelete(projectId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdDelete(projectId, identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return project identity membership
         * @param {string} projectId The ID of the project to get the identity membership for.
         * @param {string} identityId The ID of the identity to get the membership for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet(projectId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet(projectId, identityId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update project identity memberships
         * @param {string} projectId The ID of the project to update the identity membership for.
         * @param {string} identityId The ID of the identity to update the membership for.
         * @param {ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest} apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatch(projectId: string, identityId: string, apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest: ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatch(projectId, identityId, apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create project identity membership
         * @param {string} projectId 
         * @param {string} identityId 
         * @param {ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest} [apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost(projectId: string, identityId: string, apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest?: ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost(projectId, identityId, apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Remove members from project
         * @param {string} projectId The ID of the project to remove the member from.
         * @param {ApiV2WorkspaceProjectIdMembershipsDeleteRequest} [apiV2WorkspaceProjectIdMembershipsDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdMembershipsDelete(projectId: string, apiV2WorkspaceProjectIdMembershipsDeleteRequest?: ApiV2WorkspaceProjectIdMembershipsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdMembershipsPost200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdMembershipsDelete(projectId, apiV2WorkspaceProjectIdMembershipsDeleteRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Invite members to project
         * @param {string} projectId The ID of the project to invite the member to.
         * @param {ApiV2WorkspaceProjectIdMembershipsPostRequest} [apiV2WorkspaceProjectIdMembershipsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdMembershipsPost(projectId: string, apiV2WorkspaceProjectIdMembershipsPostRequest?: ApiV2WorkspaceProjectIdMembershipsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdMembershipsPost200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdMembershipsPost(projectId, apiV2WorkspaceProjectIdMembershipsPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdPkiAlertsGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdPkiAlertsGet200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdPkiAlertsGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdPkiCollectionsGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdPkiCollectionsGet200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdPkiCollectionsGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List project role
         * @param {string} projectId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdRolesGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesGet200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdRolesGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create a project role
         * @param {string} projectId Id of the project to create the role for.
         * @param {ApiV2WorkspaceProjectIdRolesPostRequest} apiV2WorkspaceProjectIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdRolesPost(projectId: string, apiV2WorkspaceProjectIdRolesPostRequest: ApiV2WorkspaceProjectIdRolesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesPost200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdRolesPost(projectId, apiV2WorkspaceProjectIdRolesPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete a project role
         * @param {string} projectId The ID of the project to delete the role for.
         * @param {string} roleId The ID of the role to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdRolesRoleIdDelete(projectId: string, roleId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesPost200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdRolesRoleIdDelete(projectId, roleId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update a project role
         * @param {string} projectId The ID of the project to update the role for.
         * @param {string} roleId The ID of the role to update
         * @param {ApiV2WorkspaceProjectIdRolesRoleIdPatchRequest} [apiV2WorkspaceProjectIdRolesRoleIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdRolesRoleIdPatch(projectId: string, roleId: string, apiV2WorkspaceProjectIdRolesRoleIdPatchRequest?: ApiV2WorkspaceProjectIdRolesRoleIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesPost200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdRolesRoleIdPatch(projectId, roleId, apiV2WorkspaceProjectIdRolesRoleIdPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId The ID of the project.
         * @param {string} roleSlug The slug of the role to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdRolesSlugRoleSlugGet(projectId: string, roleSlug: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesSlugSlugGet200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdRolesSlugRoleSlugGet(projectId, roleSlug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId The ID of the project to list SSH CAs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdSshCasGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdSshCasGet200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdSshCasGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId The ID of the project to list SSH certificate templates for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdSshCertificateTemplatesGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1SshCaSshCaIdCertificateTemplatesGet200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdSshCertificateTemplatesGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId The ID of the project to list SSH CAs for.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th SSH certificate.
         * @param {number} [limit] The number of SSH certificates to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdSshCertificatesGet(projectId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdSshCertificatesGet200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdSshCertificatesGet(projectId, offset, limit, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {ApiV2WorkspaceProjectIdUpgradePostRequest} apiV2WorkspaceProjectIdUpgradePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdUpgradePost(projectId: string, apiV2WorkspaceProjectIdUpgradePostRequest: ApiV2WorkspaceProjectIdUpgradePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;any&gt; {
            return localVarFp.apiV2WorkspaceProjectIdUpgradePost(projectId, apiV2WorkspaceProjectIdUpgradePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceProjectIdUpgradeStatusGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceProjectIdUpgradeStatusGet200Response&gt; {
            return localVarFp.apiV2WorkspaceProjectIdUpgradeStatusGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} slug The slug of the project to list CAs for.
         * @param {ApiV2WorkspaceSlugCasGetStatusEnum} [status] The status of the CA to filter by.
         * @param {string} [friendlyName] The friendly name of the CA to filter by.
         * @param {string} [commonName] The common name of the CA to filter by.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th CA.
         * @param {number} [limit] The number of CAs to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceSlugCasGet(slug: string, status?: ApiV2WorkspaceSlugCasGetStatusEnum, friendlyName?: string, commonName?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceSlugCasGet200Response&gt; {
            return localVarFp.apiV2WorkspaceSlugCasGet(slug, status, friendlyName, commonName, offset, limit, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} slug The slug of the project to list certificates for.
         * @param {string} [friendlyName] The friendly name of the certificate to filter by.
         * @param {string} [commonName] The common name of the certificate to filter by.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th certificate.
         * @param {number} [limit] The number of certificates to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceSlugCertificatesGet(slug: string, friendlyName?: string, commonName?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceSlugCertificatesGet200Response&gt; {
            return localVarFp.apiV2WorkspaceSlugCertificatesGet(slug, friendlyName, commonName, offset, limit, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete project
         * @param {string} slug The slug of the project to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceSlugDelete(slug: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationAdminProjectsGet200ResponseProjectsInner&gt; {
            return localVarFp.apiV2WorkspaceSlugDelete(slug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} slug The slug of the project to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceSlugGet(slug: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdGet200ResponseWorkspace&gt; {
            return localVarFp.apiV2WorkspaceSlugGet(slug, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} slug The slug of the project to update.
         * @param {ApiV2WorkspaceSlugPatchRequest} [apiV2WorkspaceSlugPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceSlugPatch(slug: string, apiV2WorkspaceSlugPatchRequest?: ApiV2WorkspaceSlugPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1OrganizationAdminProjectsGet200ResponseProjectsInner&gt; {
            return localVarFp.apiV2WorkspaceSlugPatch(slug, apiV2WorkspaceSlugPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Return encrypted project key
         * @param {string} workspaceId The ID of the project to get the key from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WorkspaceWorkspaceIdEncryptedKeyGet(workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2WorkspaceWorkspaceIdEncryptedKeyGet200Response&gt; {
            return localVarFp.apiV2WorkspaceWorkspaceIdEncryptedKeyGet(workspaceId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV3AuthLogin1PostRequest} apiV3AuthLogin1PostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3AuthLogin1Post(apiV3AuthLogin1PostRequest: ApiV3AuthLogin1PostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1PasswordSrp1Post200Response&gt; {
            return localVarFp.apiV3AuthLogin1Post(apiV3AuthLogin1PostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV3AuthLogin2PostRequest} apiV3AuthLogin2PostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3AuthLogin2Post(apiV3AuthLogin2PostRequest: ApiV3AuthLogin2PostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV2AuthMfaVerifyPost200Response&gt; {
            return localVarFp.apiV3AuthLogin2Post(apiV3AuthLogin2PostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV3AuthSelectOrganizationPostRequest} apiV3AuthSelectOrganizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3AuthSelectOrganizationPost(apiV3AuthSelectOrganizationPostRequest: ApiV3AuthSelectOrganizationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3AuthSelectOrganizationPost200Response&gt; {
            return localVarFp.apiV3AuthSelectOrganizationPost(apiV3AuthSelectOrganizationPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3MigrateEnvKeyPost(options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.apiV3MigrateEnvKeyPost(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Backfill secret references
         * @param {ApiV3SecretsBackfillSecretReferencesPostRequest} apiV3SecretsBackfillSecretReferencesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBackfillSecretReferencesPost(apiV3SecretsBackfillSecretReferencesPostRequest: ApiV3SecretsBackfillSecretReferencesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV3SecretsBackfillSecretReferencesPost(apiV3SecretsBackfillSecretReferencesPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV3SecretsBatchDeleteRequest} apiV3SecretsBatchDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBatchDelete(apiV3SecretsBatchDeleteRequest: ApiV3SecretsBatchDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsBatchDelete200Response&gt; {
            return localVarFp.apiV3SecretsBatchDelete(apiV3SecretsBatchDeleteRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV3SecretsBatchPatchRequest} apiV3SecretsBatchPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBatchPatch(apiV3SecretsBatchPatchRequest: ApiV3SecretsBatchPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsBatchDelete200Response&gt; {
            return localVarFp.apiV3SecretsBatchPatch(apiV3SecretsBatchPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV3SecretsBatchPostRequest} apiV3SecretsBatchPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBatchPost(apiV3SecretsBatchPostRequest: ApiV3SecretsBatchPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsBatchPost200Response&gt; {
            return localVarFp.apiV3SecretsBatchPost(apiV3SecretsBatchPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete many secrets
         * @param {ApiV3SecretsBatchRawDeleteRequest} apiV3SecretsBatchRawDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBatchRawDelete(apiV3SecretsBatchRawDeleteRequest: ApiV3SecretsBatchRawDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsBatchRawDelete200Response&gt; {
            return localVarFp.apiV3SecretsBatchRawDelete(apiV3SecretsBatchRawDeleteRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update many secrets
         * @param {ApiV3SecretsBatchRawPatchRequest} apiV3SecretsBatchRawPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBatchRawPatch(apiV3SecretsBatchRawPatchRequest: ApiV3SecretsBatchRawPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsBatchRawDelete200Response&gt; {
            return localVarFp.apiV3SecretsBatchRawPatch(apiV3SecretsBatchRawPatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create many secrets
         * @param {ApiV3SecretsBatchRawPostRequest} apiV3SecretsBatchRawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsBatchRawPost(apiV3SecretsBatchRawPostRequest: ApiV3SecretsBatchRawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsBatchRawPost200Response&gt; {
            return localVarFp.apiV3SecretsBatchRawPost(apiV3SecretsBatchRawPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} [secretPath] 
         * @param {ApiV3SecretsGetRecursiveEnum} [recursive] 
         * @param {ApiV3SecretsGetIncludeImportsEnum} [includeImports] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsGet(workspaceId: string, environment: string, secretPath?: string, recursive?: ApiV3SecretsGetRecursiveEnum, includeImports?: ApiV3SecretsGetIncludeImportsEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsGet200Response&gt; {
            return localVarFp.apiV3SecretsGet(workspaceId, environment, secretPath, recursive, includeImports, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV3SecretsMovePostRequest} apiV3SecretsMovePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsMovePost(apiV3SecretsMovePostRequest: ApiV3SecretsMovePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsMovePost200Response&gt; {
            return localVarFp.apiV3SecretsMovePost(apiV3SecretsMovePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * List secrets
         * @param {string} [metadataFilter] The secret metadata key-value pairs to filter secrets by. When querying for multiple metadata pairs, the query is treated as an AND operation. Secret metadata format is key&amp;#x3D;value1,value&amp;#x3D;value2|key&amp;#x3D;value3,value&amp;#x3D;value4.
         * @param {string} [workspaceId] The ID of the project to list secrets from.
         * @param {string} [workspaceSlug] The slug of the project to list secrets from. This parameter is only applicable by machine identities.
         * @param {string} [environment] The slug of the environment to list secrets from.
         * @param {string} [secretPath] The secret path to list secrets from.
         * @param {ApiV3SecretsRawGetViewSecretValueEnum} [viewSecretValue] Whether or not to retrieve the secret value.
         * @param {ApiV3SecretsRawGetExpandSecretReferencesEnum} [expandSecretReferences] Whether or not to expand secret references.
         * @param {ApiV3SecretsRawGetRecursiveEnum} [recursive] Whether or not to fetch all secrets from the specified base path, and all of its subdirectories. Note, the max depth is 20 deep.
         * @param {ApiV3SecretsRawGetIncludeImportsEnum} [includeImports] Weather to include imported secrets or not.
         * @param {string} [tagSlugs] The comma separated tag slugs to filter secrets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawGet(metadataFilter?: string, workspaceId?: string, workspaceSlug?: string, environment?: string, secretPath?: string, viewSecretValue?: ApiV3SecretsRawGetViewSecretValueEnum, expandSecretReferences?: ApiV3SecretsRawGetExpandSecretReferencesEnum, recursive?: ApiV3SecretsRawGetRecursiveEnum, includeImports?: ApiV3SecretsRawGetIncludeImportsEnum, tagSlugs?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsRawGet200Response&gt; {
            return localVarFp.apiV3SecretsRawGet(metadataFilter, workspaceId, workspaceSlug, environment, secretPath, viewSecretValue, expandSecretReferences, recursive, includeImports, tagSlugs, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} secretId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawIdSecretIdGet(secretId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsRawIdSecretIdGet200Response&gt; {
            return localVarFp.apiV3SecretsRawIdSecretIdGet(secretId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Delete secret
         * @param {string} secretName The name of the secret to delete.
         * @param {ApiV3SecretsRawSecretNameDeleteRequest} apiV3SecretsRawSecretNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawSecretNameDelete(secretName: string, apiV3SecretsRawSecretNameDeleteRequest: ApiV3SecretsRawSecretNameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsRawSecretNameDelete200Response&gt; {
            return localVarFp.apiV3SecretsRawSecretNameDelete(secretName, apiV3SecretsRawSecretNameDeleteRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get a secret by name
         * @param {string} secretName The name of the secret to get.
         * @param {string} [workspaceId] The ID of the project to get the secret from.
         * @param {string} [workspaceSlug] The slug of the project to get the secret from.
         * @param {string} [environment] The slug of the environment to get the secret from.
         * @param {string} [secretPath] The path of the secret to get.
         * @param {number} [version] The version of the secret to get.
         * @param {ApiV3SecretsRawSecretNameGetTypeEnum} [type] The type of the secret to get.
         * @param {ApiV3SecretsRawSecretNameGetViewSecretValueEnum} [viewSecretValue] Whether or not to retrieve the secret value.
         * @param {ApiV3SecretsRawSecretNameGetExpandSecretReferencesEnum} [expandSecretReferences] Whether or not to expand secret references.
         * @param {ApiV3SecretsRawSecretNameGetIncludeImportsEnum} [includeImports] Weather to include imported secrets or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawSecretNameGet(secretName: string, workspaceId?: string, workspaceSlug?: string, environment?: string, secretPath?: string, version?: number, type?: ApiV3SecretsRawSecretNameGetTypeEnum, viewSecretValue?: ApiV3SecretsRawSecretNameGetViewSecretValueEnum, expandSecretReferences?: ApiV3SecretsRawSecretNameGetExpandSecretReferencesEnum, includeImports?: ApiV3SecretsRawSecretNameGetIncludeImportsEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsRawSecretNameGet200Response&gt; {
            return localVarFp.apiV3SecretsRawSecretNameGet(secretName, workspaceId, workspaceSlug, environment, secretPath, version, type, viewSecretValue, expandSecretReferences, includeImports, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Update secret
         * @param {string} secretName The name of the secret to update.
         * @param {ApiV3SecretsRawSecretNamePatchRequest} apiV3SecretsRawSecretNamePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawSecretNamePatch(secretName: string, apiV3SecretsRawSecretNamePatchRequest: ApiV3SecretsRawSecretNamePatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsRawSecretNameDelete200Response&gt; {
            return localVarFp.apiV3SecretsRawSecretNamePatch(secretName, apiV3SecretsRawSecretNamePatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Create secret
         * @param {string} secretName The name of the secret to create.
         * @param {ApiV3SecretsRawSecretNamePostRequest} apiV3SecretsRawSecretNamePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawSecretNamePost(secretName: string, apiV3SecretsRawSecretNamePostRequest: ApiV3SecretsRawSecretNamePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsRawSecretNamePost200Response&gt; {
            return localVarFp.apiV3SecretsRawSecretNamePost(secretName, apiV3SecretsRawSecretNamePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Get secret reference tree
         * @param {string} workspaceId The ID of the project where the secret is located.
         * @param {string} environment The slug of the environment where the the secret is located.
         * @param {string} secretName The name of the secret to get the reference tree for.
         * @param {string} [secretPath] The folder path where the secret is located.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsRawSecretNameSecretReferenceTreeGet(workspaceId: string, environment: string, secretName: string, secretPath?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsRawSecretNameSecretReferenceTreeGet200Response&gt; {
            return localVarFp.apiV3SecretsRawSecretNameSecretReferenceTreeGet(workspaceId, environment, secretName, secretPath, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} secretName 
         * @param {ApiV3SecretsSecretNameDeleteRequest} apiV3SecretsSecretNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsSecretNameDelete(secretName: string, apiV3SecretsSecretNameDeleteRequest: ApiV3SecretsSecretNameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsSecretNameDelete200Response&gt; {
            return localVarFp.apiV3SecretsSecretNameDelete(secretName, apiV3SecretsSecretNameDeleteRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} secretName 
         * @param {string} [secretPath] 
         * @param {ApiV3SecretsSecretNameGetTypeEnum} [type] 
         * @param {number} [version] 
         * @param {ApiV3SecretsSecretNameGetIncludeImportsEnum} [includeImports] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsSecretNameGet(workspaceId: string, environment: string, secretName: string, secretPath?: string, type?: ApiV3SecretsSecretNameGetTypeEnum, version?: number, includeImports?: ApiV3SecretsSecretNameGetIncludeImportsEnum, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsSecretNameGet200Response&gt; {
            return localVarFp.apiV3SecretsSecretNameGet(workspaceId, environment, secretName, secretPath, type, version, includeImports, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} secretName 
         * @param {ApiV3SecretsSecretNamePatchRequest} apiV3SecretsSecretNamePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsSecretNamePatch(secretName: string, apiV3SecretsSecretNamePatchRequest: ApiV3SecretsSecretNamePatchRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsSecretNamePatch200Response&gt; {
            return localVarFp.apiV3SecretsSecretNamePatch(secretName, apiV3SecretsSecretNamePatchRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} secretName 
         * @param {ApiV3SecretsSecretNamePostRequest} apiV3SecretsSecretNamePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsSecretNamePost(secretName: string, apiV3SecretsSecretNamePostRequest: ApiV3SecretsSecretNamePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsSecretNamePost200Response&gt; {
            return localVarFp.apiV3SecretsSecretNamePost(secretName, apiV3SecretsSecretNamePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Detach tags from a secret
         * @param {string} secretName The name of the secret to detach tags from.
         * @param {ApiV3SecretsTagsSecretNameDeleteRequest} apiV3SecretsTagsSecretNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsTagsSecretNameDelete(secretName: string, apiV3SecretsTagsSecretNameDeleteRequest: ApiV3SecretsTagsSecretNameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsTagsSecretNamePost200Response&gt; {
            return localVarFp.apiV3SecretsTagsSecretNameDelete(secretName, apiV3SecretsTagsSecretNameDeleteRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * Attach tags to a secret
         * @param {string} secretName The name of the secret to attach tags to.
         * @param {ApiV3SecretsTagsSecretNamePostRequest} apiV3SecretsTagsSecretNamePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SecretsTagsSecretNamePost(secretName: string, apiV3SecretsTagsSecretNamePostRequest: ApiV3SecretsTagsSecretNamePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SecretsTagsSecretNamePost200Response&gt; {
            return localVarFp.apiV3SecretsTagsSecretNamePost(secretName, apiV3SecretsTagsSecretNamePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV3SignupCompleteAccountInvitePostRequest} apiV3SignupCompleteAccountInvitePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SignupCompleteAccountInvitePost(apiV3SignupCompleteAccountInvitePostRequest: ApiV3SignupCompleteAccountInvitePostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SignupCompleteAccountInvitePost200Response&gt; {
            return localVarFp.apiV3SignupCompleteAccountInvitePost(apiV3SignupCompleteAccountInvitePostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV3SignupCompleteAccountSignupPostRequest} apiV3SignupCompleteAccountSignupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SignupCompleteAccountSignupPost(apiV3SignupCompleteAccountSignupPostRequest: ApiV3SignupCompleteAccountSignupPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SignupCompleteAccountSignupPost200Response&gt; {
            return localVarFp.apiV3SignupCompleteAccountSignupPost(apiV3SignupCompleteAccountSignupPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PasswordEmailPasswordResetPostRequest} apiV1PasswordEmailPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SignupEmailSignupPost(apiV1PasswordEmailPasswordResetPostRequest: ApiV1PasswordEmailPasswordResetPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV3SignupEmailSignupPost(apiV1PasswordEmailPasswordResetPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PasswordEmailPasswordResetVerifyPostRequest} apiV1PasswordEmailPasswordResetVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SignupEmailVerifyPost(apiV1PasswordEmailPasswordResetVerifyPostRequest: ApiV1PasswordEmailPasswordResetVerifyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3SignupEmailVerifyPost200Response&gt; {
            return localVarFp.apiV3SignupEmailVerifyPost(apiV1PasswordEmailPasswordResetVerifyPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3UsersMeApiKeysGet(options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3UsersMeApiKeysGet200Response&gt; {
            return localVarFp.apiV3UsersMeApiKeysGet(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3WorkspacesProjectIdSecretsBlindIndexStatusGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;boolean&gt; {
            return localVarFp.apiV3WorkspacesProjectIdSecretsBlindIndexStatusGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3WorkspacesProjectIdSecretsGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV3WorkspacesProjectIdSecretsGet200Response&gt; {
            return localVarFp.apiV3WorkspacesProjectIdSecretsGet(projectId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {ApiV3WorkspacesProjectIdSecretsNamesPostRequest} apiV3WorkspacesProjectIdSecretsNamesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3WorkspacesProjectIdSecretsNamesPost(projectId: string, apiV3WorkspacesProjectIdSecretsNamesPostRequest: ApiV3WorkspacesProjectIdSecretsNamesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt; {
            return localVarFp.apiV3WorkspacesProjectIdSecretsNamesPost(projectId, apiV3WorkspacesProjectIdSecretsNamesPostRequest, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssWebhookPost(options?: RawAxiosRequestConfig): AxiosPromise&lt;void&gt; {
            return localVarFp.ssWebhookPost(options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} certificateTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wellKnownEstCertificateTemplateIdCacertsGet(certificateTemplateId: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;string&gt; {
            return localVarFp.wellKnownEstCertificateTemplateIdCacertsGet(certificateTemplateId, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} certificateTemplateId 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wellKnownEstCertificateTemplateIdSimpleenrollPost(certificateTemplateId: string, body?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;string&gt; {
            return localVarFp.wellKnownEstCertificateTemplateIdSimpleenrollPost(certificateTemplateId, body, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
        /**
         * 
         * @param {string} certificateTemplateId 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wellKnownEstCertificateTemplateIdSimplereenrollPost(certificateTemplateId: string, body?: string, options?: RawAxiosRequestConfig): AxiosPromise&lt;string&gt; {
            return localVarFp.wellKnownEstCertificateTemplateIdSimplereenrollPost(certificateTemplateId, body, options).then((request) &#x3D;&gt; request(axios, basePath));
        },
    };
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>DefaultApi - factory interface</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="DefaultApiFp"></a>
                    <span class="name">
                        <span ><b>DefaultApiFp</b></span>
                        <a href="#DefaultApiFp"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>function(configuration?: Configuration) {
    const localVarAxiosParamCreator &#x3D; DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStatusGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiStatusGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiStatusGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiStatusGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {string} envSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessApprovalsPoliciesCountGet(projectSlug: string, envSlug: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AccessApprovalsPoliciesCountGet(projectSlug, envSlug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AccessApprovalsPoliciesCountGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessApprovalsPoliciesGet(projectSlug: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AccessApprovalsPoliciesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AccessApprovalsPoliciesGet(projectSlug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AccessApprovalsPoliciesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessApprovalsPoliciesPolicyIdDelete(policyId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AccessApprovalsPoliciesPolicyIdDelete(policyId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AccessApprovalsPoliciesPolicyIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessApprovalsPoliciesPolicyIdGet(policyId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AccessApprovalsPoliciesPolicyIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AccessApprovalsPoliciesPolicyIdGet(policyId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AccessApprovalsPoliciesPolicyIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId 
         * @param {ApiV1AccessApprovalsPoliciesPolicyIdPatchRequest} apiV1AccessApprovalsPoliciesPolicyIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessApprovalsPoliciesPolicyIdPatch(policyId: string, apiV1AccessApprovalsPoliciesPolicyIdPatchRequest: ApiV1AccessApprovalsPoliciesPolicyIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AccessApprovalsPoliciesPolicyIdPatch(policyId, apiV1AccessApprovalsPoliciesPolicyIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AccessApprovalsPoliciesPolicyIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AccessApprovalsPoliciesPostRequest} apiV1AccessApprovalsPoliciesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessApprovalsPoliciesPost(apiV1AccessApprovalsPoliciesPostRequest: ApiV1AccessApprovalsPoliciesPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AccessApprovalsPoliciesPost(apiV1AccessApprovalsPoliciesPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AccessApprovalsPoliciesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessApprovalsRequestsCountGet(projectSlug: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AccessApprovalsRequestsCountGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AccessApprovalsRequestsCountGet(projectSlug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AccessApprovalsRequestsCountGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {string} [authorProjectMembershipId] 
         * @param {string} [envSlug] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessApprovalsRequestsGet(projectSlug: string, authorProjectMembershipId?: string, envSlug?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AccessApprovalsRequestsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AccessApprovalsRequestsGet(projectSlug, authorProjectMembershipId, envSlug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AccessApprovalsRequestsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectSlug 
         * @param {ApiV1AccessApprovalsRequestsPostRequest} apiV1AccessApprovalsRequestsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessApprovalsRequestsPost(projectSlug: string, apiV1AccessApprovalsRequestsPostRequest: ApiV1AccessApprovalsRequestsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AccessApprovalsRequestsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AccessApprovalsRequestsPost(projectSlug, apiV1AccessApprovalsRequestsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AccessApprovalsRequestsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} requestId 
         * @param {ApiV1AccessApprovalsRequestsRequestIdReviewPostRequest} apiV1AccessApprovalsRequestsRequestIdReviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccessApprovalsRequestsRequestIdReviewPost(requestId: string, apiV1AccessApprovalsRequestsRequestIdReviewPostRequest: ApiV1AccessApprovalsRequestsRequestIdReviewPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AccessApprovalsRequestsRequestIdReviewPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AccessApprovalsRequestsRequestIdReviewPost(requestId, apiV1AccessApprovalsRequestsRequestIdReviewPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AccessApprovalsRequestsRequestIdReviewPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific privilege of an identity.
         * @param {ApiV1AdditionalPrivilegeIdentityDeleteRequest} apiV1AdditionalPrivilegeIdentityDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdditionalPrivilegeIdentityDelete(apiV1AdditionalPrivilegeIdentityDeleteRequest: ApiV1AdditionalPrivilegeIdentityDeleteRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdditionalPrivilegeIdentityDelete(apiV1AdditionalPrivilegeIdentityDeleteRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdditionalPrivilegeIdentityDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of a specific privilege of an identity in a project.
         * @param {string} identityId The ID of the identity to list.
         * @param {string} projectSlug The slug of the project of the identity in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdditionalPrivilegeIdentityGet(identityId: string, projectSlug: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdditionalPrivilegeIdentityGet(identityId, projectSlug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdditionalPrivilegeIdentityGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific privilege of an identity.
         * @param {ApiV1AdditionalPrivilegeIdentityPatchRequest} apiV1AdditionalPrivilegeIdentityPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdditionalPrivilegeIdentityPatch(apiV1AdditionalPrivilegeIdentityPatchRequest: ApiV1AdditionalPrivilegeIdentityPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdditionalPrivilegeIdentityPatch(apiV1AdditionalPrivilegeIdentityPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdditionalPrivilegeIdentityPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a permanent or a non expiry specific privilege for identity.
         * @param {ApiV1AdditionalPrivilegeIdentityPermanentPostRequest} apiV1AdditionalPrivilegeIdentityPermanentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdditionalPrivilegeIdentityPermanentPost(apiV1AdditionalPrivilegeIdentityPermanentPostRequest: ApiV1AdditionalPrivilegeIdentityPermanentPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdditionalPrivilegeIdentityPermanentPost(apiV1AdditionalPrivilegeIdentityPermanentPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdditionalPrivilegeIdentityPermanentPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a specific privilege by privilege slug.
         * @param {string} identityId The ID of the identity to list.
         * @param {string} projectSlug The slug of the project of the identity in.
         * @param {string} privilegeSlug The slug of the privilege.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdditionalPrivilegeIdentityPrivilegeSlugGet(identityId: string, projectSlug: string, privilegeSlug: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdditionalPrivilegeIdentityPrivilegeSlugGet(identityId, projectSlug, privilegeSlug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdditionalPrivilegeIdentityPrivilegeSlugGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a temporary or a expiring specific privilege for identity.
         * @param {ApiV1AdditionalPrivilegeIdentityTemporaryPostRequest} apiV1AdditionalPrivilegeIdentityTemporaryPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdditionalPrivilegeIdentityTemporaryPost(apiV1AdditionalPrivilegeIdentityTemporaryPostRequest: ApiV1AdditionalPrivilegeIdentityTemporaryPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdditionalPrivilegeIdentityTemporaryPost(apiV1AdditionalPrivilegeIdentityTemporaryPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdditionalPrivilegeIdentityTemporaryPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AdminBootstrapPostRequest} apiV1AdminBootstrapPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminBootstrapPost(apiV1AdminBootstrapPostRequest: ApiV1AdminBootstrapPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdminBootstrapPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdminBootstrapPost(apiV1AdminBootstrapPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdminBootstrapPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminConfigGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdminConfigGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdminConfigGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdminConfigGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AdminConfigPatchRequest} [apiV1AdminConfigPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminConfigPatch(apiV1AdminConfigPatchRequest?: ApiV1AdminConfigPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdminConfigPatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdminConfigPatch(apiV1AdminConfigPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdminConfigPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminEncryptionStrategiesGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdminEncryptionStrategiesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdminEncryptionStrategiesGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdminEncryptionStrategiesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AdminEncryptionStrategiesPatchRequest} apiV1AdminEncryptionStrategiesPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminEncryptionStrategiesPatch(apiV1AdminEncryptionStrategiesPatchRequest: ApiV1AdminEncryptionStrategiesPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdminEncryptionStrategiesPatch(apiV1AdminEncryptionStrategiesPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdminEncryptionStrategiesPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [searchTerm] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminIdentityManagementIdentitiesGet(searchTerm?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdminIdentityManagementIdentitiesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdminIdentityManagementIdentitiesGet(searchTerm, offset, limit, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdminIdentityManagementIdentitiesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} identityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminIdentityManagementIdentitiesIdentityIdSuperAdminAccessDelete(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdminIdentityManagementIdentitiesIdentityIdSuperAdminAccessDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdminIdentityManagementIdentitiesIdentityIdSuperAdminAccessDelete(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdminIdentityManagementIdentitiesIdentityIdSuperAdminAccessDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminIntegrationsSlackConfigGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdminIntegrationsSlackConfigGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdminIntegrationsSlackConfigGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdminIntegrationsSlackConfigGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AdminSignupPostRequest} apiV1AdminSignupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminSignupPost(apiV1AdminSignupPostRequest: ApiV1AdminSignupPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdminSignupPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdminSignupPost(apiV1AdminSignupPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdminSignupPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [searchTerm] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [adminsOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminUserManagementUsersGet(searchTerm?: string, offset?: number, limit?: number, adminsOnly?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdminUserManagementUsersGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdminUserManagementUsersGet(searchTerm, offset, limit, adminsOnly, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdminUserManagementUsersGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminUserManagementUsersUserIdAdminAccessDelete(userId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdminUserManagementUsersUserIdAdminAccessDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdminUserManagementUsersUserIdAdminAccessDelete(userId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdminUserManagementUsersUserIdAdminAccessDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminUserManagementUsersUserIdAdminAccessPatch(userId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdminUserManagementUsersUserIdAdminAccessPatch(userId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdminUserManagementUsersUserIdAdminAccessPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdminUserManagementUsersUserIdDelete(userId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdminUserManagementUsersUserIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AdminUserManagementUsersUserIdDelete(userId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AdminUserManagementUsersUserIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the AWS Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAwsAvailableGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAwsAvailableGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAwsAvailableGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAwsAvailableGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified AWS Connection.
         * @param {string} connectionId The ID of the AWS Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAwsConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAwsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAwsConnectionIdDelete(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAwsConnectionIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified AWS Connection by ID.
         * @param {string} connectionId The ID of the AWS Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAwsConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAwsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAwsConnectionIdGet(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAwsConnectionIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AppConnectionsAwsConnectionIdKmsKeysGetRegionEnum} region 
         * @param {ApiV1AppConnectionsAwsConnectionIdKmsKeysGetDestinationEnum} destination 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAwsConnectionIdKmsKeysGet(region: ApiV1AppConnectionsAwsConnectionIdKmsKeysGetRegionEnum, destination: ApiV1AppConnectionsAwsConnectionIdKmsKeysGetDestinationEnum, connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAwsConnectionIdKmsKeysGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAwsConnectionIdKmsKeysGet(region, destination, connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAwsConnectionIdKmsKeysGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified AWS Connection.
         * @param {string} connectionId The ID of the AWS Connection to be updated.
         * @param {ApiV1AppConnectionsAwsConnectionIdPatchRequest} [apiV1AppConnectionsAwsConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAwsConnectionIdPatch(connectionId: string, apiV1AppConnectionsAwsConnectionIdPatchRequest?: ApiV1AppConnectionsAwsConnectionIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAwsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAwsConnectionIdPatch(connectionId, apiV1AppConnectionsAwsConnectionIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAwsConnectionIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified AWS Connection by name.
         * @param {string} connectionName The name of the AWS Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAwsConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAwsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAwsConnectionNameConnectionNameGet(connectionName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAwsConnectionNameConnectionNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the AWS Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAwsGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAwsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAwsGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAwsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an AWS Connection for the current organization.
         * @param {ApiV1AppConnectionsAwsPostRequest} [apiV1AppConnectionsAwsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAwsPost(apiV1AppConnectionsAwsPostRequest?: ApiV1AppConnectionsAwsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAwsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAwsPost(apiV1AppConnectionsAwsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAwsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Azure App Configuration Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureAppConfigurationAvailableGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationAvailableGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureAppConfigurationAvailableGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureAppConfigurationAvailableGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified Azure App Configuration Connection.
         * @param {string} connectionId The ID of the Azure App Configuration Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureAppConfigurationConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureAppConfigurationConnectionIdDelete(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureAppConfigurationConnectionIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Azure App Configuration Connection by ID.
         * @param {string} connectionId The ID of the Azure App Configuration Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureAppConfigurationConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureAppConfigurationConnectionIdGet(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureAppConfigurationConnectionIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified Azure App Configuration Connection.
         * @param {string} connectionId The ID of the Azure App Configuration Connection to be updated.
         * @param {ApiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest} [apiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureAppConfigurationConnectionIdPatch(connectionId: string, apiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest?: ApiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureAppConfigurationConnectionIdPatch(connectionId, apiV1AppConnectionsAzureAppConfigurationConnectionIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureAppConfigurationConnectionIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Azure App Configuration Connection by name.
         * @param {string} connectionName The name of the Azure App Configuration Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureAppConfigurationConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureAppConfigurationConnectionNameConnectionNameGet(connectionName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureAppConfigurationConnectionNameConnectionNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Azure App Configuration Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureAppConfigurationGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureAppConfigurationGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureAppConfigurationGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an Azure App Configuration Connection for the current organization.
         * @param {ApiV1AppConnectionsAzureAppConfigurationPostRequest} [apiV1AppConnectionsAzureAppConfigurationPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureAppConfigurationPost(apiV1AppConnectionsAzureAppConfigurationPostRequest?: ApiV1AppConnectionsAzureAppConfigurationPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureAppConfigurationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureAppConfigurationPost(apiV1AppConnectionsAzureAppConfigurationPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureAppConfigurationPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Azure Key Vault Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureKeyVaultAvailableGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultAvailableGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureKeyVaultAvailableGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureKeyVaultAvailableGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified Azure Key Vault Connection.
         * @param {string} connectionId The ID of the Azure Key Vault Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureKeyVaultConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureKeyVaultConnectionIdDelete(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureKeyVaultConnectionIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Azure Key Vault Connection by ID.
         * @param {string} connectionId The ID of the Azure Key Vault Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureKeyVaultConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureKeyVaultConnectionIdGet(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureKeyVaultConnectionIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified Azure Key Vault Connection.
         * @param {string} connectionId The ID of the Azure Key Vault Connection to be updated.
         * @param {ApiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest} [apiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureKeyVaultConnectionIdPatch(connectionId: string, apiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest?: ApiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureKeyVaultConnectionIdPatch(connectionId, apiV1AppConnectionsAzureKeyVaultConnectionIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureKeyVaultConnectionIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Azure Key Vault Connection by name.
         * @param {string} connectionName The name of the Azure Key Vault Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureKeyVaultConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureKeyVaultConnectionNameConnectionNameGet(connectionName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureKeyVaultConnectionNameConnectionNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Azure Key Vault Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureKeyVaultGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureKeyVaultGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureKeyVaultGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an Azure Key Vault Connection for the current organization.
         * @param {ApiV1AppConnectionsAzureKeyVaultPostRequest} [apiV1AppConnectionsAzureKeyVaultPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsAzureKeyVaultPost(apiV1AppConnectionsAzureKeyVaultPostRequest?: ApiV1AppConnectionsAzureKeyVaultPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsAzureKeyVaultPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsAzureKeyVaultPost(apiV1AppConnectionsAzureKeyVaultPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsAzureKeyVaultPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Databricks Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsDatabricksAvailableGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsDatabricksAvailableGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsDatabricksAvailableGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsDatabricksAvailableGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified Databricks Connection.
         * @param {string} connectionId The ID of the Databricks Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsDatabricksConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsDatabricksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsDatabricksConnectionIdDelete(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsDatabricksConnectionIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Databricks Connection by ID.
         * @param {string} connectionId The ID of the Databricks Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsDatabricksConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsDatabricksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsDatabricksConnectionIdGet(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsDatabricksConnectionIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified Databricks Connection.
         * @param {string} connectionId The ID of the Databricks Connection to be updated.
         * @param {ApiV1AppConnectionsDatabricksConnectionIdPatchRequest} [apiV1AppConnectionsDatabricksConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsDatabricksConnectionIdPatch(connectionId: string, apiV1AppConnectionsDatabricksConnectionIdPatchRequest?: ApiV1AppConnectionsDatabricksConnectionIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsDatabricksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsDatabricksConnectionIdPatch(connectionId, apiV1AppConnectionsDatabricksConnectionIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsDatabricksConnectionIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsDatabricksConnectionIdSecretScopesGet(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsDatabricksConnectionIdSecretScopesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsDatabricksConnectionIdSecretScopesGet(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsDatabricksConnectionIdSecretScopesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Databricks Connection by name.
         * @param {string} connectionName The name of the Databricks Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsDatabricksConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsDatabricksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsDatabricksConnectionNameConnectionNameGet(connectionName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsDatabricksConnectionNameConnectionNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Databricks Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsDatabricksGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsDatabricksGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsDatabricksGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsDatabricksGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Databricks Connection for the current organization.
         * @param {ApiV1AppConnectionsDatabricksPostRequest} [apiV1AppConnectionsDatabricksPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsDatabricksPost(apiV1AppConnectionsDatabricksPostRequest?: ApiV1AppConnectionsDatabricksPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsDatabricksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsDatabricksPost(apiV1AppConnectionsDatabricksPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsDatabricksPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the GCP Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGcpAvailableGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGcpAvailableGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGcpAvailableGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGcpAvailableGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified GCP Connection.
         * @param {string} connectionId The ID of the GCP Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGcpConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGcpPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGcpConnectionIdDelete(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGcpConnectionIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified GCP Connection by ID.
         * @param {string} connectionId The ID of the GCP Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGcpConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGcpPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGcpConnectionIdGet(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGcpConnectionIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified GCP Connection.
         * @param {string} connectionId The ID of the GCP Connection to be updated.
         * @param {ApiV1AppConnectionsGcpConnectionIdPatchRequest} [apiV1AppConnectionsGcpConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGcpConnectionIdPatch(connectionId: string, apiV1AppConnectionsGcpConnectionIdPatchRequest?: ApiV1AppConnectionsGcpConnectionIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGcpPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGcpConnectionIdPatch(connectionId, apiV1AppConnectionsGcpConnectionIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGcpConnectionIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGcpConnectionIdSecretManagerProjectsGet(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV1SecretSnapshotSecretSnapshotIdGet200ResponseSecretSnapshotFolderVersionInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGcpConnectionIdSecretManagerProjectsGet(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGcpConnectionIdSecretManagerProjectsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified GCP Connection by name.
         * @param {string} connectionName The name of the GCP Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGcpConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGcpPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGcpConnectionNameConnectionNameGet(connectionName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGcpConnectionNameConnectionNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the GCP Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGcpGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGcpGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGcpGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGcpGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a GCP Connection for the current organization.
         * @param {ApiV1AppConnectionsGcpPostRequest} [apiV1AppConnectionsGcpPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGcpPost(apiV1AppConnectionsGcpPostRequest?: ApiV1AppConnectionsGcpPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGcpPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGcpPost(apiV1AppConnectionsGcpPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGcpPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all the App Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the GitHub Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGithubAvailableGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGithubAvailableGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGithubAvailableGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGithubAvailableGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified GitHub Connection.
         * @param {string} connectionId The ID of the GitHub Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGithubConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGithubPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGithubConnectionIdDelete(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGithubConnectionIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repo 
         * @param {string} owner 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGithubConnectionIdEnvironmentsGet(repo: string, owner: string, connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGithubConnectionIdEnvironmentsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGithubConnectionIdEnvironmentsGet(repo, owner, connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGithubConnectionIdEnvironmentsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified GitHub Connection by ID.
         * @param {string} connectionId The ID of the GitHub Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGithubConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGithubPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGithubConnectionIdGet(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGithubConnectionIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGithubConnectionIdOrganizationsGet(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGithubConnectionIdOrganizationsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGithubConnectionIdOrganizationsGet(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGithubConnectionIdOrganizationsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified GitHub Connection.
         * @param {string} connectionId The ID of the GitHub Connection to be updated.
         * @param {ApiV1AppConnectionsGithubConnectionIdPatchRequest} [apiV1AppConnectionsGithubConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGithubConnectionIdPatch(connectionId: string, apiV1AppConnectionsGithubConnectionIdPatchRequest?: ApiV1AppConnectionsGithubConnectionIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGithubPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGithubConnectionIdPatch(connectionId, apiV1AppConnectionsGithubConnectionIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGithubConnectionIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGithubConnectionIdRepositoriesGet(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGithubConnectionIdRepositoriesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGithubConnectionIdRepositoriesGet(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGithubConnectionIdRepositoriesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified GitHub Connection by name.
         * @param {string} connectionName The name of the GitHub Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGithubConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGithubPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGithubConnectionNameConnectionNameGet(connectionName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGithubConnectionNameConnectionNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the GitHub Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGithubGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGithubGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGithubGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGithubGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a GitHub Connection for the current organization.
         * @param {ApiV1AppConnectionsGithubPostRequest} [apiV1AppConnectionsGithubPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsGithubPost(apiV1AppConnectionsGithubPostRequest?: ApiV1AppConnectionsGithubPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsGithubPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsGithubPost(apiV1AppConnectionsGithubPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsGithubPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Humanitec Connections the current user has permission to establish connections with.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsHumanitecAvailableGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsHumanitecAvailableGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsHumanitecAvailableGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsHumanitecAvailableGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified Humanitec Connection.
         * @param {string} connectionId The ID of the Humanitec Connection to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsHumanitecConnectionIdDelete(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsHumanitecPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsHumanitecConnectionIdDelete(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsHumanitecConnectionIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Humanitec Connection by ID.
         * @param {string} connectionId The ID of the Humanitec Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsHumanitecConnectionIdGet(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsHumanitecPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsHumanitecConnectionIdGet(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsHumanitecConnectionIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsHumanitecConnectionIdOrganizationsGet(connectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV1AppConnectionsHumanitecConnectionIdOrganizationsGet200ResponseInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsHumanitecConnectionIdOrganizationsGet(connectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsHumanitecConnectionIdOrganizationsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified Humanitec Connection.
         * @param {string} connectionId The ID of the Humanitec Connection to be updated.
         * @param {ApiV1AppConnectionsHumanitecConnectionIdPatchRequest} [apiV1AppConnectionsHumanitecConnectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsHumanitecConnectionIdPatch(connectionId: string, apiV1AppConnectionsHumanitecConnectionIdPatchRequest?: ApiV1AppConnectionsHumanitecConnectionIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsHumanitecPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsHumanitecConnectionIdPatch(connectionId, apiV1AppConnectionsHumanitecConnectionIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsHumanitecConnectionIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Humanitec Connection by name.
         * @param {string} connectionName The name of the Humanitec Connection to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsHumanitecConnectionNameConnectionNameGet(connectionName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsHumanitecPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsHumanitecConnectionNameConnectionNameGet(connectionName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsHumanitecConnectionNameConnectionNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Humanitec Connections for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsHumanitecGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsHumanitecGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsHumanitecGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsHumanitecGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Humanitec Connection for the current organization.
         * @param {ApiV1AppConnectionsHumanitecPostRequest} [apiV1AppConnectionsHumanitecPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsHumanitecPost(apiV1AppConnectionsHumanitecPostRequest?: ApiV1AppConnectionsHumanitecPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsHumanitecPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsHumanitecPost(apiV1AppConnectionsHumanitecPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsHumanitecPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the available App Connection Options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppConnectionsOptionsGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AppConnectionsOptionsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AppConnectionsOptionsGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AppConnectionsOptionsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List Audit Log Streams.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuditLogStreamsGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuditLogStreamsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuditLogStreamsGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuditLogStreamsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an Audit Log Stream by ID.
         * @param {string} id The ID of the audit log stream to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuditLogStreamsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuditLogStreamsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuditLogStreamsIdDelete(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuditLogStreamsIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an Audit Log Stream by ID.
         * @param {string} id The ID of the audit log stream to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuditLogStreamsIdGet(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuditLogStreamsIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuditLogStreamsIdGet(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuditLogStreamsIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an Audit Log Stream by ID.
         * @param {string} id The ID of the audit log stream to update.
         * @param {ApiV1AuditLogStreamsIdPatchRequest} [apiV1AuditLogStreamsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuditLogStreamsIdPatch(id: string, apiV1AuditLogStreamsIdPatchRequest?: ApiV1AuditLogStreamsIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuditLogStreamsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuditLogStreamsIdPatch(id, apiV1AuditLogStreamsIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuditLogStreamsIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an Audit Log Stream.
         * @param {ApiV1AuditLogStreamsPostRequest} apiV1AuditLogStreamsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuditLogStreamsPost(apiV1AuditLogStreamsPostRequest: ApiV1AuditLogStreamsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuditLogStreamsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuditLogStreamsPost(apiV1AuditLogStreamsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuditLogStreamsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete AWS Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthAwsAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthAwsAuthIdentitiesIdentityIdDelete(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthAwsAuthIdentitiesIdentityIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve AWS Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthAwsAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthAwsAuthIdentitiesIdentityIdGet(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthAwsAuthIdentitiesIdentityIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update AWS Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthAwsAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthAwsAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthAwsAuthIdentitiesIdentityIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach AWS Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthAwsAuthIdentitiesIdentityIdPostRequest} [apiV1AuthAwsAuthIdentitiesIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthAwsAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthAwsAuthIdentitiesIdentityIdPostRequest?: ApiV1AuthAwsAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthAwsAuthIdentitiesIdentityIdPost(identityId, apiV1AuthAwsAuthIdentitiesIdentityIdPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthAwsAuthIdentitiesIdentityIdPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login with AWS Auth
         * @param {ApiV1AuthAwsAuthLoginPostRequest} apiV1AuthAwsAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthAwsAuthLoginPost(apiV1AuthAwsAuthLoginPostRequest: ApiV1AuthAwsAuthLoginPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthAwsAuthLoginPost(apiV1AuthAwsAuthLoginPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthAwsAuthLoginPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Azure Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthAzureAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthAzureAuthIdentitiesIdentityIdDelete(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthAzureAuthIdentitiesIdentityIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Azure Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthAzureAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthAzureAuthIdentitiesIdentityIdGet(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthAzureAuthIdentitiesIdentityIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Azure Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthAzureAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthAzureAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthAzureAuthIdentitiesIdentityIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach Azure Auth configuration onto identity
         * @param {string} identityId The ID of the identity to login.
         * @param {ApiV1AuthAzureAuthIdentitiesIdentityIdPostRequest} apiV1AuthAzureAuthIdentitiesIdentityIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthAzureAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthAzureAuthIdentitiesIdentityIdPostRequest: ApiV1AuthAzureAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthAzureAuthIdentitiesIdentityIdPost(identityId, apiV1AuthAzureAuthIdentitiesIdentityIdPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthAzureAuthIdentitiesIdentityIdPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login with Azure Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthAzureAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthAzureAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthAzureAuthLoginPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthCheckAuthPost(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthCheckAuthPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthCheckAuthPost(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthCheckAuthPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete GCP Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthGcpAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthGcpAuthIdentitiesIdentityIdDelete(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthGcpAuthIdentitiesIdentityIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve GCP Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthGcpAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthGcpAuthIdentitiesIdentityIdGet(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthGcpAuthIdentitiesIdentityIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update GCP Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthGcpAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthGcpAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthGcpAuthIdentitiesIdentityIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach GCP Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequest} apiV1AuthGcpAuthIdentitiesIdentityIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthGcpAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthGcpAuthIdentitiesIdentityIdPostRequest: ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthGcpAuthIdentitiesIdentityIdPost(identityId, apiV1AuthGcpAuthIdentitiesIdentityIdPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthGcpAuthIdentitiesIdentityIdPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login with GCP Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthGcpAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthGcpAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthGcpAuthLoginPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete JWT Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthJwtAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthJwtAuthIdentitiesIdentityIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthJwtAuthIdentitiesIdentityIdDelete(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthJwtAuthIdentitiesIdentityIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve JWT Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthJwtAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthJwtAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthJwtAuthIdentitiesIdentityIdGet(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthJwtAuthIdentitiesIdentityIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update JWT Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthJwtAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthJwtAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthJwtAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthJwtAuthIdentitiesIdentityIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthJwtAuthIdentitiesIdentityIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach JWT Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequest} [apiV1AuthJwtAuthIdentitiesIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthJwtAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthJwtAuthIdentitiesIdentityIdPostRequest?: ApiV1AuthJwtAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthJwtAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthJwtAuthIdentitiesIdentityIdPost(identityId, apiV1AuthJwtAuthIdentitiesIdentityIdPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthJwtAuthIdentitiesIdentityIdPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login with JWT Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthJwtAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthJwtAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthJwtAuthLoginPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Kubernetes Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthKubernetesAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthKubernetesAuthIdentitiesIdentityIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthKubernetesAuthIdentitiesIdentityIdDelete(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthKubernetesAuthIdentitiesIdentityIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Kubernetes Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthKubernetesAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthKubernetesAuthIdentitiesIdentityIdGet(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthKubernetesAuthIdentitiesIdentityIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Kubernetes Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthKubernetesAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthKubernetesAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthKubernetesAuthIdentitiesIdentityIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach Kubernetes Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest} apiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthKubernetesAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest: ApiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthKubernetesAuthIdentitiesIdentityIdPost(identityId, apiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthKubernetesAuthIdentitiesIdentityIdPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login with Kubernetes Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthKubernetesAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthKubernetesAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthKubernetesAuthLoginPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthLogoutPost(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthLogoutPost(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthLogoutPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete OIDC Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthOidcAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthOidcAuthIdentitiesIdentityIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthOidcAuthIdentitiesIdentityIdDelete(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthOidcAuthIdentitiesIdentityIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve OIDC Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthOidcAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthOidcAuthIdentitiesIdentityIdGet(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthOidcAuthIdentitiesIdentityIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update OIDC Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthOidcAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthOidcAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthOidcAuthIdentitiesIdentityIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach OIDC Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthOidcAuthIdentitiesIdentityIdPostRequest} apiV1AuthOidcAuthIdentitiesIdentityIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthOidcAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthOidcAuthIdentitiesIdentityIdPostRequest: ApiV1AuthOidcAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthOidcAuthIdentitiesIdentityIdPost(identityId, apiV1AuthOidcAuthIdentitiesIdentityIdPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthOidcAuthIdentitiesIdentityIdPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login with OIDC Auth
         * @param {ApiV1AuthKubernetesAuthLoginPostRequest} apiV1AuthKubernetesAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthOidcAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest: ApiV1AuthKubernetesAuthLoginPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthOidcAuthLoginPost(apiV1AuthKubernetesAuthLoginPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthOidcAuthLoginPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Token Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthTokenAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthTokenAuthIdentitiesIdentityIdDelete(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthTokenAuthIdentitiesIdentityIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Token Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthTokenAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthTokenAuthIdentitiesIdentityIdGet(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthTokenAuthIdentitiesIdentityIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Token Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthTokenAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthTokenAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthTokenAuthIdentitiesIdentityIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach Token Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthTokenAuthIdentitiesIdentityIdPostRequest} [apiV1AuthTokenAuthIdentitiesIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthTokenAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthTokenAuthIdentitiesIdentityIdPostRequest?: ApiV1AuthTokenAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthTokenAuthIdentitiesIdentityIdPost(identityId, apiV1AuthTokenAuthIdentitiesIdentityIdPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthTokenAuthIdentitiesIdentityIdPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get tokens for identity with Token Auth
         * @param {string} identityId The ID of the identity to list token metadata for.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th token.
         * @param {number} [limit] The number of tokens to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthTokenAuthIdentitiesIdentityIdTokensGet(identityId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthTokenAuthIdentitiesIdentityIdTokensGet(identityId, offset, limit, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthTokenAuthIdentitiesIdentityIdTokensGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create token for identity with Token Auth
         * @param {string} identityId The ID of the identity to create the token for.
         * @param {ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest} [apiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthTokenAuthIdentitiesIdentityIdTokensPost(identityId: string, apiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest?: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthTokenAuthIdentitiesIdentityIdTokensPost(identityId, apiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthTokenAuthIdentitiesIdentityIdTokensPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update token for identity with Token Auth
         * @param {string} tokenId The ID of the token to update metadata for.
         * @param {ApiV1AuthTokenAuthTokensTokenIdPatchRequest} [apiV1AuthTokenAuthTokensTokenIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthTokenAuthTokensTokenIdPatch(tokenId: string, apiV1AuthTokenAuthTokensTokenIdPatchRequest?: ApiV1AuthTokenAuthTokensTokenIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthTokensTokenIdPatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthTokenAuthTokensTokenIdPatch(tokenId, apiV1AuthTokenAuthTokensTokenIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthTokenAuthTokensTokenIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke token for identity with Token Auth
         * @param {string} tokenId The ID of the token to revoke.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthTokenAuthTokensTokenIdRevokePost(tokenId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthTokenAuthTokensTokenIdRevokePost(tokenId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthTokenAuthTokensTokenIdRevokePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthTokenPost(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthTokenPost(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthTokenPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Renew access token
         * @param {ApiV1AuthTokenRenewPostRequest} apiV1AuthTokenRenewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthTokenRenewPost(apiV1AuthTokenRenewPostRequest: ApiV1AuthTokenRenewPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthTokenRenewPost(apiV1AuthTokenRenewPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthTokenRenewPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke access token
         * @param {ApiV1AuthTokenRevokePostRequest} apiV1AuthTokenRevokePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthTokenRevokePost(apiV1AuthTokenRevokePostRequest: ApiV1AuthTokenRevokePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthTokenRevokePost(apiV1AuthTokenRevokePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthTokenRevokePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Universal Auth Client Secret for identity
         * @param {string} identityId The ID of the identity to get the client secret from.
         * @param {string} clientSecretId The ID of the client secret to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet(identityId: string, clientSecretId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet(identityId, clientSecretId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke Universal Auth Client Secrets for identity
         * @param {string} identityId The ID of the identity to revoke the client secret from.
         * @param {string} clientSecretId The ID of the client secret to revoke.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdRevokePost(identityId: string, clientSecretId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdRevokePost(identityId, clientSecretId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdRevokePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List Universal Auth Client Secrets for identity
         * @param {string} identityId The ID of the identity to list client secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Universal Auth Client Secret for identity
         * @param {string} identityId The ID of the identity to create a client secret for.
         * @param {ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest} [apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost(identityId: string, apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest?: ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost(identityId, apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Universal Auth configuration on identity
         * @param {string} identityId The ID of the identity to revoke the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthUniversalAuthIdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthUniversalAuthIdentitiesIdentityIdDelete(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthUniversalAuthIdentitiesIdentityIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve Universal Auth configuration on identity
         * @param {string} identityId The ID of the identity to retrieve the auth method for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthUniversalAuthIdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthUniversalAuthIdentitiesIdentityIdGet(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthUniversalAuthIdentitiesIdentityIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Universal Auth configuration on identity
         * @param {string} identityId The ID of the identity to update the auth method for.
         * @param {ApiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest} [apiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthUniversalAuthIdentitiesIdentityIdPatch(identityId: string, apiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest?: ApiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthUniversalAuthIdentitiesIdentityIdPatch(identityId, apiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthUniversalAuthIdentitiesIdentityIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach Universal Auth configuration onto identity
         * @param {string} identityId The ID of the identity to attach the configuration onto.
         * @param {ApiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest} [apiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthUniversalAuthIdentitiesIdentityIdPost(identityId: string, apiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest?: ApiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthUniversalAuthIdentitiesIdentityIdPost(identityId, apiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthUniversalAuthIdentitiesIdentityIdPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login with Universal Auth
         * @param {ApiV1AuthUniversalAuthLoginPostRequest} apiV1AuthUniversalAuthLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthUniversalAuthLoginPost(apiV1AuthUniversalAuthLoginPostRequest: ApiV1AuthUniversalAuthLoginPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1AuthUniversalAuthLoginPost(apiV1AuthUniversalAuthLoginPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1AuthUniversalAuthLoginPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} botId 
         * @param {ApiV1BotBotIdActivePatchRequest} apiV1BotBotIdActivePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BotBotIdActivePatch(botId: string, apiV1BotBotIdActivePatchRequest: ApiV1BotBotIdActivePatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1BotProjectIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1BotBotIdActivePatch(botId, apiV1BotBotIdActivePatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1BotBotIdActivePatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BotProjectIdGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1BotProjectIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1BotProjectIdGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1BotProjectIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} environment 
         * @param {string} [secretPath] 
         * @param {ApiV1DashboardAccessibleSecretsGetFilterByActionEnum} [filterByAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DashboardAccessibleSecretsGet(projectId: string, environment: string, secretPath?: string, filterByAction?: ApiV1DashboardAccessibleSecretsGetFilterByActionEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DashboardAccessibleSecretsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DashboardAccessibleSecretsGet(projectId, environment, secretPath, filterByAction, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DashboardAccessibleSecretsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} environment 
         * @param {string} keys 
         * @param {string} [secretPath] 
         * @param {ApiV1FoldersGetRecursiveParameter} [viewSecretValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DashboardSecretsByKeysGet(projectId: string, environment: string, keys: string, secretPath?: string, viewSecretValue?: ApiV1FoldersGetRecursiveParameter, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DashboardSecretsByKeysGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DashboardSecretsByKeysGet(projectId, environment, keys, secretPath, viewSecretValue, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DashboardSecretsByKeysGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} environments 
         * @param {string} [secretPath] 
         * @param {string} [search] 
         * @param {string} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DashboardSecretsDeepSearchGet(projectId: string, environments: string, secretPath?: string, search?: string, tags?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DashboardSecretsDeepSearchGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DashboardSecretsDeepSearchGet(projectId, environments, secretPath, search, tags, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DashboardSecretsDeepSearchGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List project secrets details
         * @param {string} projectId The ID of the project to list secrets/folders from.
         * @param {string} environment The slug of the environment to list secrets/folders from.
         * @param {string} [secretPath] The secret path to list secrets/folders from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th secret/folder.
         * @param {number} [limit] The number of secrets/folders to return.
         * @param {ApiV1DashboardSecretsDetailsGetOrderByEnum} [orderBy] The column to order secrets/folders by.
         * @param {ApiV1DashboardSecretsDetailsGetOrderDirectionEnum} [orderDirection] The direction to order secrets/folders in.
         * @param {string} [search] The text string to filter secret keys and folder names by.
         * @param {string} [tags] The tags to filter secrets by (comma separated, ie \&amp;#39;tags&amp;#x3D;billing,engineering\&amp;#39;).
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [viewSecretValue] 
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeSecrets] Whether to include project secrets in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeFolders] Whether to include project folders in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeDynamicSecrets] Whether to include dynamic project secrets in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeImports] Whether to include project secret imports in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DashboardSecretsDetailsGet(projectId: string, environment: string, secretPath?: string, offset?: number, limit?: number, orderBy?: ApiV1DashboardSecretsDetailsGetOrderByEnum, orderDirection?: ApiV1DashboardSecretsDetailsGetOrderDirectionEnum, search?: string, tags?: string, viewSecretValue?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeSecrets?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeFolders?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeDynamicSecrets?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeImports?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DashboardSecretsDetailsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DashboardSecretsDetailsGet(projectId, environment, secretPath, offset, limit, orderBy, orderDirection, search, tags, viewSecretValue, includeSecrets, includeFolders, includeDynamicSecrets, includeImports, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DashboardSecretsDetailsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List project secrets overview
         * @param {string} projectId The ID of the project to list secrets/folders from.
         * @param {string} environments The slugs of the environments to list secrets/folders from (comma separated, ie \&amp;#39;environments&amp;#x3D;dev,staging,prod\&amp;#39;).
         * @param {string} [secretPath] The secret path to list secrets/folders from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th secret/folder.
         * @param {number} [limit] The number of secrets/folders to return.
         * @param {ApiV1DashboardSecretsOverviewGetOrderByEnum} [orderBy] The column to order secrets/folders by.
         * @param {ApiV1DashboardSecretsOverviewGetOrderDirectionEnum} [orderDirection] The direction to order secrets/folders in.
         * @param {string} [search] The text string to filter secret keys and folder names by.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeSecrets] Whether to include project secrets in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeFolders] Whether to include project folders in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeImports] Whether to include project secret imports in the response.
         * @param {ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter} [includeDynamicSecrets] Whether to include dynamic project secrets in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DashboardSecretsOverviewGet(projectId: string, environments: string, secretPath?: string, offset?: number, limit?: number, orderBy?: ApiV1DashboardSecretsOverviewGetOrderByEnum, orderDirection?: ApiV1DashboardSecretsOverviewGetOrderDirectionEnum, search?: string, includeSecrets?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeFolders?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeImports?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, includeDynamicSecrets?: ApiV1DashboardSecretsOverviewGetIncludeSecretsParameter, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DashboardSecretsOverviewGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DashboardSecretsOverviewGet(projectId, environments, secretPath, offset, limit, orderBy, orderDirection, search, includeSecrets, includeFolders, includeImports, includeDynamicSecrets, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DashboardSecretsOverviewGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1DynamicSecretsEntraIdUsersPostRequest} apiV1DynamicSecretsEntraIdUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DynamicSecretsEntraIdUsersPost(apiV1DynamicSecretsEntraIdUsersPostRequest: ApiV1DynamicSecretsEntraIdUsersPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV1DynamicSecretsEntraIdUsersPost200ResponseInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DynamicSecretsEntraIdUsersPost(apiV1DynamicSecretsEntraIdUsersPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DynamicSecretsEntraIdUsersPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project to create dynamic secret in.
         * @param {string} environmentSlug The slug of the environment to list folders from.
         * @param {string} [path] The path to list folders from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DynamicSecretsGet(projectSlug: string, environmentSlug: string, path?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DynamicSecretsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DynamicSecretsGet(projectSlug, environmentSlug, path, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DynamicSecretsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} leaseId The ID of the dynamic secret lease.
         * @param {ApiV1DynamicSecretsLeasesLeaseIdDeleteRequest} apiV1DynamicSecretsLeasesLeaseIdDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DynamicSecretsLeasesLeaseIdDelete(leaseId: string, apiV1DynamicSecretsLeasesLeaseIdDeleteRequest: ApiV1DynamicSecretsLeasesLeaseIdDeleteRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DynamicSecretsLeasesLeaseIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DynamicSecretsLeasesLeaseIdDelete(leaseId, apiV1DynamicSecretsLeasesLeaseIdDeleteRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DynamicSecretsLeasesLeaseIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project to create dynamic secret in.
         * @param {string} environmentSlug The slug of the environment to list folders from.
         * @param {string} leaseId The ID of the dynamic secret lease.
         * @param {string} [path] The path to list folders from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DynamicSecretsLeasesLeaseIdGet(projectSlug: string, environmentSlug: string, leaseId: string, path?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DynamicSecretsLeasesLeaseIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DynamicSecretsLeasesLeaseIdGet(projectSlug, environmentSlug, leaseId, path, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DynamicSecretsLeasesLeaseIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} leaseId The ID of the dynamic secret lease.
         * @param {ApiV1DynamicSecretsLeasesLeaseIdRenewPostRequest} apiV1DynamicSecretsLeasesLeaseIdRenewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DynamicSecretsLeasesLeaseIdRenewPost(leaseId: string, apiV1DynamicSecretsLeasesLeaseIdRenewPostRequest: ApiV1DynamicSecretsLeasesLeaseIdRenewPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DynamicSecretsLeasesLeaseIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DynamicSecretsLeasesLeaseIdRenewPost(leaseId, apiV1DynamicSecretsLeasesLeaseIdRenewPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DynamicSecretsLeasesLeaseIdRenewPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1DynamicSecretsLeasesPostRequest} apiV1DynamicSecretsLeasesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DynamicSecretsLeasesPost(apiV1DynamicSecretsLeasesPostRequest: ApiV1DynamicSecretsLeasesPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DynamicSecretsLeasesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DynamicSecretsLeasesPost(apiV1DynamicSecretsLeasesPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DynamicSecretsLeasesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name The name of the dynamic secret.
         * @param {ApiV1DynamicSecretsNameDeleteRequest} apiV1DynamicSecretsNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DynamicSecretsNameDelete(name: string, apiV1DynamicSecretsNameDeleteRequest: ApiV1DynamicSecretsNameDeleteRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DynamicSecretsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DynamicSecretsNameDelete(name, apiV1DynamicSecretsNameDeleteRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DynamicSecretsNameDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project to create dynamic secret in.
         * @param {string} environmentSlug The slug of the environment to list folders from.
         * @param {string} name The name of the dynamic secret.
         * @param {string} [path] The path to list folders from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DynamicSecretsNameGet(projectSlug: string, environmentSlug: string, name: string, path?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DynamicSecretsNameGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DynamicSecretsNameGet(projectSlug, environmentSlug, name, path, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DynamicSecretsNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project to create dynamic secret in.
         * @param {string} environmentSlug The slug of the environment to list folders from.
         * @param {string} name The name of the dynamic secret.
         * @param {string} [path] The path to list folders from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DynamicSecretsNameLeasesGet(projectSlug: string, environmentSlug: string, name: string, path?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DynamicSecretsNameLeasesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DynamicSecretsNameLeasesGet(projectSlug, environmentSlug, name, path, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DynamicSecretsNameLeasesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name The name of the dynamic secret.
         * @param {ApiV1DynamicSecretsNamePatchRequest} apiV1DynamicSecretsNamePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DynamicSecretsNamePatch(name: string, apiV1DynamicSecretsNamePatchRequest: ApiV1DynamicSecretsNamePatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DynamicSecretsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DynamicSecretsNamePatch(name, apiV1DynamicSecretsNamePatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DynamicSecretsNamePatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1DynamicSecretsPostRequest} apiV1DynamicSecretsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DynamicSecretsPost(apiV1DynamicSecretsPostRequest: ApiV1DynamicSecretsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1DynamicSecretsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1DynamicSecretsPost(apiV1DynamicSecretsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1DynamicSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ExternalGroupMappingsGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV1ExternalGroupMappingsGet200ResponseInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ExternalGroupMappingsGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ExternalGroupMappingsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ExternalGroupMappingsPutRequest} apiV1ExternalGroupMappingsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ExternalGroupMappingsPut(apiV1ExternalGroupMappingsPutRequest: ApiV1ExternalGroupMappingsPutRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV1ExternalGroupMappingsGet200ResponseInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ExternalGroupMappingsPut(apiV1ExternalGroupMappingsPutRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ExternalGroupMappingsPut&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ExternalKmsGcpKeysPostRequest} [apiV1ExternalKmsGcpKeysPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ExternalKmsGcpKeysPost(apiV1ExternalKmsGcpKeysPostRequest?: ApiV1ExternalKmsGcpKeysPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ExternalKmsGcpKeysPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ExternalKmsGcpKeysPost(apiV1ExternalKmsGcpKeysPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ExternalKmsGcpKeysPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ExternalKmsGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ExternalKmsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ExternalKmsGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ExternalKmsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ExternalKmsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ExternalKmsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ExternalKmsIdDelete(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ExternalKmsIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ExternalKmsIdGet(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ExternalKmsIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ExternalKmsIdGet(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ExternalKmsIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1ExternalKmsIdPatchRequest} apiV1ExternalKmsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ExternalKmsIdPatch(id: string, apiV1ExternalKmsIdPatchRequest: ApiV1ExternalKmsIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ExternalKmsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ExternalKmsIdPatch(id, apiV1ExternalKmsIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ExternalKmsIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ExternalKmsNameNameGet(name: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ExternalKmsIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ExternalKmsNameNameGet(name, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ExternalKmsNameNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ExternalKmsPostRequest} apiV1ExternalKmsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ExternalKmsPost(apiV1ExternalKmsPostRequest: ApiV1ExternalKmsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ExternalKmsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ExternalKmsPost(apiV1ExternalKmsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ExternalKmsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update folders by batch
         * @param {ApiV1FoldersBatchPatchRequest} apiV1FoldersBatchPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1FoldersBatchPatch(apiV1FoldersBatchPatchRequest: ApiV1FoldersBatchPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1FoldersBatchPatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1FoldersBatchPatch(apiV1FoldersBatchPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1FoldersBatchPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a folder
         * @param {string} folderIdOrName The ID or name of the folder to delete.
         * @param {ApiV1FoldersFolderIdOrNameDeleteRequest} apiV1FoldersFolderIdOrNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1FoldersFolderIdOrNameDelete(folderIdOrName: string, apiV1FoldersFolderIdOrNameDeleteRequest: ApiV1FoldersFolderIdOrNameDeleteRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1FoldersPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1FoldersFolderIdOrNameDelete(folderIdOrName, apiV1FoldersFolderIdOrNameDeleteRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1FoldersFolderIdOrNameDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update folder
         * @param {string} folderId The ID of the folder to update.
         * @param {ApiV1FoldersFolderIdPatchRequest} apiV1FoldersFolderIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1FoldersFolderIdPatch(folderId: string, apiV1FoldersFolderIdPatchRequest: ApiV1FoldersFolderIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1FoldersPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1FoldersFolderIdPatch(folderId, apiV1FoldersFolderIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1FoldersFolderIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get folders
         * @param {string} workspaceId The ID of the project to list folders from.
         * @param {string} environment The slug of the environment to list folders from.
         * @param {string} [path] The path to list folders from.
         * @param {string} [directory] The directory to list folders from. (Deprecated in favor of path)
         * @param {ApiV1FoldersGetRecursiveParameter} [recursive] Whether or not to fetch all folders from the specified base path, and all of its subdirectories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1FoldersGet(workspaceId: string, environment: string, path?: string, directory?: string, recursive?: ApiV1FoldersGetRecursiveParameter, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1FoldersGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1FoldersGet(workspaceId, environment, path, directory, recursive, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1FoldersGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get folder by id
         * @param {string} id The ID of the folder to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1FoldersIdGet(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1FoldersIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1FoldersIdGet(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1FoldersIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create folders
         * @param {ApiV1FoldersPostRequest} apiV1FoldersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1FoldersPost(apiV1FoldersPostRequest: ApiV1FoldersPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1FoldersPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1FoldersPost(apiV1FoldersPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1FoldersPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1GatewaysExchangeCertPostRequest} apiV1GatewaysExchangeCertPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GatewaysExchangeCertPost(apiV1GatewaysExchangeCertPostRequest: ApiV1GatewaysExchangeCertPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GatewaysExchangeCertPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GatewaysExchangeCertPost(apiV1GatewaysExchangeCertPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GatewaysExchangeCertPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [projectId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GatewaysGet(projectId?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GatewaysGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GatewaysGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GatewaysGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GatewaysHeartbeatPost(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GatewaysHeartbeatPost(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GatewaysHeartbeatPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GatewaysIdDelete(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GatewaysIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GatewaysIdDelete(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GatewaysIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GatewaysIdGet(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GatewaysIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GatewaysIdGet(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GatewaysIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1GatewaysIdPatchRequest} [apiV1GatewaysIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GatewaysIdPatch(id: string, apiV1GatewaysIdPatchRequest?: ApiV1GatewaysIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GatewaysIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GatewaysIdPatch(id, apiV1GatewaysIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GatewaysIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GatewaysProjectsProjectIdGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GatewaysProjectsProjectIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GatewaysProjectsProjectIdGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GatewaysProjectsProjectIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GatewaysRegisterIdentityPost(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GatewaysRegisterIdentityPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GatewaysRegisterIdentityPost(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GatewaysRegisterIdentityPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GroupsGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV1GroupsGet200ResponseInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GroupsGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GroupsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id The ID of the group to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GroupsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GroupsGet200ResponseInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GroupsIdDelete(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GroupsIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id The ID of the group to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GroupsIdGet(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GroupsGet200ResponseInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GroupsIdGet(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GroupsIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id The ID of the group to update.
         * @param {ApiV1GroupsIdPatchRequest} [apiV1GroupsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GroupsIdPatch(id: string, apiV1GroupsIdPatchRequest?: ApiV1GroupsIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GroupsGet200ResponseInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GroupsIdPatch(id, apiV1GroupsIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GroupsIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id The ID of the group to list users for.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th user.
         * @param {number} [limit] The number of users to return.
         * @param {string} [username] The username to search for.
         * @param {string} [search] The text string that user email or name will be filtered by.
         * @param {ApiV1GroupsIdUsersGetFilterEnum} [filter] Whether to filter the list of returned users. \&amp;#39;existingMembers\&amp;#39; will only return existing users in the group, \&amp;#39;nonMembers\&amp;#39; will only return users not in the group, undefined will return all users in the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GroupsIdUsersGet(id: string, offset?: number, limit?: number, username?: string, search?: string, filter?: ApiV1GroupsIdUsersGetFilterEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GroupsIdUsersGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GroupsIdUsersGet(id, offset, limit, username, search, filter, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GroupsIdUsersGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id The ID of the group to remove the user from.
         * @param {string} username The username of the user to remove from the group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GroupsIdUsersUsernameDelete(id: string, username: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GroupsIdUsersUsernamePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GroupsIdUsersUsernameDelete(id, username, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GroupsIdUsersUsernameDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id The ID of the group to add the user to.
         * @param {string} username The username of the user to add to the group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GroupsIdUsersUsernamePost(id: string, username: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GroupsIdUsersUsernamePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GroupsIdUsersUsernamePost(id, username, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GroupsIdUsersUsernamePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1GroupsPostRequest} apiV1GroupsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1GroupsPost(apiV1GroupsPostRequest: ApiV1GroupsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1GroupsGet200ResponseInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1GroupsPost(apiV1GroupsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1GroupsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List identities
         * @param {string} orgId The ID of the organization to list identities.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IdentitiesGet(orgId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IdentitiesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IdentitiesGet(orgId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IdentitiesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete identity
         * @param {string} identityId The ID of the identity to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IdentitiesIdentityIdDelete(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IdentitiesIdentityIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IdentitiesIdentityIdDelete(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IdentitiesIdentityIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an identity by id
         * @param {string} identityId The ID of the identity to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IdentitiesIdentityIdGet(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IdentitiesIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IdentitiesIdentityIdGet(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IdentitiesIdentityIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List project memberships that identity with id is part of
         * @param {string} identityId The ID of the identity to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IdentitiesIdentityIdIdentityMembershipsGet(identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IdentitiesIdentityIdIdentityMembershipsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IdentitiesIdentityIdIdentityMembershipsGet(identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IdentitiesIdentityIdIdentityMembershipsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update identity
         * @param {string} identityId The ID of the identity to update.
         * @param {ApiV1IdentitiesIdentityIdPatchRequest} [apiV1IdentitiesIdentityIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IdentitiesIdentityIdPatch(identityId: string, apiV1IdentitiesIdentityIdPatchRequest?: ApiV1IdentitiesIdentityIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IdentitiesIdentityIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IdentitiesIdentityIdPatch(identityId, apiV1IdentitiesIdentityIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IdentitiesIdentityIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create identity
         * @param {ApiV1IdentitiesPostRequest} apiV1IdentitiesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IdentitiesPost(apiV1IdentitiesPostRequest: ApiV1IdentitiesPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IdentitiesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IdentitiesPost(apiV1IdentitiesPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IdentitiesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create the integration authentication object required for syncing secrets.
         * @param {ApiV1IntegrationAuthAccessTokenPostRequest} apiV1IntegrationAuthAccessTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthAccessTokenPost(apiV1IntegrationAuthAccessTokenPostRequest: ApiV1IntegrationAuthAccessTokenPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthAccessTokenPost(apiV1IntegrationAuthAccessTokenPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthAccessTokenPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove all integration\&#x27;s auth object from the project.
         * @param {string} integration The slug of the integration to be unauthorized.
         * @param {string} projectId The ID of the project to delete the integration auth from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthDelete(integration: string, projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthDelete(integration, projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {string} [teamId] 
         * @param {string} [azureDevOpsOrgName] 
         * @param {string} [workspaceSlug] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdAppsGet(integrationAuthId: string, teamId?: string, azureDevOpsOrgName?: string, workspaceSlug?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdAppsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdAppsGet(integrationAuthId, teamId, azureDevOpsOrgName, workspaceSlug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdAppsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} region 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet(region: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet(region, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceSlug 
         * @param {string} repoSlug 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdBitbucketEnvironmentsGet(workspaceSlug: string, repoSlug: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdBitbucketEnvironmentsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdBitbucketEnvironmentsGet(workspaceSlug, repoSlug, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdBitbucketEnvironmentsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet(integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet(integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet(accountId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet(accountId, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdCircleciOrganizationsGet(integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdCircleciOrganizationsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdCircleciOrganizationsGet(integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdCircleciOrganizationsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an integration auth object by object id.
         * @param {string} integrationAuthId The ID of integration authentication object to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdDelete(integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdDelete(integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {ApiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest} apiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdDuplicatePost(integrationAuthId: string, apiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest: ApiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdDuplicatePost(integrationAuthId, apiV1IntegrationAuthIntegrationAuthIdDuplicatePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdDuplicatePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of an integration authorization by auth object id.
         * @param {string} integrationAuthId The ID of integration authentication object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdGet(integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdGet(integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} repoOwner 
         * @param {string} repoName 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet(repoOwner: string, repoName: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet(repoOwner, repoName, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet(integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet(integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet(integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet(integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet(appId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet(appId, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGetScopeEnum} scope 
         * @param {string} spaceId 
         * @param {string} resourceId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGet(scope: ApiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGetScopeEnum, spaceId: string, resourceId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGet(scope, spaceId, resourceId, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdOctopusDeployScopeValuesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdOctopusDeploySpacesGet(integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdOctopusDeploySpacesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdOctopusDeploySpacesGet(integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdOctopusDeploySpacesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the integration authentication object required for syncing secrets.
         * @param {string} integrationAuthId The ID of integration authentication object to update.
         * @param {ApiV1IntegrationAuthIntegrationAuthIdPatchRequest} [apiV1IntegrationAuthIntegrationAuthIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdPatch(integrationAuthId: string, apiV1IntegrationAuthIntegrationAuthIdPatchRequest?: ApiV1IntegrationAuthIntegrationAuthIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdPatch(integrationAuthId, apiV1IntegrationAuthIntegrationAuthIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} environmentId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet(environmentId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet(environmentId, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} environmentId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet(environmentId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet(environmentId, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet(projectId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet(projectId, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} environmentId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet(environmentId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet(environmentId, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdQoveryOrgsGet(integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdQoveryOrgsGet(integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdQoveryOrgsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet(orgId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet(orgId, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdRailwayEnvironmentsGet(appId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdRailwayEnvironmentsGet(appId, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdRailwayEnvironmentsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet(appId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet(appId, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet(appId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet(appId, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdTeamsGet(integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdTeamsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdTeamsGet(integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdTeamsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} appId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet(appId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet(appId, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} teamId 
         * @param {string} integrationAuthId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationAuthIdVercelCustomEnvironmentsGet(teamId: string, integrationAuthId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdVercelCustomEnvironmentsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationAuthIdVercelCustomEnvironmentsGet(teamId, integrationAuthId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationAuthIdVercelCustomEnvironmentsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of integrations available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthIntegrationOptionsGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationOptionsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthIntegrationOptionsGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthIntegrationOptionsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1IntegrationAuthOauthTokenPostRequest} apiV1IntegrationAuthOauthTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationAuthOauthTokenPost(apiV1IntegrationAuthOauthTokenPostRequest: ApiV1IntegrationAuthOauthTokenPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationAuthIntegrationAuthIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationAuthOauthTokenPost(apiV1IntegrationAuthOauthTokenPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationAuthOauthTokenPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an integration using the integration object ID
         * @param {string} integrationId The ID of the integration object.
         * @param {ApiV1IntegrationIntegrationIdDeleteShouldDeleteIntegrationSecretsEnum} [shouldDeleteIntegrationSecrets] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationIntegrationIdDelete(integrationId: string, shouldDeleteIntegrationSecrets?: ApiV1IntegrationIntegrationIdDeleteShouldDeleteIntegrationSecretsEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationIntegrationIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationIntegrationIdDelete(integrationId, shouldDeleteIntegrationSecrets, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationIntegrationIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an integration by integration id
         * @param {string} integrationId The ID of the integration object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationIntegrationIdGet(integrationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationIntegrationIdGet(integrationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationIntegrationIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an integration by integration id
         * @param {string} integrationId The ID of the integration object.
         * @param {ApiV1IntegrationIntegrationIdPatchRequest} [apiV1IntegrationIntegrationIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationIntegrationIdPatch(integrationId: string, apiV1IntegrationIntegrationIdPatchRequest?: ApiV1IntegrationIntegrationIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationIntegrationIdPatch(integrationId, apiV1IntegrationIntegrationIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationIntegrationIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Manually trigger sync of an integration by integration id
         * @param {string} integrationId The ID of the integration object to manually sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationIntegrationIdSyncPost(integrationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationIntegrationIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationIntegrationIdSyncPost(integrationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationIntegrationIdSyncPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an integration to sync secrets.
         * @param {ApiV1IntegrationPostRequest} apiV1IntegrationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1IntegrationPost(apiV1IntegrationPostRequest: ApiV1IntegrationPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1IntegrationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1IntegrationPost(apiV1IntegrationPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1IntegrationPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1InviteOrgSignupPostRequest} apiV1InviteOrgSignupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1InviteOrgSignupPost(apiV1InviteOrgSignupPostRequest: ApiV1InviteOrgSignupPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1InviteOrgSignupPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1InviteOrgSignupPost(apiV1InviteOrgSignupPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1InviteOrgSignupPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1InviteOrgSignupResendPostRequest} apiV1InviteOrgSignupResendPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1InviteOrgSignupResendPost(apiV1InviteOrgSignupResendPostRequest: ApiV1InviteOrgSignupResendPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1InviteOrgSignupResendPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1InviteOrgSignupResendPost(apiV1InviteOrgSignupResendPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1InviteOrgSignupResendPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1InviteOrgVerifyPostRequest} apiV1InviteOrgVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1InviteOrgVerifyPost(apiV1InviteOrgVerifyPostRequest: ApiV1InviteOrgVerifyPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1InviteOrgVerifyPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1InviteOrgVerifyPost(apiV1InviteOrgVerifyPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1InviteOrgVerifyPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List KMIP clients
         * @param {string} projectId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {ApiV1KmipClientsGetOrderByEnum} [orderBy] 
         * @param {ApiV1KmipClientsGetOrderDirectionEnum} [orderDirection] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipClientsGet(projectId: string, offset?: number, limit?: number, orderBy?: ApiV1KmipClientsGetOrderByEnum, orderDirection?: ApiV1KmipClientsGetOrderDirectionEnum, search?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipClientsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipClientsGet(projectId, offset, limit, orderBy, orderDirection, search, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipClientsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1KmipClientsIdCertificatesPostRequest} apiV1KmipClientsIdCertificatesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipClientsIdCertificatesPost(id: string, apiV1KmipClientsIdCertificatesPostRequest: ApiV1KmipClientsIdCertificatesPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipClientsIdCertificatesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipClientsIdCertificatesPost(id, apiV1KmipClientsIdCertificatesPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipClientsIdCertificatesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipClientsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipClientsGet200ResponseKmipClientsInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipClientsIdDelete(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipClientsIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipClientsIdGet(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipClientsGet200ResponseKmipClientsInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipClientsIdGet(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipClientsIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1KmipClientsIdPatchRequest} apiV1KmipClientsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipClientsIdPatch(id: string, apiV1KmipClientsIdPatchRequest: ApiV1KmipClientsIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipClientsGet200ResponseKmipClientsInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipClientsIdPatch(id, apiV1KmipClientsIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipClientsIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1KmipClientsPostRequest} apiV1KmipClientsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipClientsPost(apiV1KmipClientsPostRequest: ApiV1KmipClientsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipClientsGet200ResponseKmipClientsInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipClientsPost(apiV1KmipClientsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipClientsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1KmipPostRequest} apiV1KmipPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipPost(apiV1KmipPostRequest: ApiV1KmipPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipPost(apiV1KmipPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1KmipServerRegistrationPostRequest} apiV1KmipServerRegistrationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipServerRegistrationPost(apiV1KmipServerRegistrationPostRequest: ApiV1KmipServerRegistrationPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipServerRegistrationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipServerRegistrationPost(apiV1KmipServerRegistrationPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipServerRegistrationPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * KMIP endpoint for activating managed object
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipSpecActivatePost(apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipSpecActivatePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipSpecActivatePost(apiV1SecretRotationsRestartPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipSpecActivatePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * KMIP endpoint for creating managed objects
         * @param {ApiV1KmipSpecCreatePostRequest} apiV1KmipSpecCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipSpecCreatePost(apiV1KmipSpecCreatePostRequest: ApiV1KmipSpecCreatePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipSpecCreatePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipSpecCreatePost(apiV1KmipSpecCreatePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipSpecCreatePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * KMIP endpoint for destroying managed objects
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipSpecDestroyPost(apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretRotationsRestartPostRequest&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipSpecDestroyPost(apiV1SecretRotationsRestartPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipSpecDestroyPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * KMIP endpoint for getting attributes of managed object
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipSpecGetAttributesPost(apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipSpecGetAttributesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipSpecGetAttributesPost(apiV1SecretRotationsRestartPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipSpecGetAttributesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * KMIP endpoint for getting managed objects
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipSpecGetPost(apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipSpecGetPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipSpecGetPost(apiV1SecretRotationsRestartPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipSpecGetPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * KMIP endpoint for locating managed objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipSpecLocatePost(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipSpecLocatePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipSpecLocatePost(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipSpecLocatePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * KMIP endpoint for registering managed object
         * @param {ApiV1KmipSpecRegisterPostRequest} apiV1KmipSpecRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipSpecRegisterPost(apiV1KmipSpecRegisterPostRequest: ApiV1KmipSpecRegisterPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretRotationsRestartPostRequest&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipSpecRegisterPost(apiV1KmipSpecRegisterPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipSpecRegisterPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * KMIP endpoint for revoking managed object
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmipSpecRevokePost(apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmipSpecRevokePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmipSpecRevokePost(apiV1SecretRotationsRestartPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmipSpecRevokePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List KMS keys
         * @param {string} projectId The ID of the project to list keys from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th key.
         * @param {number} [limit] The number of keys to return.
         * @param {ApiV1KmsKeysGetOrderByEnum} [orderBy] The column to order keys by.
         * @param {ApiV1KmsKeysGetOrderDirectionEnum} [orderDirection] The direction to order keys in.
         * @param {string} [search] The text string to filter key names by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmsKeysGet(projectId: string, offset?: number, limit?: number, orderBy?: ApiV1KmsKeysGetOrderByEnum, orderDirection?: ApiV1KmsKeysGetOrderDirectionEnum, search?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmsKeysGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmsKeysGet(projectId, offset, limit, orderBy, orderDirection, search, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmsKeysGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Decrypt data with KMS key
         * @param {string} keyId The ID of the key to decrypt the data with.
         * @param {ApiV1KmsKeysKeyIdDecryptPostRequest} apiV1KmsKeysKeyIdDecryptPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmsKeysKeyIdDecryptPost(keyId: string, apiV1KmsKeysKeyIdDecryptPostRequest: ApiV1KmsKeysKeyIdDecryptPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmsKeysKeyIdDecryptPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmsKeysKeyIdDecryptPost(keyId, apiV1KmsKeysKeyIdDecryptPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmsKeysKeyIdDecryptPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete KMS key
         * @param {string} keyId The ID of the key to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmsKeysKeyIdDelete(keyId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmsKeysPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmsKeysKeyIdDelete(keyId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmsKeysKeyIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Encrypt data with KMS key
         * @param {string} keyId The ID of the key to encrypt the data with.
         * @param {ApiV1KmsKeysKeyIdEncryptPostRequest} apiV1KmsKeysKeyIdEncryptPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmsKeysKeyIdEncryptPost(keyId: string, apiV1KmsKeysKeyIdEncryptPostRequest: ApiV1KmsKeysKeyIdEncryptPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmsKeysKeyIdEncryptPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmsKeysKeyIdEncryptPost(keyId, apiV1KmsKeysKeyIdEncryptPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmsKeysKeyIdEncryptPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get KMS key by ID
         * @param {string} keyId The ID of the KMS key to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmsKeysKeyIdGet(keyId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmsKeysPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmsKeysKeyIdGet(keyId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmsKeysKeyIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update KMS key
         * @param {string} keyId The ID of the key to be updated.
         * @param {ApiV1KmsKeysKeyIdPatchRequest} [apiV1KmsKeysKeyIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmsKeysKeyIdPatch(keyId: string, apiV1KmsKeysKeyIdPatchRequest?: ApiV1KmsKeysKeyIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmsKeysPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmsKeysKeyIdPatch(keyId, apiV1KmsKeysKeyIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmsKeysKeyIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get KMS key by Name
         * @param {string} projectId The ID of the project the key belongs to.
         * @param {string} keyName The name of the KMS key to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmsKeysKeyNameKeyNameGet(projectId: string, keyName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmsKeysPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmsKeysKeyNameKeyNameGet(projectId, keyName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmsKeysKeyNameKeyNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create KMS key
         * @param {ApiV1KmsKeysPostRequest} apiV1KmsKeysPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1KmsKeysPost(apiV1KmsKeysPostRequest: ApiV1KmsKeysPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1KmsKeysPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1KmsKeysPost(apiV1KmsKeysPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1KmsKeysPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} configId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LdapConfigConfigIdGroupMapsGet(configId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV1LdapConfigConfigIdGroupMapsGet200ResponseInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1LdapConfigConfigIdGroupMapsGet(configId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1LdapConfigConfigIdGroupMapsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} configId 
         * @param {string} groupMapId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LdapConfigConfigIdGroupMapsGroupMapIdDelete(configId: string, groupMapId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1LdapConfigConfigIdGroupMapsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1LdapConfigConfigIdGroupMapsGroupMapIdDelete(configId, groupMapId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1LdapConfigConfigIdGroupMapsGroupMapIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} configId 
         * @param {ApiV1LdapConfigConfigIdGroupMapsPostRequest} apiV1LdapConfigConfigIdGroupMapsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LdapConfigConfigIdGroupMapsPost(configId: string, apiV1LdapConfigConfigIdGroupMapsPostRequest: ApiV1LdapConfigConfigIdGroupMapsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1LdapConfigConfigIdGroupMapsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1LdapConfigConfigIdGroupMapsPost(configId, apiV1LdapConfigConfigIdGroupMapsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1LdapConfigConfigIdGroupMapsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} configId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LdapConfigConfigIdTestConnectionPost(configId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;boolean&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1LdapConfigConfigIdTestConnectionPost(configId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1LdapConfigConfigIdTestConnectionPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LdapConfigGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1LdapConfigGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1LdapConfigGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1LdapConfigGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1LdapConfigPatchRequest} apiV1LdapConfigPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LdapConfigPatch(apiV1LdapConfigPatchRequest: ApiV1LdapConfigPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1LdapConfigPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1LdapConfigPatch(apiV1LdapConfigPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1LdapConfigPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1LdapConfigPostRequest} apiV1LdapConfigPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LdapConfigPost(apiV1LdapConfigPostRequest: ApiV1LdapConfigPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1LdapConfigPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1LdapConfigPost(apiV1LdapConfigPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1LdapConfigPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1LdapLoginPostRequest} apiV1LdapLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LdapLoginPost(apiV1LdapLoginPostRequest: ApiV1LdapLoginPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1LdapLoginPost(apiV1LdapLoginPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1LdapLoginPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationAdminProjectsGet(search?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationAdminProjectsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationAdminProjectsGet(search, offset, limit, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationAdminProjectsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all audit logs for an organization
         * @param {string} [projectId] Optionally filter logs by project ID. If not provided, logs from the entire organization will be returned.
         * @param {ApiV1OrganizationAuditLogsGetActorTypeEnum} [actorType] 
         * @param {string} [secretPath] The path of the secret to query audit logs for. Note that the projectId parameter must also be provided.
         * @param {string} [eventType] 
         * @param {ApiV1OrganizationAuditLogsGetUserAgentTypeEnum} [userAgentType] Choose which consuming application to export audit logs for.
         * @param {string} [eventMetadata] Filter by event metadata key-value pairs. Formatted as &amp;#x60;key1&amp;#x3D;value1,key2&amp;#x3D;value2&amp;#x60;, with comma-separation.
         * @param {string} [startDate] The date to start the export from.
         * @param {string} [endDate] The date to end the export at.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th audit log.
         * @param {number} [limit] The number of audit logs to return.
         * @param {string} [actor] The actor to filter the audit logs by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationAuditLogsGet(projectId?: string, actorType?: ApiV1OrganizationAuditLogsGetActorTypeEnum, secretPath?: string, eventType?: string, userAgentType?: ApiV1OrganizationAuditLogsGetUserAgentTypeEnum, eventMetadata?: string, startDate?: string, endDate?: string, offset?: number, limit?: number, actor?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationAuditLogsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationAuditLogsGet(projectId, actorType, secretPath, eventType, userAgentType, eventMetadata, startDate, endDate, offset, limit, actor, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationAuditLogsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId The ID of the organization to list groups for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdGroupsGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdGroupsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdGroupsGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdGroupsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdIncidentContactOrgGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdIncidentContactOrgGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdIncidentContactOrgGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdIncidentContactOrgGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} incidentContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdIncidentContactOrgIncidentContactIdDelete(organizationId: string, incidentContactId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdIncidentContactOrgPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdIncidentContactOrgIncidentContactIdDelete(organizationId, incidentContactId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdIncidentContactOrgIncidentContactIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1PasswordEmailPasswordResetPostRequest} apiV1PasswordEmailPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdIncidentContactOrgPost(organizationId: string, apiV1PasswordEmailPasswordResetPostRequest: ApiV1PasswordEmailPasswordResetPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdIncidentContactOrgPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdIncidentContactOrgPost(organizationId, apiV1PasswordEmailPasswordResetPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdIncidentContactOrgPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdIntegrationAuthorizationsGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdIntegrationAuthorizationsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdIntegrationAuthorizationsGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdIntegrationAuthorizationsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationOrganizationIdPatchRequest} [apiV1OrganizationOrganizationIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdPatch(organizationId: string, apiV1OrganizationOrganizationIdPatchRequest?: ApiV1OrganizationOrganizationIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdPatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdPatch(organizationId, apiV1OrganizationOrganizationIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdPermissionsGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdPermissionsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdPermissionsGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdPermissionsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdRolesGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdRolesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdRolesGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdRolesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationOrganizationIdRolesPostRequest} apiV1OrganizationOrganizationIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdRolesPost(organizationId: string, apiV1OrganizationOrganizationIdRolesPostRequest: ApiV1OrganizationOrganizationIdRolesPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdRolesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdRolesPost(organizationId, apiV1OrganizationOrganizationIdRolesPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdRolesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdRolesRoleIdDelete(organizationId: string, roleId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdRolesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdRolesRoleIdDelete(organizationId, roleId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdRolesRoleIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdRolesRoleIdGet(organizationId: string, roleId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdRolesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdRolesRoleIdGet(organizationId, roleId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdRolesRoleIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} roleId 
         * @param {ApiV1OrganizationOrganizationIdRolesRoleIdPatchRequest} [apiV1OrganizationOrganizationIdRolesRoleIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdRolesRoleIdPatch(organizationId: string, roleId: string, apiV1OrganizationOrganizationIdRolesRoleIdPatchRequest?: ApiV1OrganizationOrganizationIdRolesRoleIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdRolesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdRolesRoleIdPatch(organizationId, roleId, apiV1OrganizationOrganizationIdRolesRoleIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdRolesRoleIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationOrganizationIdUsersGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdUsersGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationOrganizationIdUsersGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationOrganizationIdUsersGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdBillingDetailsGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdBillingDetailsGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdBillingDetailsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationsOrganizationIdBillingDetailsPatchRequest} [apiV1OrganizationsOrganizationIdBillingDetailsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdBillingDetailsPatch(organizationId: string, apiV1OrganizationsOrganizationIdBillingDetailsPatchRequest?: ApiV1OrganizationsOrganizationIdBillingDetailsPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdBillingDetailsPatch(organizationId, apiV1OrganizationsOrganizationIdBillingDetailsPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdBillingDetailsPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} pmtMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPmtMethodIdDelete(organizationId: string, pmtMethodId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPmtMethodIdDelete(organizationId, pmtMethodId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPmtMethodIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest} apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPost(organizationId: string, apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest: ApiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPost(organizationId, apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest} apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPost(organizationId: string, apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest: ApiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPost(organizationId, apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} taxId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsTaxIdDelete(organizationId: string, taxId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsTaxIdDelete(organizationId, taxId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdBillingDetailsTaxIdsTaxIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdCustomerPortalSessionPost(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdCustomerPortalSessionPost(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdCustomerPortalSessionPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdInvoicesGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdInvoicesGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdInvoicesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdLicensesGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdLicensesGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdLicensesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdPlanBillingGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdPlanBillingGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdPlanBillingGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdPlanGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationsOrganizationIdPlanGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdPlanGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdPlanGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdPlanTableGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdPlanTableGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdPlanTableGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} [workspaceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdPlansGet(organizationId: string, workspaceId?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdPlansGet(organizationId, workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdPlansGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1OrganizationsOrganizationIdPlansTableGetBillingCycleEnum} billingCycle 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdPlansTableGet(billingCycle: ApiV1OrganizationsOrganizationIdPlansTableGetBillingCycleEnum, organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdPlansTableGet(billingCycle, organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdPlansTableGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {ApiV1OrganizationsOrganizationIdSessionTrialPostRequest} apiV1OrganizationsOrganizationIdSessionTrialPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OrganizationsOrganizationIdSessionTrialPost(organizationId: string, apiV1OrganizationsOrganizationIdSessionTrialPostRequest: ApiV1OrganizationsOrganizationIdSessionTrialPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1OrganizationsOrganizationIdSessionTrialPost(organizationId, apiV1OrganizationsOrganizationIdSessionTrialPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1OrganizationsOrganizationIdSessionTrialPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PasswordBackupPrivateKeyGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PasswordBackupPrivateKeyGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PasswordBackupPrivateKeyGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PasswordBackupPrivateKeyGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PasswordBackupPrivateKeyPostRequest} apiV1PasswordBackupPrivateKeyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PasswordBackupPrivateKeyPost(apiV1PasswordBackupPrivateKeyPostRequest: ApiV1PasswordBackupPrivateKeyPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PasswordBackupPrivateKeyGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PasswordBackupPrivateKeyPost(apiV1PasswordBackupPrivateKeyPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PasswordBackupPrivateKeyPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PasswordChangePasswordPostRequest} apiV1PasswordChangePasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PasswordChangePasswordPost(apiV1PasswordChangePasswordPostRequest: ApiV1PasswordChangePasswordPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PasswordChangePasswordPost(apiV1PasswordChangePasswordPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PasswordChangePasswordPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PasswordEmailPasswordResetPostRequest} apiV1PasswordEmailPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PasswordEmailPasswordResetPost(apiV1PasswordEmailPasswordResetPostRequest: ApiV1PasswordEmailPasswordResetPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PasswordEmailPasswordResetPost(apiV1PasswordEmailPasswordResetPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PasswordEmailPasswordResetPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PasswordEmailPasswordResetVerifyPostRequest} apiV1PasswordEmailPasswordResetVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PasswordEmailPasswordResetVerifyPost(apiV1PasswordEmailPasswordResetVerifyPostRequest: ApiV1PasswordEmailPasswordResetVerifyPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PasswordEmailPasswordResetVerifyPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PasswordEmailPasswordResetVerifyPost(apiV1PasswordEmailPasswordResetVerifyPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PasswordEmailPasswordResetVerifyPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PasswordEmailPasswordSetupPost(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PasswordEmailPasswordSetupPost(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PasswordEmailPasswordSetupPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PasswordPasswordResetPostRequest} apiV1PasswordPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PasswordPasswordResetPost(apiV1PasswordPasswordResetPostRequest: ApiV1PasswordPasswordResetPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PasswordPasswordResetPost(apiV1PasswordPasswordResetPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PasswordPasswordResetPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PasswordPasswordSetupPostRequest} apiV1PasswordPasswordSetupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PasswordPasswordSetupPost(apiV1PasswordPasswordSetupPostRequest: ApiV1PasswordPasswordSetupPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PasswordPasswordSetupPost(apiV1PasswordPasswordSetupPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PasswordPasswordSetupPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PasswordSrp1PostRequest} apiV1PasswordSrp1PostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PasswordSrp1Post(apiV1PasswordSrp1PostRequest: ApiV1PasswordSrp1PostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PasswordSrp1Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PasswordSrp1Post(apiV1PasswordSrp1PostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PasswordSrp1Post&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete PKI alert
         * @param {string} alertId The ID of the alert to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiAlertsAlertIdDelete(alertId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiAlertsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiAlertsAlertIdDelete(alertId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiAlertsAlertIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get PKI alert
         * @param {string} alertId The ID of the alert to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiAlertsAlertIdGet(alertId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiAlertsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiAlertsAlertIdGet(alertId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiAlertsAlertIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update PKI alert
         * @param {string} alertId The ID of the alert to update.
         * @param {ApiV1PkiAlertsAlertIdPatchRequest} [apiV1PkiAlertsAlertIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiAlertsAlertIdPatch(alertId: string, apiV1PkiAlertsAlertIdPatchRequest?: ApiV1PkiAlertsAlertIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiAlertsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiAlertsAlertIdPatch(alertId, apiV1PkiAlertsAlertIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiAlertsAlertIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create PKI alert
         * @param {ApiV1PkiAlertsPostRequest} apiV1PkiAlertsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiAlertsPost(apiV1PkiAlertsPostRequest: ApiV1PkiAlertsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiAlertsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiAlertsPost(apiV1PkiAlertsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiAlertsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of past and current CA certificates for a CA
         * @param {string} caId The ID of the CA to get the CA certificates for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdCaCertificatesGet(caId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV1PkiCaCaIdCaCertificatesGet200ResponseInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdCaCertificatesGet(caId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdCaCertificatesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current CA cert and cert chain of a CA
         * @param {string} caId The ID of the CA to get the certificate body and certificate chain from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdCertificateGet(caId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaCaIdCertificateGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdCertificateGet(caId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdCertificateGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of certificate templates for the CA
         * @param {string} caId The ID of the CA to issue the certificate from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdCertificateTemplatesGet(caId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaCaIdCertificateTemplatesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdCertificateTemplatesGet(caId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdCertificateTemplatesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get DER-encoded certificate of CA
         * @param {string} caId The ID of the CA to get the CA certificate from.
         * @param {string} caCertId The ID of the CA certificate to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdCertificatesCaCertIdDerGet(caId: string, caCertId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdCertificatesCaCertIdDerGet(caId, caCertId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdCertificatesCaCertIdDerGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of CRLs of the CA
         * @param {string} caId The ID of the CA to get the certificate revocation lists (CRLs) for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdCrlsGet(caId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV1PkiCaCaIdCrlsGet200ResponseInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdCrlsGet(caId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdCrlsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CA CSR
         * @param {string} caId The ID of the CA to generate CSR from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdCsrGet(caId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaCaIdCsrGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdCsrGet(caId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdCsrGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete CA
         * @param {string} caId The ID of the CA to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdDelete(caId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdDelete(caId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CA
         * @param {string} caId The ID of the CA to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdGet(caId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdGet(caId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import certificate and chain to CA
         * @param {string} caId The ID of the CA to import the certificate for.
         * @param {ApiV1PkiCaCaIdImportCertificatePostRequest} apiV1PkiCaCaIdImportCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdImportCertificatePost(caId: string, apiV1PkiCaCaIdImportCertificatePostRequest: ApiV1PkiCaCaIdImportCertificatePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaCaIdImportCertificatePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdImportCertificatePost(caId, apiV1PkiCaCaIdImportCertificatePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdImportCertificatePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Issue certificate from CA
         * @param {string} caId The ID of the CA to issue the certificate from.
         * @param {ApiV1PkiCaCaIdIssueCertificatePostRequest} apiV1PkiCaCaIdIssueCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdIssueCertificatePost(caId: string, apiV1PkiCaCaIdIssueCertificatePostRequest: ApiV1PkiCaCaIdIssueCertificatePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaCaIdIssueCertificatePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdIssueCertificatePost(caId, apiV1PkiCaCaIdIssueCertificatePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdIssueCertificatePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update CA
         * @param {string} caId The ID of the CA to update.
         * @param {ApiV1PkiCaCaIdPatchRequest} [apiV1PkiCaCaIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdPatch(caId: string, apiV1PkiCaCaIdPatchRequest?: ApiV1PkiCaCaIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdPatch(caId, apiV1PkiCaCaIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Perform CA certificate renewal
         * @param {string} caId The ID of the CA to renew the CA certificate for.
         * @param {ApiV1PkiCaCaIdRenewPostRequest} apiV1PkiCaCaIdRenewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdRenewPost(caId: string, apiV1PkiCaCaIdRenewPostRequest: ApiV1PkiCaCaIdRenewPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaCaIdRenewPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdRenewPost(caId, apiV1PkiCaCaIdRenewPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdRenewPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sign certificate from CA
         * @param {string} caId The ID of the CA to issue the certificate from.
         * @param {ApiV1PkiCaCaIdSignCertificatePostRequest} apiV1PkiCaCaIdSignCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdSignCertificatePost(caId: string, apiV1PkiCaCaIdSignCertificatePostRequest: ApiV1PkiCaCaIdSignCertificatePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaCaIdSignCertificatePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdSignCertificatePost(caId, apiV1PkiCaCaIdSignCertificatePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdSignCertificatePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create intermediate CA certificate from parent CA
         * @param {string} caId The ID of the CA to sign the intermediate certificate with.
         * @param {ApiV1PkiCaCaIdSignIntermediatePostRequest} apiV1PkiCaCaIdSignIntermediatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaCaIdSignIntermediatePost(caId: string, apiV1PkiCaCaIdSignIntermediatePostRequest: ApiV1PkiCaCaIdSignIntermediatePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaCaIdSignIntermediatePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaCaIdSignIntermediatePost(caId, apiV1PkiCaCaIdSignIntermediatePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaCaIdSignIntermediatePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create CA
         * @param {ApiV1PkiCaPostRequest} apiV1PkiCaPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCaPost(apiV1PkiCaPostRequest: ApiV1PkiCaPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCaPost(apiV1PkiCaPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCaPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the certificate template to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCertificateTemplatesCertificateTemplateIdDelete(certificateTemplateId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCertificateTemplatesCertificateTemplateIdDelete(certificateTemplateId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCertificateTemplatesCertificateTemplateIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Certificate Template EST configuration
         * @param {string} certificateTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigGet(certificateTemplateId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigGet(certificateTemplateId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Certificate Template EST configuration
         * @param {string} certificateTemplateId 
         * @param {ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest} [apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatch(certificateTemplateId: string, apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest?: ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatch(certificateTemplateId, apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Certificate Template EST configuration
         * @param {string} certificateTemplateId 
         * @param {ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest} apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPost(certificateTemplateId: string, apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest: ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPost(certificateTemplateId, apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCertificateTemplatesCertificateTemplateIdEstConfigPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the certificate template to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCertificateTemplatesCertificateTemplateIdGet(certificateTemplateId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCertificateTemplatesCertificateTemplateIdGet(certificateTemplateId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCertificateTemplatesCertificateTemplateIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the certificate template to update.
         * @param {ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest} [apiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCertificateTemplatesCertificateTemplateIdPatch(certificateTemplateId: string, apiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest?: ApiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCertificateTemplatesCertificateTemplateIdPatch(certificateTemplateId, apiV1PkiCertificateTemplatesCertificateTemplateIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCertificateTemplatesCertificateTemplateIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PkiCertificateTemplatesPostRequest} apiV1PkiCertificateTemplatesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCertificateTemplatesPost(apiV1PkiCertificateTemplatesPostRequest: ApiV1PkiCertificateTemplatesPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCertificateTemplatesCertificateTemplateIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCertificateTemplatesPost(apiV1PkiCertificateTemplatesPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCertificateTemplatesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Issue certificate
         * @param {ApiV1PkiCertificatesIssueCertificatePostRequest} apiV1PkiCertificatesIssueCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCertificatesIssueCertificatePost(apiV1PkiCertificatesIssueCertificatePostRequest: ApiV1PkiCertificatesIssueCertificatePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaCaIdIssueCertificatePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCertificatesIssueCertificatePost(apiV1PkiCertificatesIssueCertificatePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCertificatesIssueCertificatePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get certificate body of certificate
         * @param {string} serialNumber The serial number of the certificate to get the certificate body and certificate chain for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCertificatesSerialNumberCertificateGet(serialNumber: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCertificatesSerialNumberCertificateGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCertificatesSerialNumberCertificateGet(serialNumber, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCertificatesSerialNumberCertificateGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete certificate
         * @param {string} serialNumber The serial number of the certificate to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCertificatesSerialNumberDelete(serialNumber: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCertificatesSerialNumberGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCertificatesSerialNumberDelete(serialNumber, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCertificatesSerialNumberDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get certificate
         * @param {string} serialNumber The serial number of the certificate to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCertificatesSerialNumberGet(serialNumber: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCertificatesSerialNumberGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCertificatesSerialNumberGet(serialNumber, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCertificatesSerialNumberGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke
         * @param {string} serialNumber The serial number of the certificate to revoke. The revoked certificate will be added to the certificate revocation list (CRL) of the CA.
         * @param {ApiV1PkiCertificatesSerialNumberRevokePostRequest} apiV1PkiCertificatesSerialNumberRevokePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCertificatesSerialNumberRevokePost(serialNumber: string, apiV1PkiCertificatesSerialNumberRevokePostRequest: ApiV1PkiCertificatesSerialNumberRevokePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCertificatesSerialNumberRevokePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCertificatesSerialNumberRevokePost(serialNumber, apiV1PkiCertificatesSerialNumberRevokePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCertificatesSerialNumberRevokePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sign certificate
         * @param {ApiV1PkiCertificatesSignCertificatePostRequest} apiV1PkiCertificatesSignCertificatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCertificatesSignCertificatePost(apiV1PkiCertificatesSignCertificatePostRequest: ApiV1PkiCertificatesSignCertificatePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCaCaIdSignCertificatePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCertificatesSignCertificatePost(apiV1PkiCertificatesSignCertificatePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCertificatesSignCertificatePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete PKI collection
         * @param {string} collectionId The ID of the PKI collection to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCollectionsCollectionIdDelete(collectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCollectionsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCollectionsCollectionIdDelete(collectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCollectionsCollectionIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get PKI collection
         * @param {string} collectionId The ID of the PKI collection to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCollectionsCollectionIdGet(collectionId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCollectionsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCollectionsCollectionIdGet(collectionId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCollectionsCollectionIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove item from PKI collection
         * @param {string} collectionId The ID of the PKI collection to delete the item from.
         * @param {string} collectionItemId The ID of the PKI collection item to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete(collectionId: string, collectionItemId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete(collectionId, collectionItemId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCollectionsCollectionIdItemsCollectionItemIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get items in PKI collection
         * @param {string} collectionId The ID of the PKI collection to list items from.
         * @param {ApiV1PkiCollectionsCollectionIdItemsGetTypeEnum} [type] The type of the PKI collection item to list.
         * @param {number} [offset] The offset to start from.
         * @param {number} [limit] The number of items to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCollectionsCollectionIdItemsGet(collectionId: string, type?: ApiV1PkiCollectionsCollectionIdItemsGetTypeEnum, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCollectionsCollectionIdItemsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCollectionsCollectionIdItemsGet(collectionId, type, offset, limit, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCollectionsCollectionIdItemsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add item to PKI collection
         * @param {string} collectionId The ID of the PKI collection to add the item to.
         * @param {ApiV1PkiCollectionsCollectionIdItemsPostRequest} apiV1PkiCollectionsCollectionIdItemsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCollectionsCollectionIdItemsPost(collectionId: string, apiV1PkiCollectionsCollectionIdItemsPostRequest: ApiV1PkiCollectionsCollectionIdItemsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCollectionsCollectionIdItemsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCollectionsCollectionIdItemsPost(collectionId, apiV1PkiCollectionsCollectionIdItemsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCollectionsCollectionIdItemsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update PKI collection
         * @param {string} collectionId The ID of the PKI collection to update.
         * @param {ApiV1PkiCollectionsCollectionIdPatchRequest} [apiV1PkiCollectionsCollectionIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCollectionsCollectionIdPatch(collectionId: string, apiV1PkiCollectionsCollectionIdPatchRequest?: ApiV1PkiCollectionsCollectionIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCollectionsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCollectionsCollectionIdPatch(collectionId, apiV1PkiCollectionsCollectionIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCollectionsCollectionIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create PKI collection
         * @param {ApiV1PkiCollectionsPostRequest} apiV1PkiCollectionsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCollectionsPost(apiV1PkiCollectionsPostRequest: ApiV1PkiCollectionsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PkiCollectionsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCollectionsPost(apiV1PkiCollectionsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCollectionsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CRL in DER format
         * @param {string} crlId The ID of the certificate revocation list (CRL) to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCrlCrlIdDerGet(crlId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCrlCrlIdDerGet(crlId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCrlCrlIdDerGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CRL in DER format (deprecated)
         * @param {string} crlId The ID of the certificate revocation list (CRL) to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PkiCrlCrlIdGet(crlId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1PkiCrlCrlIdGet(crlId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1PkiCrlCrlIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List project templates for the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProjectTemplatesGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ProjectTemplatesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ProjectTemplatesGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ProjectTemplatesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a project template.
         * @param {ApiV1ProjectTemplatesPostRequest} apiV1ProjectTemplatesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProjectTemplatesPost(apiV1ProjectTemplatesPostRequest: ApiV1ProjectTemplatesPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ProjectTemplatesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ProjectTemplatesPost(apiV1ProjectTemplatesPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ProjectTemplatesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a project template.
         * @param {string} templateId The ID of the project template to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProjectTemplatesTemplateIdDelete(templateId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ProjectTemplatesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ProjectTemplatesTemplateIdDelete(templateId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ProjectTemplatesTemplateIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a project template by ID.
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProjectTemplatesTemplateIdGet(templateId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ProjectTemplatesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ProjectTemplatesTemplateIdGet(templateId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ProjectTemplatesTemplateIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a project template.
         * @param {string} templateId The ID of the project template to be updated.
         * @param {ApiV1ProjectTemplatesTemplateIdPatchRequest} [apiV1ProjectTemplatesTemplateIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ProjectTemplatesTemplateIdPatch(templateId: string, apiV1ProjectTemplatesTemplateIdPatchRequest?: ApiV1ProjectTemplatesTemplateIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ProjectTemplatesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ProjectTemplatesTemplateIdPatch(templateId, apiV1ProjectTemplatesTemplateIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ProjectTemplatesTemplateIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RateLimitGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1RateLimitGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1RateLimitGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1RateLimitGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1RateLimitPutRequest} apiV1RateLimitPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RateLimitPut(apiV1RateLimitPutRequest: ApiV1RateLimitPutRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1RateLimitGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1RateLimitPut(apiV1RateLimitPutRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1RateLimitPut&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [startIndex] 
         * @param {number} [count] 
         * @param {string} [filter] 
         * @param {string} [excludedAttributes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimGroupsGet(startIndex?: number, count?: number, filter?: string, excludedAttributes?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ScimGroupsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimGroupsGet(startIndex, count, filter, excludedAttributes, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimGroupsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimGroupsGroupIdDelete(groupId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;object&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimGroupsGroupIdDelete(groupId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimGroupsGroupIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimGroupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ScimGroupsGet200ResponseResourcesInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimGroupsGroupIdGet(groupId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimGroupsGroupIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ApiV1ScimUsersOrgMembershipIdPatchRequest} apiV1ScimUsersOrgMembershipIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimGroupsGroupIdPatch(groupId: string, apiV1ScimUsersOrgMembershipIdPatchRequest: ApiV1ScimUsersOrgMembershipIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ScimGroupsGet200ResponseResourcesInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimGroupsGroupIdPatch(groupId, apiV1ScimUsersOrgMembershipIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimGroupsGroupIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupId 
         * @param {ApiV1ScimGroupsGroupIdPutRequest} apiV1ScimGroupsGroupIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimGroupsGroupIdPut(groupId: string, apiV1ScimGroupsGroupIdPutRequest: ApiV1ScimGroupsGroupIdPutRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ScimGroupsGet200ResponseResourcesInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimGroupsGroupIdPut(groupId, apiV1ScimGroupsGroupIdPutRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimGroupsGroupIdPut&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ScimGroupsPostRequest} apiV1ScimGroupsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimGroupsPost(apiV1ScimGroupsPostRequest: ApiV1ScimGroupsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ScimGroupsGet200ResponseResourcesInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimGroupsPost(apiV1ScimGroupsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimGroupsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimScimTokensGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ScimScimTokensGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimScimTokensGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimScimTokensGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ScimScimTokensPostRequest} apiV1ScimScimTokensPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimScimTokensPost(apiV1ScimScimTokensPostRequest: ApiV1ScimScimTokensPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ScimScimTokensPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimScimTokensPost(apiV1ScimScimTokensPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimScimTokensPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} scimTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimScimTokensScimTokenIdDelete(scimTokenId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ScimScimTokensScimTokenIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimScimTokensScimTokenIdDelete(scimTokenId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimScimTokensScimTokenIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [startIndex] 
         * @param {number} [count] 
         * @param {string} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimUsersGet(startIndex?: number, count?: number, filter?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ScimUsersGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimUsersGet(startIndex, count, filter, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimUsersGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgMembershipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimUsersOrgMembershipIdDelete(orgMembershipId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;object&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimUsersOrgMembershipIdDelete(orgMembershipId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimUsersOrgMembershipIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgMembershipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimUsersOrgMembershipIdGet(orgMembershipId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ScimUsersGet200ResponseResourcesInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimUsersOrgMembershipIdGet(orgMembershipId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimUsersOrgMembershipIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgMembershipId 
         * @param {ApiV1ScimUsersOrgMembershipIdPatchRequest} apiV1ScimUsersOrgMembershipIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimUsersOrgMembershipIdPatch(orgMembershipId: string, apiV1ScimUsersOrgMembershipIdPatchRequest: ApiV1ScimUsersOrgMembershipIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ScimUsersGet200ResponseResourcesInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimUsersOrgMembershipIdPatch(orgMembershipId, apiV1ScimUsersOrgMembershipIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimUsersOrgMembershipIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgMembershipId 
         * @param {ApiV1ScimUsersOrgMembershipIdPutRequest} apiV1ScimUsersOrgMembershipIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimUsersOrgMembershipIdPut(orgMembershipId: string, apiV1ScimUsersOrgMembershipIdPutRequest: ApiV1ScimUsersOrgMembershipIdPutRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ScimUsersOrgMembershipIdPut200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimUsersOrgMembershipIdPut(orgMembershipId, apiV1ScimUsersOrgMembershipIdPutRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimUsersOrgMembershipIdPut&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ScimUsersPostRequest} apiV1ScimUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ScimUsersPost(apiV1ScimUsersPostRequest: ApiV1ScimUsersPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1ScimUsersGet200ResponseResourcesInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1ScimUsersPost(apiV1ScimUsersPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1ScimUsersPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretApprovalRequestsCountGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalRequestsCountGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretApprovalRequestsCountGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretApprovalRequestsCountGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [environment] 
         * @param {string} [committer] 
         * @param {ApiV1SecretApprovalRequestsGetStatusEnum} [status] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretApprovalRequestsGet(workspaceId: string, environment?: string, committer?: string, status?: ApiV1SecretApprovalRequestsGetStatusEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalRequestsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretApprovalRequestsGet(workspaceId, environment, committer, status, limit, offset, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretApprovalRequestsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretApprovalRequestsIdGet(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalRequestsIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretApprovalRequestsIdGet(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretApprovalRequestsIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretApprovalRequestsIdMergePostRequest} [apiV1SecretApprovalRequestsIdMergePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretApprovalRequestsIdMergePost(id: string, apiV1SecretApprovalRequestsIdMergePostRequest?: ApiV1SecretApprovalRequestsIdMergePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalRequestsIdMergePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretApprovalRequestsIdMergePost(id, apiV1SecretApprovalRequestsIdMergePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretApprovalRequestsIdMergePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretApprovalRequestsIdReviewPostRequest} apiV1SecretApprovalRequestsIdReviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretApprovalRequestsIdReviewPost(id: string, apiV1SecretApprovalRequestsIdReviewPostRequest: ApiV1SecretApprovalRequestsIdReviewPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalRequestsIdReviewPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretApprovalRequestsIdReviewPost(id, apiV1SecretApprovalRequestsIdReviewPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretApprovalRequestsIdReviewPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretApprovalRequestsIdStatusPostRequest} apiV1SecretApprovalRequestsIdStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretApprovalRequestsIdStatusPost(id: string, apiV1SecretApprovalRequestsIdStatusPostRequest: ApiV1SecretApprovalRequestsIdStatusPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalRequestsIdMergePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretApprovalRequestsIdStatusPost(id, apiV1SecretApprovalRequestsIdStatusPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretApprovalRequestsIdStatusPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} secretPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretApprovalsBoardGet(workspaceId: string, environment: string, secretPath: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalsBoardGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretApprovalsBoardGet(workspaceId, environment, secretPath, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretApprovalsBoardGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretApprovalsGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretApprovalsGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretApprovalsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SecretApprovalsPostRequest} apiV1SecretApprovalsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretApprovalsPost(apiV1SecretApprovalsPostRequest: ApiV1SecretApprovalsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretApprovalsPost(apiV1SecretApprovalsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretApprovalsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sapId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretApprovalsSapIdDelete(sapId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretApprovalsSapIdDelete(sapId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretApprovalsSapIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sapId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretApprovalsSapIdGet(sapId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalsSapIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretApprovalsSapIdGet(sapId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretApprovalsSapIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sapId 
         * @param {ApiV1SecretApprovalsSapIdPatchRequest} apiV1SecretApprovalsSapIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretApprovalsSapIdPatch(sapId: string, apiV1SecretApprovalsSapIdPatchRequest: ApiV1SecretApprovalsSapIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretApprovalsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretApprovalsSapIdPatch(sapId, apiV1SecretApprovalsSapIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretApprovalsSapIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get secret imports
         * @param {string} workspaceId The ID of the project to list secret imports from.
         * @param {string} environment The slug of the environment to list secret imports from.
         * @param {string} [path] The path to list secret imports from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretImportsGet(workspaceId: string, environment: string, path?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretImportsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretImportsGet(workspaceId, environment, path, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretImportsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create secret imports
         * @param {ApiV1SecretImportsPostRequest} apiV1SecretImportsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretImportsPost(apiV1SecretImportsPostRequest: ApiV1SecretImportsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretImportsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretImportsPost(apiV1SecretImportsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretImportsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete secret imports
         * @param {string} secretImportId The ID of the secret import to delete.
         * @param {ApiV1SecretImportsSecretImportIdDeleteRequest} apiV1SecretImportsSecretImportIdDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretImportsSecretImportIdDelete(secretImportId: string, apiV1SecretImportsSecretImportIdDeleteRequest: ApiV1SecretImportsSecretImportIdDeleteRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretImportsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretImportsSecretImportIdDelete(secretImportId, apiV1SecretImportsSecretImportIdDeleteRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretImportsSecretImportIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get single secret import
         * @param {string} secretImportId The ID of the secret import to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretImportsSecretImportIdGet(secretImportId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretImportsSecretImportIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretImportsSecretImportIdGet(secretImportId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretImportsSecretImportIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update secret imports
         * @param {string} secretImportId The ID of the secret import to update.
         * @param {ApiV1SecretImportsSecretImportIdPatchRequest} apiV1SecretImportsSecretImportIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretImportsSecretImportIdPatch(secretImportId: string, apiV1SecretImportsSecretImportIdPatchRequest: ApiV1SecretImportsSecretImportIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretImportsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretImportsSecretImportIdPatch(secretImportId, apiV1SecretImportsSecretImportIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretImportsSecretImportIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resync secret replication of secret imports
         * @param {string} secretImportId The ID of the secret import to update.
         * @param {ApiV1SecretImportsSecretImportIdReplicationResyncPostRequest} apiV1SecretImportsSecretImportIdReplicationResyncPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretImportsSecretImportIdReplicationResyncPost(secretImportId: string, apiV1SecretImportsSecretImportIdReplicationResyncPostRequest: ApiV1SecretImportsSecretImportIdReplicationResyncPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretImportsSecretImportIdReplicationResyncPost(secretImportId, apiV1SecretImportsSecretImportIdReplicationResyncPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretImportsSecretImportIdReplicationResyncPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretImportsSecretsGet(workspaceId: string, environment: string, path?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretImportsSecretsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretImportsSecretsGet(workspaceId, environment, path, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretImportsSecretsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretImportsSecretsRawGet(workspaceId: string, environment: string, path?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretImportsSecretsRawGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretImportsSecretsRawGet(workspaceId, environment, path, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretImportsSecretsRawGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretRotationProvidersWorkspaceIdGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretRotationProvidersWorkspaceIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretRotationProvidersWorkspaceIdGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretRotationProvidersWorkspaceIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretRotationsGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretRotationsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretRotationsGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretRotationsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretRotationsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretRotationsRestartPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretRotationsIdDelete(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretRotationsIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SecretRotationsPostRequest} apiV1SecretRotationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretRotationsPost(apiV1SecretRotationsPostRequest: ApiV1SecretRotationsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretRotationsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretRotationsPost(apiV1SecretRotationsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretRotationsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SecretRotationsRestartPostRequest} apiV1SecretRotationsRestartPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretRotationsRestartPost(apiV1SecretRotationsRestartPostRequest: ApiV1SecretRotationsRestartPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretRotationsRestartPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretRotationsRestartPost(apiV1SecretRotationsRestartPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretRotationsRestartPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest} apiV1SecretScanningCreateInstallationSessionOrganizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretScanningCreateInstallationSessionOrganizationPost(apiV1SecretScanningCreateInstallationSessionOrganizationPostRequest: ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretScanningCreateInstallationSessionOrganizationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretScanningCreateInstallationSessionOrganizationPost(apiV1SecretScanningCreateInstallationSessionOrganizationPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretScanningCreateInstallationSessionOrganizationPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SecretScanningLinkInstallationPostRequest} apiV1SecretScanningLinkInstallationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretScanningLinkInstallationPost(apiV1SecretScanningLinkInstallationPostRequest: ApiV1SecretScanningLinkInstallationPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretScanningLinkInstallationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretScanningLinkInstallationPost(apiV1SecretScanningLinkInstallationPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretScanningLinkInstallationPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string | null} [repositoryNames] 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksExportGetResolvedStatusEnum} [resolvedStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretScanningOrganizationOrganizationIdRisksExportGet(organizationId: string, repositoryNames?: string | null, resolvedStatus?: ApiV1SecretScanningOrganizationOrganizationIdRisksExportGetResolvedStatusEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretScanningOrganizationOrganizationIdRisksExportGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretScanningOrganizationOrganizationIdRisksExportGet(organizationId, repositoryNames, resolvedStatus, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretScanningOrganizationOrganizationIdRisksExportGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderByEnum} [orderBy] 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderDirectionEnum} [orderDirection] 
         * @param {string | null} [repositoryNames] 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksGetResolvedStatusEnum} [resolvedStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretScanningOrganizationOrganizationIdRisksGet(organizationId: string, offset?: number, limit?: number, orderBy?: ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderByEnum, orderDirection?: ApiV1SecretScanningOrganizationOrganizationIdRisksGetOrderDirectionEnum, repositoryNames?: string | null, resolvedStatus?: ApiV1SecretScanningOrganizationOrganizationIdRisksGetResolvedStatusEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretScanningOrganizationOrganizationIdRisksGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretScanningOrganizationOrganizationIdRisksGet(organizationId, offset, limit, orderBy, orderDirection, repositoryNames, resolvedStatus, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretScanningOrganizationOrganizationIdRisksGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} riskId 
         * @param {ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest} apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPost(organizationId: string, riskId: string, apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest: ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretScanningOrganizationOrganizationIdRisksExportGet200ResponseRisksInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPost(organizationId, riskId, apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} offset 
         * @param {number} limit 
         * @param {string} secretId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSecretIdSecretVersionsGet(offset: number, limit: number, secretId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSecretIdSecretVersionsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSecretIdSecretVersionsGet(offset, limit, secretId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSecretIdSecretVersionsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSharingRequestsGet(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSharingSharedGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSharingRequestsGet(offset, limit, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSharingRequestsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSharingRequestsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSharingRequestsIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSharingRequestsIdDelete(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSharingRequestsIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSharingRequestsIdGet(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSharingRequestsIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSharingRequestsIdGet(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSharingRequestsIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSharingRequestsIdRevealValuePost(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSharingRequestsIdRevealValuePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSharingRequestsIdRevealValuePost(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSharingRequestsIdRevealValuePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretSharingRequestsIdSetValuePostRequest} apiV1SecretSharingRequestsIdSetValuePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSharingRequestsIdSetValuePost(id: string, apiV1SecretSharingRequestsIdSetValuePostRequest: ApiV1SecretSharingRequestsIdSetValuePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSharingRequestsIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSharingRequestsIdSetValuePost(id, apiV1SecretSharingRequestsIdSetValuePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSharingRequestsIdSetValuePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SecretSharingRequestsPostRequest} apiV1SecretSharingRequestsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSharingRequestsPost(apiV1SecretSharingRequestsPostRequest: ApiV1SecretSharingRequestsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretRotationsRestartPostRequest&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSharingRequestsPost(apiV1SecretSharingRequestsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSharingRequestsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSharingSharedGet(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSharingSharedGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSharingSharedGet(offset, limit, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSharingSharedGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SecretSharingSharedPostRequest} apiV1SecretSharingSharedPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSharingSharedPost(apiV1SecretSharingSharedPostRequest: ApiV1SecretSharingSharedPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretRotationsRestartPostRequest&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSharingSharedPost(apiV1SecretSharingSharedPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSharingSharedPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1SecretSharingSharedPublicIdPostRequest} [apiV1SecretSharingSharedPublicIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSharingSharedPublicIdPost(id: string, apiV1SecretSharingSharedPublicIdPostRequest?: ApiV1SecretSharingSharedPublicIdPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSharingSharedPublicIdPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSharingSharedPublicIdPost(id, apiV1SecretSharingSharedPublicIdPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSharingSharedPublicIdPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SecretSharingSharedPublicPostRequest} apiV1SecretSharingSharedPublicPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSharingSharedPublicPost(apiV1SecretSharingSharedPublicPostRequest: ApiV1SecretSharingSharedPublicPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretRotationsRestartPostRequest&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSharingSharedPublicPost(apiV1SecretSharingSharedPublicPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSharingSharedPublicPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} sharedSecretId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSharingSharedSharedSecretIdDelete(sharedSecretId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSharingSharedGet200ResponseSecretsInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSharingSharedSharedSecretIdDelete(sharedSecretId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSharingSharedSharedSecretIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} secretSnapshotId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSnapshotSecretSnapshotIdGet(secretSnapshotId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSnapshotSecretSnapshotIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSnapshotSecretSnapshotIdGet(secretSnapshotId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSnapshotSecretSnapshotIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Roll back project secrets to those captured in a secret snapshot version.
         * @param {string} secretSnapshotId The ID of the snapshot to rollback to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSnapshotSecretSnapshotIdRollbackPost(secretSnapshotId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSnapshotSecretSnapshotIdRollbackPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSnapshotSecretSnapshotIdRollbackPost(secretSnapshotId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSnapshotSecretSnapshotIdRollbackPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the AWS Parameter Store Syncs for the specified project.
         * @param {string} projectId The ID of the project to list AWS Parameter Store Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsParameterStoreGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStoreGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsParameterStoreGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsParameterStoreGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an AWS Parameter Store Sync for the specified project environment.
         * @param {ApiV1SecretSyncsAwsParameterStorePostRequest} apiV1SecretSyncsAwsParameterStorePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsParameterStorePost(apiV1SecretSyncsAwsParameterStorePostRequest: ApiV1SecretSyncsAwsParameterStorePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsParameterStorePost(apiV1SecretSyncsAwsParameterStorePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsParameterStorePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified AWS Parameter Store Sync.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to be deleted.
         * @param {ApiV1SecretSyncsAwsParameterStoreSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsParameterStoreSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsAwsParameterStoreSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsParameterStoreSyncIdDelete(syncId, removeSecrets, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsParameterStoreSyncIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified AWS Parameter Store Sync by ID.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsParameterStoreSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsParameterStoreSyncIdGet(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsParameterStoreSyncIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import secrets from the specified AWS Parameter Store Sync destination.
         * @param {ApiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or AWS Parameter Store.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPost(importBehavior, syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsParameterStoreSyncIdImportSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified AWS Parameter Store Sync.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to be updated.
         * @param {ApiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest} [apiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsParameterStoreSyncIdPatch(syncId: string, apiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest?: ApiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsParameterStoreSyncIdPatch(syncId, apiV1SecretSyncsAwsParameterStoreSyncIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsParameterStoreSyncIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove previously synced secrets from the specified AWS Parameter Store Sync destination.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsParameterStoreSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsParameterStoreSyncIdRemoveSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsParameterStoreSyncIdRemoveSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a sync for the specified AWS Parameter Store Sync.
         * @param {string} syncId The ID of the AWS Parameter Store Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsParameterStoreSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsParameterStoreSyncIdSyncSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsParameterStoreSyncIdSyncSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified AWS Parameter Store Sync by name and project ID.
         * @param {string} projectId The ID of the project the AWS Parameter Store Sync is associated with.
         * @param {string} syncName The name of the AWS Parameter Store Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsParameterStoreSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsParameterStorePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsParameterStoreSyncNameSyncNameGet(projectId, syncName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsParameterStoreSyncNameSyncNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the AWS Secrets Manager Syncs for the specified project.
         * @param {string} projectId The ID of the project to list AWS Secrets Manager Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsSecretsManagerGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsSecretsManagerGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsSecretsManagerGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an AWS Secrets Manager Sync for the specified project environment.
         * @param {ApiV1SecretSyncsAwsSecretsManagerPostRequest} apiV1SecretSyncsAwsSecretsManagerPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsSecretsManagerPost(apiV1SecretSyncsAwsSecretsManagerPostRequest: ApiV1SecretSyncsAwsSecretsManagerPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsSecretsManagerPost(apiV1SecretSyncsAwsSecretsManagerPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsSecretsManagerPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified AWS Secrets Manager Sync.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to be deleted.
         * @param {ApiV1SecretSyncsAwsSecretsManagerSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsSecretsManagerSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsAwsSecretsManagerSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsSecretsManagerSyncIdDelete(syncId, removeSecrets, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsSecretsManagerSyncIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified AWS Secrets Manager Sync by ID.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsSecretsManagerSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsSecretsManagerSyncIdGet(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsSecretsManagerSyncIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import secrets from the specified AWS Secrets Manager Sync destination.
         * @param {ApiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or AWS Secrets Manager.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPost(importBehavior, syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsSecretsManagerSyncIdImportSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified AWS Secrets Manager Sync.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to be updated.
         * @param {ApiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest} [apiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsSecretsManagerSyncIdPatch(syncId: string, apiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest?: ApiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsSecretsManagerSyncIdPatch(syncId, apiV1SecretSyncsAwsSecretsManagerSyncIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsSecretsManagerSyncIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove previously synced secrets from the specified AWS Secrets Manager Sync destination.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsSecretsManagerSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsSecretsManagerSyncIdRemoveSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsSecretsManagerSyncIdRemoveSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a sync for the specified AWS Secrets Manager Sync.
         * @param {string} syncId The ID of the AWS Secrets Manager Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsSecretsManagerSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsSecretsManagerSyncIdSyncSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsSecretsManagerSyncIdSyncSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified AWS Secrets Manager Sync by name and project ID.
         * @param {string} projectId The ID of the project the AWS Secrets Manager Sync is associated with.
         * @param {string} syncName The name of the AWS Secrets Manager Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAwsSecretsManagerSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAwsSecretsManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAwsSecretsManagerSyncNameSyncNameGet(projectId, syncName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAwsSecretsManagerSyncNameSyncNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Azure App Configuration Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Azure App Configuration Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureAppConfigurationGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureAppConfigurationGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureAppConfigurationGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an Azure App Configuration Sync for the specified project environment.
         * @param {ApiV1SecretSyncsAzureAppConfigurationPostRequest} apiV1SecretSyncsAzureAppConfigurationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureAppConfigurationPost(apiV1SecretSyncsAzureAppConfigurationPostRequest: ApiV1SecretSyncsAzureAppConfigurationPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureAppConfigurationPost(apiV1SecretSyncsAzureAppConfigurationPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureAppConfigurationPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified Azure App Configuration Sync.
         * @param {string} syncId The ID of the Azure App Configuration Sync to be deleted.
         * @param {ApiV1SecretSyncsAzureAppConfigurationSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureAppConfigurationSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsAzureAppConfigurationSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureAppConfigurationSyncIdDelete(syncId, removeSecrets, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureAppConfigurationSyncIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Azure App Configuration Sync by ID.
         * @param {string} syncId The ID of the Azure App Configuration Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureAppConfigurationSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureAppConfigurationSyncIdGet(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureAppConfigurationSyncIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import secrets from the specified Azure App Configuration Sync destination.
         * @param {ApiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or Azure App Configuration.
         * @param {string} syncId The ID of the Azure App Configuration Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPost(importBehavior, syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureAppConfigurationSyncIdImportSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified Azure App Configuration Sync.
         * @param {string} syncId The ID of the Azure App Configuration Sync to be updated.
         * @param {ApiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest} [apiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureAppConfigurationSyncIdPatch(syncId: string, apiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest?: ApiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureAppConfigurationSyncIdPatch(syncId, apiV1SecretSyncsAzureAppConfigurationSyncIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureAppConfigurationSyncIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove previously synced secrets from the specified Azure App Configuration Sync destination.
         * @param {string} syncId The ID of the Azure App Configuration Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureAppConfigurationSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureAppConfigurationSyncIdRemoveSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureAppConfigurationSyncIdRemoveSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a sync for the specified Azure App Configuration Sync.
         * @param {string} syncId The ID of the Azure App Configuration Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureAppConfigurationSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureAppConfigurationSyncIdSyncSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureAppConfigurationSyncIdSyncSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Azure App Configuration Sync by name and project ID.
         * @param {string} projectId The ID of the project the Azure App Configuration Sync is associated with.
         * @param {string} syncName The name of the Azure App Configuration Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureAppConfigurationSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureAppConfigurationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureAppConfigurationSyncNameSyncNameGet(projectId, syncName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureAppConfigurationSyncNameSyncNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Azure Key Vault Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Azure Key Vault Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureKeyVaultGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureKeyVaultGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureKeyVaultGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an Azure Key Vault Sync for the specified project environment.
         * @param {ApiV1SecretSyncsAzureKeyVaultPostRequest} apiV1SecretSyncsAzureKeyVaultPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureKeyVaultPost(apiV1SecretSyncsAzureKeyVaultPostRequest: ApiV1SecretSyncsAzureKeyVaultPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureKeyVaultPost(apiV1SecretSyncsAzureKeyVaultPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureKeyVaultPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified Azure Key Vault Sync.
         * @param {string} syncId The ID of the Azure Key Vault Sync to be deleted.
         * @param {ApiV1SecretSyncsAzureKeyVaultSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureKeyVaultSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsAzureKeyVaultSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureKeyVaultSyncIdDelete(syncId, removeSecrets, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureKeyVaultSyncIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Azure Key Vault Sync by ID.
         * @param {string} syncId The ID of the Azure Key Vault Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureKeyVaultSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureKeyVaultSyncIdGet(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureKeyVaultSyncIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import secrets from the specified Azure Key Vault Sync destination.
         * @param {ApiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or Azure Key Vault.
         * @param {string} syncId The ID of the Azure Key Vault Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPost(importBehavior, syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureKeyVaultSyncIdImportSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified Azure Key Vault Sync.
         * @param {string} syncId The ID of the Azure Key Vault Sync to be updated.
         * @param {ApiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest} [apiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureKeyVaultSyncIdPatch(syncId: string, apiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest?: ApiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureKeyVaultSyncIdPatch(syncId, apiV1SecretSyncsAzureKeyVaultSyncIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureKeyVaultSyncIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove previously synced secrets from the specified Azure Key Vault Sync destination.
         * @param {string} syncId The ID of the Azure Key Vault Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureKeyVaultSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureKeyVaultSyncIdRemoveSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureKeyVaultSyncIdRemoveSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a sync for the specified Azure Key Vault Sync.
         * @param {string} syncId The ID of the Azure Key Vault Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureKeyVaultSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureKeyVaultSyncIdSyncSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureKeyVaultSyncIdSyncSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Azure Key Vault Sync by name and project ID.
         * @param {string} projectId The ID of the project the Azure Key Vault Sync is associated with.
         * @param {string} syncName The name of the Azure Key Vault Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsAzureKeyVaultSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsAzureKeyVaultPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsAzureKeyVaultSyncNameSyncNameGet(projectId, syncName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsAzureKeyVaultSyncNameSyncNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Databricks Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Databricks Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsDatabricksGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsDatabricksGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsDatabricksGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsDatabricksGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Databricks Sync for the specified project environment.
         * @param {ApiV1SecretSyncsDatabricksPostRequest} apiV1SecretSyncsDatabricksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsDatabricksPost(apiV1SecretSyncsDatabricksPostRequest: ApiV1SecretSyncsDatabricksPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsDatabricksPost(apiV1SecretSyncsDatabricksPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsDatabricksPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified Databricks Sync.
         * @param {string} syncId The ID of the Databricks Sync to be deleted.
         * @param {ApiV1SecretSyncsDatabricksSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsDatabricksSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsDatabricksSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsDatabricksSyncIdDelete(syncId, removeSecrets, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsDatabricksSyncIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Databricks Sync by ID.
         * @param {string} syncId The ID of the Databricks Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsDatabricksSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsDatabricksSyncIdGet(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsDatabricksSyncIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import secrets from the specified Databricks Sync destination.
         * @param {ApiV1SecretSyncsDatabricksSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or Databricks.
         * @param {string} syncId The ID of the Databricks Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsDatabricksSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsDatabricksSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsDatabricksSyncIdImportSecretsPost(importBehavior, syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsDatabricksSyncIdImportSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified Databricks Sync.
         * @param {string} syncId The ID of the Databricks Sync to be updated.
         * @param {ApiV1SecretSyncsDatabricksSyncIdPatchRequest} [apiV1SecretSyncsDatabricksSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsDatabricksSyncIdPatch(syncId: string, apiV1SecretSyncsDatabricksSyncIdPatchRequest?: ApiV1SecretSyncsDatabricksSyncIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsDatabricksSyncIdPatch(syncId, apiV1SecretSyncsDatabricksSyncIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsDatabricksSyncIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove previously synced secrets from the specified Databricks Sync destination.
         * @param {string} syncId The ID of the Databricks Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsDatabricksSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsDatabricksSyncIdRemoveSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsDatabricksSyncIdRemoveSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a sync for the specified Databricks Sync.
         * @param {string} syncId The ID of the Databricks Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsDatabricksSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsDatabricksSyncIdSyncSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsDatabricksSyncIdSyncSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Databricks Sync by name and project ID.
         * @param {string} projectId The ID of the project the Databricks Sync is associated with.
         * @param {string} syncName The name of the Databricks Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsDatabricksSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsDatabricksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsDatabricksSyncNameSyncNameGet(projectId, syncName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsDatabricksSyncNameSyncNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the GCP Secret Manager Syncs for the specified project.
         * @param {string} projectId The ID of the project to list GCP Secret Manager Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGcpSecretManagerGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGcpSecretManagerGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGcpSecretManagerGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a GCP Secret Manager Sync for the specified project environment.
         * @param {ApiV1SecretSyncsGcpSecretManagerPostRequest} apiV1SecretSyncsGcpSecretManagerPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGcpSecretManagerPost(apiV1SecretSyncsGcpSecretManagerPostRequest: ApiV1SecretSyncsGcpSecretManagerPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGcpSecretManagerPost(apiV1SecretSyncsGcpSecretManagerPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGcpSecretManagerPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified GCP Secret Manager Sync.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to be deleted.
         * @param {ApiV1SecretSyncsGcpSecretManagerSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGcpSecretManagerSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsGcpSecretManagerSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGcpSecretManagerSyncIdDelete(syncId, removeSecrets, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGcpSecretManagerSyncIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified GCP Secret Manager Sync by ID.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGcpSecretManagerSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGcpSecretManagerSyncIdGet(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGcpSecretManagerSyncIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import secrets from the specified GCP Secret Manager Sync destination.
         * @param {ApiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or GCP Secret Manager.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPost(importBehavior, syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGcpSecretManagerSyncIdImportSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified GCP Secret Manager Sync.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to be updated.
         * @param {ApiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest} [apiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGcpSecretManagerSyncIdPatch(syncId: string, apiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest?: ApiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGcpSecretManagerSyncIdPatch(syncId, apiV1SecretSyncsGcpSecretManagerSyncIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGcpSecretManagerSyncIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove previously synced secrets from the specified GCP Secret Manager Sync destination.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGcpSecretManagerSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGcpSecretManagerSyncIdRemoveSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGcpSecretManagerSyncIdRemoveSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a sync for the specified GCP Secret Manager Sync.
         * @param {string} syncId The ID of the GCP Secret Manager Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGcpSecretManagerSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGcpSecretManagerSyncIdSyncSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGcpSecretManagerSyncIdSyncSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified GCP Secret Manager Sync by name and project ID.
         * @param {string} projectId The ID of the project the GCP Secret Manager Sync is associated with.
         * @param {string} syncName The name of the GCP Secret Manager Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGcpSecretManagerSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGcpSecretManagerPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGcpSecretManagerSyncNameSyncNameGet(projectId, syncName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGcpSecretManagerSyncNameSyncNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all the Secret Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Secret Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the GitHub Syncs for the specified project.
         * @param {string} projectId The ID of the project to list GitHub Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGithubGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGithubGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGithubGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGithubGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a GitHub Sync for the specified project environment.
         * @param {ApiV1SecretSyncsGithubPostRequest} apiV1SecretSyncsGithubPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGithubPost(apiV1SecretSyncsGithubPostRequest: ApiV1SecretSyncsGithubPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGithubPost(apiV1SecretSyncsGithubPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGithubPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified GitHub Sync.
         * @param {string} syncId The ID of the GitHub Sync to be deleted.
         * @param {ApiV1SecretSyncsGithubSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGithubSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsGithubSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGithubSyncIdDelete(syncId, removeSecrets, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGithubSyncIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified GitHub Sync by ID.
         * @param {string} syncId The ID of the GitHub Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGithubSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGithubSyncIdGet(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGithubSyncIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import secrets from the specified GitHub Sync destination.
         * @param {ApiV1SecretSyncsGithubSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or GitHub.
         * @param {string} syncId The ID of the GitHub Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGithubSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsGithubSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGithubSyncIdImportSecretsPost(importBehavior, syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGithubSyncIdImportSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified GitHub Sync.
         * @param {string} syncId The ID of the GitHub Sync to be updated.
         * @param {ApiV1SecretSyncsGithubSyncIdPatchRequest} [apiV1SecretSyncsGithubSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGithubSyncIdPatch(syncId: string, apiV1SecretSyncsGithubSyncIdPatchRequest?: ApiV1SecretSyncsGithubSyncIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGithubSyncIdPatch(syncId, apiV1SecretSyncsGithubSyncIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGithubSyncIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove previously synced secrets from the specified GitHub Sync destination.
         * @param {string} syncId The ID of the GitHub Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGithubSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGithubSyncIdRemoveSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGithubSyncIdRemoveSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a sync for the specified GitHub Sync.
         * @param {string} syncId The ID of the GitHub Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGithubSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGithubSyncIdSyncSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGithubSyncIdSyncSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified GitHub Sync by name and project ID.
         * @param {string} projectId The ID of the project the GitHub Sync is associated with.
         * @param {string} syncName The name of the GitHub Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsGithubSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsGithubPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsGithubSyncNameSyncNameGet(projectId, syncName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsGithubSyncNameSyncNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Humanitec Syncs for the specified project.
         * @param {string} projectId The ID of the project to list Humanitec Syncs from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsHumanitecGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsHumanitecGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsHumanitecGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsHumanitecGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Humanitec Sync for the specified project environment.
         * @param {ApiV1SecretSyncsHumanitecPostRequest} apiV1SecretSyncsHumanitecPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsHumanitecPost(apiV1SecretSyncsHumanitecPostRequest: ApiV1SecretSyncsHumanitecPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsHumanitecPost(apiV1SecretSyncsHumanitecPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsHumanitecPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified Humanitec Sync.
         * @param {string} syncId The ID of the Humanitec Sync to be deleted.
         * @param {ApiV1SecretSyncsHumanitecSyncIdDeleteRemoveSecretsEnum} [removeSecrets] Whether previously synced secrets should be removed prior to deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsHumanitecSyncIdDelete(syncId: string, removeSecrets?: ApiV1SecretSyncsHumanitecSyncIdDeleteRemoveSecretsEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsHumanitecSyncIdDelete(syncId, removeSecrets, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsHumanitecSyncIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Humanitec Sync by ID.
         * @param {string} syncId The ID of the Humanitec Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsHumanitecSyncIdGet(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsHumanitecSyncIdGet(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsHumanitecSyncIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import secrets from the specified Humanitec Sync destination.
         * @param {ApiV1SecretSyncsHumanitecSyncIdImportSecretsPostImportBehaviorEnum} importBehavior Specify whether Infisical should prioritize secret values from Infisical or Humanitec.
         * @param {string} syncId The ID of the Humanitec Sync to trigger importing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsHumanitecSyncIdImportSecretsPost(importBehavior: ApiV1SecretSyncsHumanitecSyncIdImportSecretsPostImportBehaviorEnum, syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsHumanitecSyncIdImportSecretsPost(importBehavior, syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsHumanitecSyncIdImportSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the specified Humanitec Sync.
         * @param {string} syncId The ID of the Humanitec Sync to be updated.
         * @param {ApiV1SecretSyncsHumanitecSyncIdPatchRequest} [apiV1SecretSyncsHumanitecSyncIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsHumanitecSyncIdPatch(syncId: string, apiV1SecretSyncsHumanitecSyncIdPatchRequest?: ApiV1SecretSyncsHumanitecSyncIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsHumanitecSyncIdPatch(syncId, apiV1SecretSyncsHumanitecSyncIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsHumanitecSyncIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove previously synced secrets from the specified Humanitec Sync destination.
         * @param {string} syncId The ID of the Humanitec Sync to trigger removing secrets for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsHumanitecSyncIdRemoveSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsHumanitecSyncIdRemoveSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsHumanitecSyncIdRemoveSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a sync for the specified Humanitec Sync.
         * @param {string} syncId The ID of the Humanitec Sync to trigger a sync for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsHumanitecSyncIdSyncSecretsPost(syncId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsHumanitecSyncIdSyncSecretsPost(syncId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsHumanitecSyncIdSyncSecretsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the specified Humanitec Sync by name and project ID.
         * @param {string} projectId The ID of the project the Humanitec Sync is associated with.
         * @param {string} syncName The name of the Humanitec Sync to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsHumanitecSyncNameSyncNameGet(projectId: string, syncName: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsHumanitecPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsHumanitecSyncNameSyncNameGet(projectId, syncName, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsHumanitecSyncNameSyncNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the available Secret Sync Options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretSyncsOptionsGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretSyncsOptionsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretSyncsOptionsGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretSyncsOptionsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of users, machine identities, and groups with access to a secret
         * @param {string} workspaceId The ID of the project where the secret is located.
         * @param {string} environment The slug of the environment where the the secret is located.
         * @param {string} secretName The name of the secret to get the access list for.
         * @param {string} [secretPath] The folder path where the secret is located.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SecretsSecretNameAccessListGet(workspaceId: string, environment: string, secretName: string, secretPath?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SecretsSecretNameAccessListGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SecretsSecretNameAccessListGet(workspaceId, environment, secretName, secretPath, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SecretsSecretNameAccessListGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create SSH CA
         * @param {ApiV1SshCaPostRequest} apiV1SshCaPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SshCaPost(apiV1SshCaPostRequest: ApiV1SshCaPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SshCaPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SshCaPost(apiV1SshCaPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SshCaPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of certificate templates for the SSH CA
         * @param {string} sshCaId The ID of the SSH CA to get the certificate templates for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SshCaSshCaIdCertificateTemplatesGet(sshCaId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SshCaSshCaIdCertificateTemplatesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SshCaSshCaIdCertificateTemplatesGet(sshCaId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SshCaSshCaIdCertificateTemplatesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete SSH CA
         * @param {string} sshCaId The ID of the SSH CA to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SshCaSshCaIdDelete(sshCaId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SshCaSshCaIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SshCaSshCaIdDelete(sshCaId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SshCaSshCaIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SSH CA
         * @param {string} sshCaId The ID of the SSH CA to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SshCaSshCaIdGet(sshCaId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SshCaPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SshCaSshCaIdGet(sshCaId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SshCaSshCaIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update SSH CA
         * @param {string} sshCaId The ID of the SSH CA to update.
         * @param {ApiV1SshCaSshCaIdPatchRequest} [apiV1SshCaSshCaIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SshCaSshCaIdPatch(sshCaId: string, apiV1SshCaSshCaIdPatchRequest?: ApiV1SshCaSshCaIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SshCaPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SshCaSshCaIdPatch(sshCaId, apiV1SshCaSshCaIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SshCaSshCaIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get public key of SSH CA
         * @param {string} sshCaId The ID of the SSH CA to get the public key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SshCaSshCaIdPublicKeyGet(sshCaId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;string&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SshCaSshCaIdPublicKeyGet(sshCaId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SshCaSshCaIdPublicKeyGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the SSH certificate template to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SshCertificateTemplatesCertificateTemplateIdDelete(certificateTemplateId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SshCaSshCaIdCertificateTemplatesGet200ResponseCertificateTemplatesInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SshCertificateTemplatesCertificateTemplateIdDelete(certificateTemplateId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SshCertificateTemplatesCertificateTemplateIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the SSH certificate template to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SshCertificateTemplatesCertificateTemplateIdGet(certificateTemplateId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SshCaSshCaIdCertificateTemplatesGet200ResponseCertificateTemplatesInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SshCertificateTemplatesCertificateTemplateIdGet(certificateTemplateId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SshCertificateTemplatesCertificateTemplateIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} certificateTemplateId The ID of the SSH certificate template to update.
         * @param {ApiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest} [apiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SshCertificateTemplatesCertificateTemplateIdPatch(certificateTemplateId: string, apiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest?: ApiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SshCaSshCaIdCertificateTemplatesGet200ResponseCertificateTemplatesInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SshCertificateTemplatesCertificateTemplateIdPatch(certificateTemplateId, apiV1SshCertificateTemplatesCertificateTemplateIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SshCertificateTemplatesCertificateTemplateIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SshCertificateTemplatesPostRequest} apiV1SshCertificateTemplatesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SshCertificateTemplatesPost(apiV1SshCertificateTemplatesPostRequest: ApiV1SshCertificateTemplatesPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SshCaSshCaIdCertificateTemplatesGet200ResponseCertificateTemplatesInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SshCertificateTemplatesPost(apiV1SshCertificateTemplatesPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SshCertificateTemplatesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Issue SSH credentials (certificate + key)
         * @param {ApiV1SshCertificatesIssuePostRequest} apiV1SshCertificatesIssuePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SshCertificatesIssuePost(apiV1SshCertificatesIssuePostRequest: ApiV1SshCertificatesIssuePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SshCertificatesIssuePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SshCertificatesIssuePost(apiV1SshCertificatesIssuePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SshCertificatesIssuePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sign SSH public key
         * @param {ApiV1SshCertificatesSignPostRequest} apiV1SshCertificatesSignPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SshCertificatesSignPost(apiV1SshCertificatesSignPostRequest: ApiV1SshCertificatesSignPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SshCertificatesSignPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SshCertificatesSignPost(apiV1SshCertificatesSignPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SshCertificatesSignPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoConfigGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SsoConfigGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoConfigGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoConfigGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SsoConfigPatchRequest} apiV1SsoConfigPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoConfigPatch(apiV1SsoConfigPatchRequest: ApiV1SsoConfigPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SsoConfigPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoConfigPatch(apiV1SsoConfigPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoConfigPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SsoConfigPostRequest} apiV1SsoConfigPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoConfigPost(apiV1SsoConfigPostRequest: ApiV1SsoConfigPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SsoConfigPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoConfigPost(apiV1SsoConfigPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoConfigPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoGithubGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoGithubGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoGithubGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoGitlabGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoGitlabGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoGitlabGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoGoogleGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoGoogleGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoGoogleGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoOidcCallbackGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoOidcCallbackGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoOidcCallbackGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgSlug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoOidcConfigGet(orgSlug: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SsoOidcConfigGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoOidcConfigGet(orgSlug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoOidcConfigGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SsoOidcConfigPatchRequest} apiV1SsoOidcConfigPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoOidcConfigPatch(apiV1SsoOidcConfigPatchRequest: ApiV1SsoOidcConfigPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SsoOidcConfigPatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoOidcConfigPatch(apiV1SsoOidcConfigPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoOidcConfigPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SsoOidcConfigPostRequest} apiV1SsoOidcConfigPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoOidcConfigPost(apiV1SsoOidcConfigPostRequest: ApiV1SsoOidcConfigPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SsoOidcConfigPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoOidcConfigPost(apiV1SsoOidcConfigPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoOidcConfigPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoOidcLoginErrorGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoOidcLoginErrorGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoOidcLoginErrorGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgSlug 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoOidcLoginGet(orgSlug: string, callbackPort?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoOidcLoginGet(orgSlug, callbackPort, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoOidcLoginGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoOidcManageGroupMembershipsGet(orgId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SsoOidcManageGroupMembershipsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoOidcManageGroupMembershipsGet(orgId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoOidcManageGroupMembershipsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoRedirectGithubGet(callbackPort?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoRedirectGithubGet(callbackPort, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoRedirectGithubGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoRedirectGitlabGet(callbackPort?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoRedirectGitlabGet(callbackPort, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoRedirectGitlabGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoRedirectGoogleGet(callbackPort?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoRedirectGoogleGet(callbackPort, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoRedirectGoogleGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgSlug 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoRedirectOrganizationsOrgSlugGet(orgSlug: string, callbackPort?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoRedirectOrganizationsOrgSlugGet(orgSlug, callbackPort, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoRedirectOrganizationsOrgSlugGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgSlug 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoRedirectSaml2OrganizationsOrgSlugGet(orgSlug: string, callbackPort?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoRedirectSaml2OrganizationsOrgSlugGet(orgSlug, callbackPort, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoRedirectSaml2OrganizationsOrgSlugGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} samlConfigId 
         * @param {string} [callbackPort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoRedirectSaml2SamlConfigIdGet(samlConfigId: string, callbackPort?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoRedirectSaml2SamlConfigIdGet(samlConfigId, callbackPort, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoRedirectSaml2SamlConfigIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} samlConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoSaml2SamlConfigIdPost(samlConfigId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoSaml2SamlConfigIdPost(samlConfigId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoSaml2SamlConfigIdPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1SsoTokenExchangePostRequest} apiV1SsoTokenExchangePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1SsoTokenExchangePost(apiV1SsoTokenExchangePostRequest: ApiV1SsoTokenExchangePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1SsoTokenExchangePost(apiV1SsoTokenExchangePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1SsoTokenExchangePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} action 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserActionGet(action: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1UserActionGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserActionGet(action, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserActionGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserActionPostRequest} apiV1UserActionPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserActionPost(apiV1UserActionPostRequest: ApiV1UserActionPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1UserActionPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserActionPost(apiV1UserActionPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserActionPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserEngagementMeWishPostRequest} apiV1UserEngagementMeWishPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserEngagementMeWishPost(apiV1UserEngagementMeWishPostRequest: ApiV1UserEngagementMeWishPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;object&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserEngagementMeWishPost(apiV1UserEngagementMeWishPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserEngagementMeWishPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1UserGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserMeProjectFavoritesGet(orgId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1UserMeProjectFavoritesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserMeProjectFavoritesGet(orgId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserMeProjectFavoritesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserMeProjectFavoritesPutRequest} apiV1UserMeProjectFavoritesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserMeProjectFavoritesPut(apiV1UserMeProjectFavoritesPutRequest: ApiV1UserMeProjectFavoritesPutRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserMeProjectFavoritesPut(apiV1UserMeProjectFavoritesPutRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserMeProjectFavoritesPut&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserMeTotpDelete(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserMeTotpDelete(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserMeTotpDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserMeTotpGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1UserMeTotpGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserMeTotpGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserMeTotpGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserMeTotpRecoveryCodesPost(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserMeTotpRecoveryCodesPost(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserMeTotpRecoveryCodesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserMeTotpRegisterPost(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1UserMeTotpRegisterPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserMeTotpRegisterPost(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserMeTotpRegisterPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserMeTotpVerifyPostRequest} apiV1UserMeTotpVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserMeTotpVerifyPost(apiV1UserMeTotpVerifyPostRequest: ApiV1UserMeTotpVerifyPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;object&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserMeTotpVerifyPost(apiV1UserMeTotpVerifyPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserMeTotpVerifyPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserMeUsernameGroupsGet(username: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV1UserMeUsernameGroupsGet200ResponseInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserMeUsernameGroupsGet(username, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserMeUsernameGroupsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserPrivateKeyGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1UserPrivateKeyGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserPrivateKeyGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserPrivateKeyGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectMembershipId Project membership ID of user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProjectAdditionalPrivilegeGet(projectMembershipId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1UserProjectAdditionalPrivilegeGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserProjectAdditionalPrivilegeGet(projectMembershipId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserProjectAdditionalPrivilegeGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserProjectAdditionalPrivilegePostRequest} apiV1UserProjectAdditionalPrivilegePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProjectAdditionalPrivilegePost(apiV1UserProjectAdditionalPrivilegePostRequest: ApiV1UserProjectAdditionalPrivilegePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1UserProjectAdditionalPrivilegePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserProjectAdditionalPrivilegePost(apiV1UserProjectAdditionalPrivilegePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserProjectAdditionalPrivilegePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} privilegeId The ID of privilege object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProjectAdditionalPrivilegePrivilegeIdDelete(privilegeId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1UserProjectAdditionalPrivilegePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserProjectAdditionalPrivilegePrivilegeIdDelete(privilegeId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserProjectAdditionalPrivilegePrivilegeIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} privilegeId The ID of privilege object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProjectAdditionalPrivilegePrivilegeIdGet(privilegeId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1UserProjectAdditionalPrivilegePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserProjectAdditionalPrivilegePrivilegeIdGet(privilegeId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserProjectAdditionalPrivilegePrivilegeIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} privilegeId The ID of privilege object.
         * @param {ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest} [apiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProjectAdditionalPrivilegePrivilegeIdPatch(privilegeId: string, apiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest?: ApiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1UserProjectAdditionalPrivilegePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserProjectAdditionalPrivilegePrivilegeIdPatch(privilegeId, apiV1UserProjectAdditionalPrivilegePrivilegeIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserProjectAdditionalPrivilegePrivilegeIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} token 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserUserIdUnlockGet(token: string, userId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1UserUserIdUnlockGet(token, userId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1UserUserIdUnlockGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [environment] 
         * @param {string} [secretPath] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WebhooksGet(workspaceId: string, environment?: string, secretPath?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WebhooksGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WebhooksGet(workspaceId, environment, secretPath, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WebhooksGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1WebhooksPostRequest} apiV1WebhooksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WebhooksPost(apiV1WebhooksPostRequest: ApiV1WebhooksPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WebhooksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WebhooksPost(apiV1WebhooksPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WebhooksPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WebhooksWebhookIdDelete(webhookId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WebhooksWebhookIdDelete(webhookId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WebhooksWebhookIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {ApiV1WebhooksWebhookIdPatchRequest} [apiV1WebhooksWebhookIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WebhooksWebhookIdPatch(webhookId: string, apiV1WebhooksWebhookIdPatchRequest?: ApiV1WebhooksWebhookIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WebhooksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WebhooksWebhookIdPatch(webhookId, apiV1WebhooksWebhookIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WebhooksWebhookIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WebhooksWebhookIdTestPost(webhookId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WebhooksPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WebhooksWebhookIdTestPost(webhookId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WebhooksWebhookIdTestPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowIntegrationsGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV1WorkflowIntegrationsGet200ResponseInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkflowIntegrationsGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkflowIntegrationsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowIntegrationsSlackGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV1WorkflowIntegrationsSlackGet200ResponseInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkflowIntegrationsSlackGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkflowIntegrationsSlackGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowIntegrationsSlackIdChannelsGet(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV1GatewaysGet200ResponseGatewaysInnerIdentity&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkflowIntegrationsSlackIdChannelsGet(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkflowIntegrationsSlackIdChannelsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowIntegrationsSlackIdDelete(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkflowIntegrationsSlackGet200ResponseInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkflowIntegrationsSlackIdDelete(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkflowIntegrationsSlackIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowIntegrationsSlackIdGet(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkflowIntegrationsSlackGet200ResponseInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkflowIntegrationsSlackIdGet(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkflowIntegrationsSlackIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ApiV1WorkflowIntegrationsSlackIdPatchRequest} [apiV1WorkflowIntegrationsSlackIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowIntegrationsSlackIdPatch(id: string, apiV1WorkflowIntegrationsSlackIdPatchRequest?: ApiV1WorkflowIntegrationsSlackIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkflowIntegrationsSlackGet200ResponseInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkflowIntegrationsSlackIdPatch(id, apiV1WorkflowIntegrationsSlackIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkflowIntegrationsSlackIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} slug 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowIntegrationsSlackInstallGet(slug: string, description?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;string&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkflowIntegrationsSlackInstallGet(slug, description, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkflowIntegrationsSlackInstallGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowIntegrationsSlackOauthRedirectGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkflowIntegrationsSlackOauthRedirectGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkflowIntegrationsSlackOauthRedirectGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowIntegrationsSlackReinstallGet(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;string&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkflowIntegrationsSlackReinstallGet(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkflowIntegrationsSlackReinstallGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Environment by ID
         * @param {string} envId The ID of the environment to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceEnvironmentsEnvIdGet(envId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceEnvironmentsEnvIdGet(envId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceEnvironmentsEnvIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1WorkspaceGetIncludeRolesEnum} [includeRoles] 
         * @param {ApiV1WorkspaceGetTypeEnum} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceGet(includeRoles?: ApiV1WorkspaceGetIncludeRolesEnum, type?: ApiV1WorkspaceGetTypeEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceGet(includeRoles, type, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceProjectIdPermissionsGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectIdPermissionsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceProjectIdPermissionsGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceProjectIdPermissionsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId The ID of the project to list tags from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceProjectIdTagsGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectIdTagsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceProjectIdTagsGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceProjectIdTagsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId The ID of the project to create the tag in.
         * @param {ApiV1WorkspaceProjectIdTagsPostRequest} apiV1WorkspaceProjectIdTagsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceProjectIdTagsPost(projectId: string, apiV1WorkspaceProjectIdTagsPostRequest: ApiV1WorkspaceProjectIdTagsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectIdTagsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceProjectIdTagsPost(projectId, apiV1WorkspaceProjectIdTagsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceProjectIdTagsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId The ID of the project to get tags from.
         * @param {string} tagSlug The slug of the tag to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceProjectIdTagsSlugTagSlugGet(projectId: string, tagSlug: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectIdTagsTagIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceProjectIdTagsSlugTagSlugGet(projectId, tagSlug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceProjectIdTagsSlugTagSlugGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId The ID of the project to delete the tag from.
         * @param {string} tagId The ID of the tag to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceProjectIdTagsTagIdDelete(projectId: string, tagId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectIdTagsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceProjectIdTagsTagIdDelete(projectId, tagId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceProjectIdTagsTagIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId The ID of the project to get tags from.
         * @param {string} tagId The ID of the tag to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceProjectIdTagsTagIdGet(projectId: string, tagId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectIdTagsTagIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceProjectIdTagsTagIdGet(projectId, tagId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceProjectIdTagsTagIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId The ID of the project to update the tag in.
         * @param {string} tagId The ID of the tag to get details.
         * @param {ApiV1WorkspaceProjectIdTagsTagIdPatchRequest} apiV1WorkspaceProjectIdTagsTagIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceProjectIdTagsTagIdPatch(projectId: string, tagId: string, apiV1WorkspaceProjectIdTagsTagIdPatchRequest: ApiV1WorkspaceProjectIdTagsTagIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectIdTagsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceProjectIdTagsTagIdPatch(projectId, tagId, apiV1WorkspaceProjectIdTagsTagIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceProjectIdTagsTagIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List project role
         * @param {string} projectSlug The slug of the project to list the roles of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceProjectSlugRolesGet(projectSlug: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceProjectSlugRolesGet(projectSlug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceProjectSlugRolesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a project role
         * @param {string} projectSlug Slug of the project to create the role for.
         * @param {ApiV1WorkspaceProjectSlugRolesPostRequest} apiV1WorkspaceProjectSlugRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceProjectSlugRolesPost(projectSlug: string, apiV1WorkspaceProjectSlugRolesPostRequest: ApiV1WorkspaceProjectSlugRolesPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceProjectSlugRolesPost(projectSlug, apiV1WorkspaceProjectSlugRolesPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceProjectSlugRolesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a project role
         * @param {string} projectSlug The slug of the project to delete this role for.
         * @param {string} roleId The ID of the role to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceProjectSlugRolesRoleIdDelete(projectSlug: string, roleId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceProjectSlugRolesRoleIdDelete(projectSlug, roleId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceProjectSlugRolesRoleIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a project role
         * @param {string} projectSlug The slug of the project to update the role for.
         * @param {string} roleId The ID of the role to update
         * @param {ApiV1WorkspaceProjectSlugRolesRoleIdPatchRequest} [apiV1WorkspaceProjectSlugRolesRoleIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceProjectSlugRolesRoleIdPatch(projectSlug: string, roleId: string, apiV1WorkspaceProjectSlugRolesRoleIdPatchRequest?: ApiV1WorkspaceProjectSlugRolesRoleIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceProjectSlugRolesRoleIdPatch(projectSlug, roleId, apiV1WorkspaceProjectSlugRolesRoleIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceProjectSlugRolesRoleIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectSlug The slug of the project.
         * @param {string} slug The slug of the role to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceProjectSlugRolesSlugSlugGet(projectSlug: string, slug: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesSlugSlugGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceProjectSlugRolesSlugSlugGet(projectSlug, slug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceProjectSlugRolesSlugSlugGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return audit logs
         * @param {string} workspaceId Optionally filter logs by project ID. If not provided, logs from the entire organization will be returned.
         * @param {ApiV1WorkspaceWorkspaceIdAuditLogsGetEventTypeEnum} [eventType] The type of the event to export.
         * @param {ApiV1WorkspaceWorkspaceIdAuditLogsGetUserAgentTypeEnum} [userAgentType] Choose which consuming application to export audit logs for.
         * @param {string} [startDate] The date to start the export from.
         * @param {string} [endDate] The date to end the export at.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th audit log.
         * @param {number} [limit] The number of audit logs to return.
         * @param {string} [actor] The actor to filter the audit logs by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdAuditLogsGet(workspaceId: string, eventType?: ApiV1WorkspaceWorkspaceIdAuditLogsGetEventTypeEnum, userAgentType?: ApiV1WorkspaceWorkspaceIdAuditLogsGetUserAgentTypeEnum, startDate?: string, endDate?: string, offset?: number, limit?: number, actor?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdAuditLogsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdAuditLogsGet(workspaceId, eventType, userAgentType, startDate, endDate, offset, limit, actor, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdAuditLogsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List integration auth objects for a workspace.
         * @param {string} workspaceId The ID of the project to list integration auths for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdAuthorizationsGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdIntegrationAuthorizationsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdAuthorizationsGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdAuthorizationsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest} apiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdAutoCapitalizationPost(workspaceId: string, apiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest: ApiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdNamePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdAutoCapitalizationPost(workspaceId, apiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdAutoCapitalizationPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete project
         * @param {string} workspaceId The ID of the project to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdDelete(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdDelete(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdEnvironmentFolderTreeGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;{ [key: string]: ApiV1WorkspaceWorkspaceIdEnvironmentFolderTreeGet200ResponseValue; }&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdEnvironmentFolderTreeGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdEnvironmentFolderTreeGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Environment
         * @param {string} workspaceId The ID of the project the environment belongs to.
         * @param {string} envId The ID of the environment to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet(workspaceId: string, envId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet(workspaceId, envId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete environment
         * @param {string} workspaceId The ID of the project to delete the environment from.
         * @param {string} id The ID of the environment to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdEnvironmentsIdDelete(workspaceId: string, id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdEnvironmentsIdDelete(workspaceId, id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdEnvironmentsIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update environment
         * @param {string} workspaceId The ID of the project to update the environment in.
         * @param {string} id The ID of the environment to update.
         * @param {ApiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest} [apiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdEnvironmentsIdPatch(workspaceId: string, id: string, apiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest?: ApiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdEnvironmentsIdPatch(workspaceId, id, apiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdEnvironmentsIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create environment
         * @param {string} workspaceId The ID of the project to create the environment in.
         * @param {ApiV1WorkspaceWorkspaceIdEnvironmentsPostRequest} apiV1WorkspaceWorkspaceIdEnvironmentsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdEnvironmentsPost(workspaceId: string, apiV1WorkspaceWorkspaceIdEnvironmentsPostRequest: ApiV1WorkspaceWorkspaceIdEnvironmentsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdEnvironmentsPost(workspaceId, apiV1WorkspaceWorkspaceIdEnvironmentsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdEnvironmentsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get project
         * @param {string} workspaceId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List integrations for a project.
         * @param {string} workspaceId The ID of the project to list integrations for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdIntegrationsGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdIntegrationsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdIntegrationsGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdIntegrationsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdKeyPostRequest} apiV1WorkspaceWorkspaceIdKeyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdKeyPost(workspaceId: string, apiV1WorkspaceWorkspaceIdKeyPostRequest: ApiV1WorkspaceWorkspaceIdKeyPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdKeyPost(workspaceId, apiV1WorkspaceWorkspaceIdKeyPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdKeyPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdKeysGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdKeysGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdKeysGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdKeysGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdKmsBackupGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdKmsBackupGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdKmsBackupGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdKmsBackupGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdKmsBackupPostRequest} apiV1WorkspaceWorkspaceIdKmsBackupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdKmsBackupPost(workspaceId: string, apiV1WorkspaceWorkspaceIdKmsBackupPostRequest: ApiV1WorkspaceWorkspaceIdKmsBackupPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdKmsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdKmsBackupPost(workspaceId, apiV1WorkspaceWorkspaceIdKmsBackupPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdKmsBackupPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdKmsGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdKmsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdKmsGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdKmsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdKmsPatchRequest} apiV1WorkspaceWorkspaceIdKmsPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdKmsPatch(workspaceId: string, apiV1WorkspaceWorkspaceIdKmsPatchRequest: ApiV1WorkspaceWorkspaceIdKmsPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdKmsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdKmsPatch(workspaceId, apiV1WorkspaceWorkspaceIdKmsPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdKmsPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdLeaveDelete(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdLeaveDelete(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdLeaveDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return project user memberships
         * @param {string} workspaceId The ID of the project to get memberships from.
         * @param {ApiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest} apiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdMembershipsDetailsPost(workspaceId: string, apiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest: ApiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsDetailsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdMembershipsDetailsPost(workspaceId, apiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdMembershipsDetailsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return project user memberships
         * @param {string} workspaceId The ID of the project to get memberships from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdMembershipsGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdMembershipsGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdMembershipsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete project user membership
         * @param {string} workspaceId 
         * @param {string} membershipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdMembershipsMembershipIdDelete(workspaceId: string, membershipId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdMembershipsMembershipIdDelete(workspaceId, membershipId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdMembershipsMembershipIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return project user membership
         * @param {string} workspaceId The ID of the project to get memberships from.
         * @param {string} membershipId The ID of the user\&amp;#39;s project membership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdMembershipsMembershipIdGet(workspaceId: string, membershipId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdMembershipsMembershipIdGet(workspaceId, membershipId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdMembershipsMembershipIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update project user membership
         * @param {string} workspaceId The ID of the project to update the membership for.
         * @param {string} membershipId The ID of the membership to update.
         * @param {ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest} apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch(workspaceId: string, membershipId: string, apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest: ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch(workspaceId, membershipId, apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdMembershipsPostRequest} apiV1WorkspaceWorkspaceIdMembershipsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdMembershipsPost(workspaceId: string, apiV1WorkspaceWorkspaceIdMembershipsPostRequest: ApiV1WorkspaceWorkspaceIdMembershipsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdMembershipsPost(workspaceId, apiV1WorkspaceWorkspaceIdMembershipsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdMembershipsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdMigrateV3Post(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdMigrateV3Post(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdMigrateV3Post&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdNamePostRequest} apiV1WorkspaceWorkspaceIdNamePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdNamePost(workspaceId: string, apiV1WorkspaceWorkspaceIdNamePostRequest: ApiV1WorkspaceWorkspaceIdNamePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdNamePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdNamePost(workspaceId, apiV1WorkspaceWorkspaceIdNamePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdNamePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update project
         * @param {string} workspaceId The ID of the project to update.
         * @param {ApiV1WorkspaceWorkspaceIdPatchRequest} [apiV1WorkspaceWorkspaceIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdPatch(workspaceId: string, apiV1WorkspaceWorkspaceIdPatchRequest?: ApiV1WorkspaceWorkspaceIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdPatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdPatch(workspaceId, apiV1WorkspaceWorkspaceIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} environment 
         * @param {string} workspaceId 
         * @param {string} [path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet(environment: string, workspaceId: string, path?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet(environment, workspaceId, path, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return project secret snapshots ids
         * @param {string} environment The environment to get snapshots from.
         * @param {string} workspaceId The ID of the project to get snapshots from.
         * @param {string} [path] The secret path to get snapshots from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th snapshot.
         * @param {number} [limit] The number of snapshots to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdSecretSnapshotsGet(environment: string, workspaceId: string, path?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdSecretSnapshotsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdSecretSnapshotsGet(environment, workspaceId, path, offset, limit, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdSecretSnapshotsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdServiceTokenDataGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdServiceTokenDataGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdServiceTokenDataGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdServiceTokenDataGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdSlackConfigGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdSlackConfigGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdSlackConfigGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdSlackConfigGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdSlackConfigPutRequest} apiV1WorkspaceWorkspaceIdSlackConfigPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdSlackConfigPut(workspaceId: string, apiV1WorkspaceWorkspaceIdSlackConfigPutRequest: ApiV1WorkspaceWorkspaceIdSlackConfigPutRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdSlackConfigGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdSlackConfigPut(workspaceId, apiV1WorkspaceWorkspaceIdSlackConfigPutRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdSlackConfigPut&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdTrustedIpsGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdTrustedIpsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdTrustedIpsGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdTrustedIpsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdTrustedIpsPostRequest} apiV1WorkspaceWorkspaceIdTrustedIpsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdTrustedIpsPost(workspaceId: string, apiV1WorkspaceWorkspaceIdTrustedIpsPostRequest: ApiV1WorkspaceWorkspaceIdTrustedIpsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdTrustedIpsPost(workspaceId, apiV1WorkspaceWorkspaceIdTrustedIpsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdTrustedIpsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} trustedIpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdDelete(workspaceId: string, trustedIpId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdDelete(workspaceId, trustedIpId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} trustedIpId 
         * @param {ApiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest} apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatch(workspaceId: string, trustedIpId: string, apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest: ApiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatch(workspaceId, trustedIpId, apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ApiV1WorkspaceWorkspaceIdUsersGetIncludeGroupMembersEnum} [includeGroupMembers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceIdUsersGet(workspaceId: string, includeGroupMembers?: ApiV1WorkspaceWorkspaceIdUsersGetIncludeGroupMembersEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdUsersGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceIdUsersGet(workspaceId, includeGroupMembers, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceIdUsersGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceSlug 
         * @param {ApiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest} apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPut(workspaceSlug: string, apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest: ApiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdNamePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPut(workspaceSlug, apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceSlugAuditLogsRetentionPut&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceSlug 
         * @param {ApiV1WorkspaceWorkspaceSlugVersionLimitPutRequest} apiV1WorkspaceWorkspaceSlugVersionLimitPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkspaceWorkspaceSlugVersionLimitPut(workspaceSlug: string, apiV1WorkspaceWorkspaceSlugVersionLimitPutRequest: ApiV1WorkspaceWorkspaceSlugVersionLimitPutRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdNamePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV1WorkspaceWorkspaceSlugVersionLimitPut(workspaceSlug, apiV1WorkspaceWorkspaceSlugVersionLimitPutRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV1WorkspaceWorkspaceSlugVersionLimitPut&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2AuthMfaCheckTotpGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2AuthMfaCheckTotpGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2AuthMfaCheckTotpGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2AuthMfaCheckTotpGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2AuthMfaSendPost(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2AuthMfaSendPost(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2AuthMfaSendPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV2AuthMfaVerifyPostRequest} apiV2AuthMfaVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2AuthMfaVerifyPost(apiV2AuthMfaVerifyPostRequest: ApiV2AuthMfaVerifyPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2AuthMfaVerifyPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2AuthMfaVerifyPost(apiV2AuthMfaVerifyPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2AuthMfaVerifyPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List privileges for the specified identity by project.
         * @param {string} identityId The ID of the identity to list.
         * @param {string} projectId The ID of the project that the identity is in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2IdentityProjectAdditionalPrivilegeGet(identityId: string, projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2IdentityProjectAdditionalPrivilegeGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2IdentityProjectAdditionalPrivilegeGet(identityId, projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2IdentityProjectAdditionalPrivilegeGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified identity privilege.
         * @param {string} id The ID of the identity privilege.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2IdentityProjectAdditionalPrivilegeIdDelete(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2IdentityProjectAdditionalPrivilegeIdDelete(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2IdentityProjectAdditionalPrivilegeIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a specific privilege by id.
         * @param {string} id The ID of the identity privilege.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2IdentityProjectAdditionalPrivilegeIdGet(id: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2IdentityProjectAdditionalPrivilegeIdGet(id, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2IdentityProjectAdditionalPrivilegeIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific identity privilege.
         * @param {string} id The ID of the identity privilege.
         * @param {ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequest} apiV2IdentityProjectAdditionalPrivilegeIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2IdentityProjectAdditionalPrivilegeIdPatch(id: string, apiV2IdentityProjectAdditionalPrivilegeIdPatchRequest: ApiV2IdentityProjectAdditionalPrivilegeIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2IdentityProjectAdditionalPrivilegeIdPatch(id, apiV2IdentityProjectAdditionalPrivilegeIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2IdentityProjectAdditionalPrivilegeIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add an additional privilege for identity.
         * @param {ApiV2IdentityProjectAdditionalPrivilegePostRequest} apiV2IdentityProjectAdditionalPrivilegePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2IdentityProjectAdditionalPrivilegePost(apiV2IdentityProjectAdditionalPrivilegePostRequest: ApiV2IdentityProjectAdditionalPrivilegePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2IdentityProjectAdditionalPrivilegePost(apiV2IdentityProjectAdditionalPrivilegePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2IdentityProjectAdditionalPrivilegePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a specific privilege by slug.
         * @param {string} identityId The ID of the identity to list.
         * @param {string} projectSlug The slug of the project of the identity in.
         * @param {string} privilegeSlug The slug of the privilege.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2IdentityProjectAdditionalPrivilegeSlugPrivilegeSlugGet(identityId: string, projectSlug: string, privilegeSlug: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1AdditionalPrivilegeIdentityPermanentPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2IdentityProjectAdditionalPrivilegeSlugPrivilegeSlugGet(identityId, projectSlug, privilegeSlug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2IdentityProjectAdditionalPrivilegeSlugPrivilegeSlugGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return organization identity memberships
         * @param {string} orgId The ID of the organization to get identity memberships from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th identity membership.
         * @param {number} [limit] The number of identity memberships to return.
         * @param {ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderByEnum} [orderBy] The column to order identity memberships by.
         * @param {ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderDirectionEnum} [orderDirection] The direction identity memberships will be sorted in.
         * @param {string} [search] The text string that identity membership names will be filtered by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2OrganizationsOrgIdIdentityMembershipsGet(orgId: string, offset?: number, limit?: number, orderBy?: ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderByEnum, orderDirection?: ApiV2OrganizationsOrgIdIdentityMembershipsGetOrderDirectionEnum, search?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2OrganizationsOrgIdIdentityMembershipsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2OrganizationsOrgIdIdentityMembershipsGet(orgId, offset, limit, orderBy, orderDirection, search, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2OrganizationsOrgIdIdentityMembershipsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2OrganizationsOrganizationIdDelete(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2OrganizationsOrganizationIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2OrganizationsOrganizationIdDelete(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2OrganizationsOrganizationIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return organization user memberships
         * @param {string} organizationId The ID of the organization to get memberships from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2OrganizationsOrganizationIdMembershipsGet(organizationId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2OrganizationsOrganizationIdMembershipsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2OrganizationsOrganizationIdMembershipsGet(organizationId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2OrganizationsOrganizationIdMembershipsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete organization user memberships
         * @param {string} organizationId The ID of the organization to delete the membership from.
         * @param {string} membershipId The ID of the membership to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete(organizationId: string, membershipId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete(organizationId, membershipId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization user membership
         * @param {string} organizationId The ID of the organization to get the membership for.
         * @param {string} membershipId The ID of the membership to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2OrganizationsOrganizationIdMembershipsMembershipIdGet(organizationId: string, membershipId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2OrganizationsOrganizationIdMembershipsMembershipIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2OrganizationsOrganizationIdMembershipsMembershipIdGet(organizationId, membershipId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2OrganizationsOrganizationIdMembershipsMembershipIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update organization user memberships
         * @param {string} organizationId The ID of the organization to update the membership for.
         * @param {string} membershipId The ID of the membership to update.
         * @param {ApiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest} [apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatch(organizationId: string, membershipId: string, apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest?: ApiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatch(organizationId, membershipId, apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2OrganizationsOrganizationIdMembershipsMembershipIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get project memberships given organization membership
         * @param {string} organizationId The ID of the organization to delete the membership from.
         * @param {string} membershipId The ID of the membership to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet(organizationId: string, membershipId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet(organizationId, membershipId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return projects in organization that user is apart of
         * @param {string} organizationId The ID of the organization to get projects from.
         * @param {ApiV2OrganizationsOrganizationIdWorkspacesGetTypeEnum} [type] The type of project to filter by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2OrganizationsOrganizationIdWorkspacesGet(organizationId: string, type?: ApiV2OrganizationsOrganizationIdWorkspacesGetTypeEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2OrganizationsOrganizationIdWorkspacesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2OrganizationsOrganizationIdWorkspacesGet(organizationId, type, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2OrganizationsOrganizationIdWorkspacesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV2OrganizationsPostRequest} apiV2OrganizationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2OrganizationsPost(apiV2OrganizationsPostRequest: ApiV2OrganizationsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2OrganizationsPost(apiV2OrganizationsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2OrganizationsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2OrganizationsPrivilegeSystemUpgradePost(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationOrganizationIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2OrganizationsPrivilegeSystemUpgradePost(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2OrganizationsPrivilegeSystemUpgradePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV2PasswordPasswordResetPostRequest} apiV2PasswordPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2PasswordPasswordResetPost(apiV2PasswordPasswordResetPostRequest: ApiV2PasswordPasswordResetPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2PasswordPasswordResetPost(apiV2PasswordPasswordResetPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2PasswordPasswordResetPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV2PasswordUserPasswordResetPostRequest} apiV2PasswordUserPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2PasswordUserPasswordResetPost(apiV2PasswordUserPasswordResetPostRequest: ApiV2PasswordUserPasswordResetPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2PasswordUserPasswordResetPost(apiV2PasswordUserPasswordResetPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2PasswordUserPasswordResetPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return Infisical Token data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2ServiceTokenGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2ServiceTokenGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2ServiceTokenGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2ServiceTokenGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV2ServiceTokenPostRequest} apiV2ServiceTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2ServiceTokenPost(apiV2ServiceTokenPostRequest: ApiV2ServiceTokenPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2ServiceTokenPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2ServiceTokenPost(apiV2ServiceTokenPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2ServiceTokenPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} serviceTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2ServiceTokenServiceTokenIdDelete(serviceTokenId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2ServiceTokenServiceTokenIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2ServiceTokenServiceTokenIdDelete(serviceTokenId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2ServiceTokenServiceTokenIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} apiKeyDataId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2UsersMeApiKeysApiKeyDataIdDelete(apiKeyDataId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2UsersMeApiKeysApiKeyDataIdDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2UsersMeApiKeysApiKeyDataIdDelete(apiKeyDataId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2UsersMeApiKeysApiKeyDataIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2UsersMeApiKeysGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV2UsersMeApiKeysGet200ResponseInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2UsersMeApiKeysGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2UsersMeApiKeysGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV2UsersMeApiKeysPostRequest} apiV2UsersMeApiKeysPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2UsersMeApiKeysPost(apiV2UsersMeApiKeysPostRequest: ApiV2UsersMeApiKeysPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2UsersMeApiKeysPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2UsersMeApiKeysPost(apiV2UsersMeApiKeysPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2UsersMeApiKeysPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV2UsersMeAuthMethodsPutRequest} apiV2UsersMeAuthMethodsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2UsersMeAuthMethodsPut(apiV2UsersMeAuthMethodsPutRequest: ApiV2UsersMeAuthMethodsPutRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2UsersMeMfaPatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2UsersMeAuthMethodsPut(apiV2UsersMeAuthMethodsPutRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2UsersMeAuthMethodsPut&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2UsersMeDelete(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2UsersMeMfaPatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2UsersMeDelete(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2UsersMeDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV2UsersMeEmailsCodePostRequest} apiV2UsersMeEmailsCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2UsersMeEmailsCodePost(apiV2UsersMeEmailsCodePostRequest: ApiV2UsersMeEmailsCodePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;object&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2UsersMeEmailsCodePost(apiV2UsersMeEmailsCodePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2UsersMeEmailsCodePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV2UsersMeEmailsVerifyPostRequest} apiV2UsersMeEmailsVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2UsersMeEmailsVerifyPost(apiV2UsersMeEmailsVerifyPostRequest: ApiV2UsersMeEmailsVerifyPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;object&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2UsersMeEmailsVerifyPost(apiV2UsersMeEmailsVerifyPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2UsersMeEmailsVerifyPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the current user on the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2UsersMeGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1UserGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2UsersMeGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2UsersMeGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV2UsersMeMfaPatchRequest} [apiV2UsersMeMfaPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2UsersMeMfaPatch(apiV2UsersMeMfaPatchRequest?: ApiV2UsersMeMfaPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2UsersMeMfaPatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2UsersMeMfaPatch(apiV2UsersMeMfaPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2UsersMeMfaPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV2UsersMeNamePatchRequest} apiV2UsersMeNamePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2UsersMeNamePatch(apiV2UsersMeNamePatchRequest: ApiV2UsersMeNamePatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2UsersMeMfaPatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2UsersMeNamePatch(apiV2UsersMeNamePatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2UsersMeNamePatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return organizations that current user is part of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2UsersMeOrganizationsGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2UsersMeOrganizationsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2UsersMeOrganizationsGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2UsersMeOrganizationsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2UsersMeSessionsDelete(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2UsersMeSessionsDelete(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2UsersMeSessionsDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2UsersMeSessionsGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;Array&lt;ApiV2UsersMeSessionsGet200ResponseInner&gt;&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2UsersMeSessionsGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2UsersMeSessionsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new project
         * @param {ApiV2WorkspacePostRequest} apiV2WorkspacePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspacePost(apiV2WorkspacePostRequest: ApiV2WorkspacePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspacePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspacePost(apiV2WorkspacePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspacePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdCertificateTemplatesGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdCertificateTemplatesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdCertificateTemplatesGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdCertificateTemplatesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return list of groups in project
         * @param {string} projectId The ID of the project to list groups for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdGroupsGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdGroupsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdGroupsGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdGroupsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove group from project
         * @param {string} projectId The ID of the project to delete the group from.
         * @param {string} groupId The ID of the group to delete from the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdGroupsGroupIdDelete(projectId: string, groupId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdGroupsGroupIdOrNamePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdGroupsGroupIdDelete(projectId, groupId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdGroupsGroupIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return project group
         * @param {string} projectId 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdGroupsGroupIdGet(projectId: string, groupId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdGroupsGroupIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdGroupsGroupIdGet(projectId, groupId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdGroupsGroupIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add group to project
         * @param {string} projectId The ID of the project to add the group to.
         * @param {string} groupIdOrName The ID or name of the group to add to the project.
         * @param {ApiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest} [apiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdGroupsGroupIdOrNamePost(projectId: string, groupIdOrName: string, apiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest?: ApiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdGroupsGroupIdOrNamePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdGroupsGroupIdOrNamePost(projectId, groupIdOrName, apiV2WorkspaceProjectIdGroupsGroupIdOrNamePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdGroupsGroupIdOrNamePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update group in project
         * @param {string} projectId The ID of the project to update the group in.
         * @param {string} groupId The ID of the group to update in the project.
         * @param {ApiV2WorkspaceProjectIdGroupsGroupIdPatchRequest} apiV2WorkspaceProjectIdGroupsGroupIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdGroupsGroupIdPatch(projectId: string, groupId: string, apiV2WorkspaceProjectIdGroupsGroupIdPatchRequest: ApiV2WorkspaceProjectIdGroupsGroupIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdGroupsGroupIdPatch(projectId, groupId, apiV2WorkspaceProjectIdGroupsGroupIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdGroupsGroupIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return project identity memberships
         * @param {string} projectId The ID of the project to get identity memberships from.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th identity membership.
         * @param {number} [limit] The number of identity memberships to return.
         * @param {ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderByEnum} [orderBy] The column to order identity memberships by.
         * @param {ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderDirectionEnum} [orderDirection] The direction identity memberships will be sorted in.
         * @param {string} [search] The text string that identity membership names will be filtered by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdIdentityMembershipsGet(projectId: string, offset?: number, limit?: number, orderBy?: ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderByEnum, orderDirection?: ApiV2WorkspaceProjectIdIdentityMembershipsGetOrderDirectionEnum, search?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdIdentityMembershipsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdIdentityMembershipsGet(projectId, offset, limit, orderBy, orderDirection, search, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdIdentityMembershipsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete project identity memberships
         * @param {string} projectId The ID of the project to delete the identity membership from.
         * @param {string} identityId The ID of the identity to delete the membership from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdDelete(projectId: string, identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdDelete(projectId, identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return project identity membership
         * @param {string} projectId The ID of the project to get the identity membership for.
         * @param {string} identityId The ID of the identity to get the membership for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet(projectId: string, identityId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet(projectId, identityId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update project identity memberships
         * @param {string} projectId The ID of the project to update the identity membership for.
         * @param {string} identityId The ID of the identity to update the membership for.
         * @param {ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest} apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatch(projectId: string, identityId: string, apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest: ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatch(projectId, identityId, apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create project identity membership
         * @param {string} projectId 
         * @param {string} identityId 
         * @param {ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest} [apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost(projectId: string, identityId: string, apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest?: ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost(projectId, identityId, apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove members from project
         * @param {string} projectId The ID of the project to remove the member from.
         * @param {ApiV2WorkspaceProjectIdMembershipsDeleteRequest} [apiV2WorkspaceProjectIdMembershipsDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdMembershipsDelete(projectId: string, apiV2WorkspaceProjectIdMembershipsDeleteRequest?: ApiV2WorkspaceProjectIdMembershipsDeleteRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdMembershipsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdMembershipsDelete(projectId, apiV2WorkspaceProjectIdMembershipsDeleteRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdMembershipsDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite members to project
         * @param {string} projectId The ID of the project to invite the member to.
         * @param {ApiV2WorkspaceProjectIdMembershipsPostRequest} [apiV2WorkspaceProjectIdMembershipsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdMembershipsPost(projectId: string, apiV2WorkspaceProjectIdMembershipsPostRequest?: ApiV2WorkspaceProjectIdMembershipsPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdMembershipsPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdMembershipsPost(projectId, apiV2WorkspaceProjectIdMembershipsPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdMembershipsPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdPkiAlertsGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdPkiAlertsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdPkiAlertsGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdPkiAlertsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdPkiCollectionsGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdPkiCollectionsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdPkiCollectionsGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdPkiCollectionsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List project role
         * @param {string} projectId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdRolesGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdRolesGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdRolesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a project role
         * @param {string} projectId Id of the project to create the role for.
         * @param {ApiV2WorkspaceProjectIdRolesPostRequest} apiV2WorkspaceProjectIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdRolesPost(projectId: string, apiV2WorkspaceProjectIdRolesPostRequest: ApiV2WorkspaceProjectIdRolesPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdRolesPost(projectId, apiV2WorkspaceProjectIdRolesPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdRolesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a project role
         * @param {string} projectId The ID of the project to delete the role for.
         * @param {string} roleId The ID of the role to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdRolesRoleIdDelete(projectId: string, roleId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdRolesRoleIdDelete(projectId, roleId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdRolesRoleIdDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a project role
         * @param {string} projectId The ID of the project to update the role for.
         * @param {string} roleId The ID of the role to update
         * @param {ApiV2WorkspaceProjectIdRolesRoleIdPatchRequest} [apiV2WorkspaceProjectIdRolesRoleIdPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdRolesRoleIdPatch(projectId: string, roleId: string, apiV2WorkspaceProjectIdRolesRoleIdPatchRequest?: ApiV2WorkspaceProjectIdRolesRoleIdPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdRolesRoleIdPatch(projectId, roleId, apiV2WorkspaceProjectIdRolesRoleIdPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdRolesRoleIdPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId The ID of the project.
         * @param {string} roleSlug The slug of the role to get details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdRolesSlugRoleSlugGet(projectId: string, roleSlug: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceProjectSlugRolesSlugSlugGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdRolesSlugRoleSlugGet(projectId, roleSlug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdRolesSlugRoleSlugGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId The ID of the project to list SSH CAs for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdSshCasGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdSshCasGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdSshCasGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdSshCasGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId The ID of the project to list SSH certificate templates for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdSshCertificateTemplatesGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1SshCaSshCaIdCertificateTemplatesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdSshCertificateTemplatesGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdSshCertificateTemplatesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId The ID of the project to list SSH CAs for.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th SSH certificate.
         * @param {number} [limit] The number of SSH certificates to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdSshCertificatesGet(projectId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdSshCertificatesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdSshCertificatesGet(projectId, offset, limit, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdSshCertificatesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {ApiV2WorkspaceProjectIdUpgradePostRequest} apiV2WorkspaceProjectIdUpgradePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdUpgradePost(projectId: string, apiV2WorkspaceProjectIdUpgradePostRequest: ApiV2WorkspaceProjectIdUpgradePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;any&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdUpgradePost(projectId, apiV2WorkspaceProjectIdUpgradePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdUpgradePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceProjectIdUpgradeStatusGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceProjectIdUpgradeStatusGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceProjectIdUpgradeStatusGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceProjectIdUpgradeStatusGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} slug The slug of the project to list CAs for.
         * @param {ApiV2WorkspaceSlugCasGetStatusEnum} [status] The status of the CA to filter by.
         * @param {string} [friendlyName] The friendly name of the CA to filter by.
         * @param {string} [commonName] The common name of the CA to filter by.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th CA.
         * @param {number} [limit] The number of CAs to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceSlugCasGet(slug: string, status?: ApiV2WorkspaceSlugCasGetStatusEnum, friendlyName?: string, commonName?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceSlugCasGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceSlugCasGet(slug, status, friendlyName, commonName, offset, limit, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceSlugCasGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} slug The slug of the project to list certificates for.
         * @param {string} [friendlyName] The friendly name of the certificate to filter by.
         * @param {string} [commonName] The common name of the certificate to filter by.
         * @param {number} [offset] The offset to start from. If you enter 10, it will start from the 10th certificate.
         * @param {number} [limit] The number of certificates to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceSlugCertificatesGet(slug: string, friendlyName?: string, commonName?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceSlugCertificatesGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceSlugCertificatesGet(slug, friendlyName, commonName, offset, limit, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceSlugCertificatesGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete project
         * @param {string} slug The slug of the project to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceSlugDelete(slug: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationAdminProjectsGet200ResponseProjectsInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceSlugDelete(slug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceSlugDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} slug The slug of the project to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceSlugGet(slug: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdGet200ResponseWorkspace&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceSlugGet(slug, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceSlugGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} slug The slug of the project to update.
         * @param {ApiV2WorkspaceSlugPatchRequest} [apiV2WorkspaceSlugPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceSlugPatch(slug: string, apiV2WorkspaceSlugPatchRequest?: ApiV2WorkspaceSlugPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1OrganizationAdminProjectsGet200ResponseProjectsInner&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceSlugPatch(slug, apiV2WorkspaceSlugPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceSlugPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return encrypted project key
         * @param {string} workspaceId The ID of the project to get the key from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV2WorkspaceWorkspaceIdEncryptedKeyGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2WorkspaceWorkspaceIdEncryptedKeyGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV2WorkspaceWorkspaceIdEncryptedKeyGet(workspaceId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV2WorkspaceWorkspaceIdEncryptedKeyGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV3AuthLogin1PostRequest} apiV3AuthLogin1PostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3AuthLogin1Post(apiV3AuthLogin1PostRequest: ApiV3AuthLogin1PostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1PasswordSrp1Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3AuthLogin1Post(apiV3AuthLogin1PostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3AuthLogin1Post&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV3AuthLogin2PostRequest} apiV3AuthLogin2PostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3AuthLogin2Post(apiV3AuthLogin2PostRequest: ApiV3AuthLogin2PostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV2AuthMfaVerifyPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3AuthLogin2Post(apiV3AuthLogin2PostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3AuthLogin2Post&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV3AuthSelectOrganizationPostRequest} apiV3AuthSelectOrganizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3AuthSelectOrganizationPost(apiV3AuthSelectOrganizationPostRequest: ApiV3AuthSelectOrganizationPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3AuthSelectOrganizationPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3AuthSelectOrganizationPost(apiV3AuthSelectOrganizationPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3AuthSelectOrganizationPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3MigrateEnvKeyPost(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3MigrateEnvKeyPost(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3MigrateEnvKeyPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Backfill secret references
         * @param {ApiV3SecretsBackfillSecretReferencesPostRequest} apiV3SecretsBackfillSecretReferencesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsBackfillSecretReferencesPost(apiV3SecretsBackfillSecretReferencesPostRequest: ApiV3SecretsBackfillSecretReferencesPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsBackfillSecretReferencesPost(apiV3SecretsBackfillSecretReferencesPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsBackfillSecretReferencesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV3SecretsBatchDeleteRequest} apiV3SecretsBatchDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsBatchDelete(apiV3SecretsBatchDeleteRequest: ApiV3SecretsBatchDeleteRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsBatchDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsBatchDelete(apiV3SecretsBatchDeleteRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsBatchDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV3SecretsBatchPatchRequest} apiV3SecretsBatchPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsBatchPatch(apiV3SecretsBatchPatchRequest: ApiV3SecretsBatchPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsBatchDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsBatchPatch(apiV3SecretsBatchPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsBatchPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV3SecretsBatchPostRequest} apiV3SecretsBatchPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsBatchPost(apiV3SecretsBatchPostRequest: ApiV3SecretsBatchPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsBatchPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsBatchPost(apiV3SecretsBatchPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsBatchPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete many secrets
         * @param {ApiV3SecretsBatchRawDeleteRequest} apiV3SecretsBatchRawDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsBatchRawDelete(apiV3SecretsBatchRawDeleteRequest: ApiV3SecretsBatchRawDeleteRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsBatchRawDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsBatchRawDelete(apiV3SecretsBatchRawDeleteRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsBatchRawDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update many secrets
         * @param {ApiV3SecretsBatchRawPatchRequest} apiV3SecretsBatchRawPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsBatchRawPatch(apiV3SecretsBatchRawPatchRequest: ApiV3SecretsBatchRawPatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsBatchRawDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsBatchRawPatch(apiV3SecretsBatchRawPatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsBatchRawPatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create many secrets
         * @param {ApiV3SecretsBatchRawPostRequest} apiV3SecretsBatchRawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsBatchRawPost(apiV3SecretsBatchRawPostRequest: ApiV3SecretsBatchRawPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsBatchRawPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsBatchRawPost(apiV3SecretsBatchRawPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsBatchRawPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} [secretPath] 
         * @param {ApiV3SecretsGetRecursiveEnum} [recursive] 
         * @param {ApiV3SecretsGetIncludeImportsEnum} [includeImports] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsGet(workspaceId: string, environment: string, secretPath?: string, recursive?: ApiV3SecretsGetRecursiveEnum, includeImports?: ApiV3SecretsGetIncludeImportsEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsGet(workspaceId, environment, secretPath, recursive, includeImports, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV3SecretsMovePostRequest} apiV3SecretsMovePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsMovePost(apiV3SecretsMovePostRequest: ApiV3SecretsMovePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsMovePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsMovePost(apiV3SecretsMovePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsMovePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List secrets
         * @param {string} [metadataFilter] The secret metadata key-value pairs to filter secrets by. When querying for multiple metadata pairs, the query is treated as an AND operation. Secret metadata format is key&amp;#x3D;value1,value&amp;#x3D;value2|key&amp;#x3D;value3,value&amp;#x3D;value4.
         * @param {string} [workspaceId] The ID of the project to list secrets from.
         * @param {string} [workspaceSlug] The slug of the project to list secrets from. This parameter is only applicable by machine identities.
         * @param {string} [environment] The slug of the environment to list secrets from.
         * @param {string} [secretPath] The secret path to list secrets from.
         * @param {ApiV3SecretsRawGetViewSecretValueEnum} [viewSecretValue] Whether or not to retrieve the secret value.
         * @param {ApiV3SecretsRawGetExpandSecretReferencesEnum} [expandSecretReferences] Whether or not to expand secret references.
         * @param {ApiV3SecretsRawGetRecursiveEnum} [recursive] Whether or not to fetch all secrets from the specified base path, and all of its subdirectories. Note, the max depth is 20 deep.
         * @param {ApiV3SecretsRawGetIncludeImportsEnum} [includeImports] Weather to include imported secrets or not.
         * @param {string} [tagSlugs] The comma separated tag slugs to filter secrets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsRawGet(metadataFilter?: string, workspaceId?: string, workspaceSlug?: string, environment?: string, secretPath?: string, viewSecretValue?: ApiV3SecretsRawGetViewSecretValueEnum, expandSecretReferences?: ApiV3SecretsRawGetExpandSecretReferencesEnum, recursive?: ApiV3SecretsRawGetRecursiveEnum, includeImports?: ApiV3SecretsRawGetIncludeImportsEnum, tagSlugs?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsRawGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsRawGet(metadataFilter, workspaceId, workspaceSlug, environment, secretPath, viewSecretValue, expandSecretReferences, recursive, includeImports, tagSlugs, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsRawGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} secretId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsRawIdSecretIdGet(secretId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsRawIdSecretIdGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsRawIdSecretIdGet(secretId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsRawIdSecretIdGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete secret
         * @param {string} secretName The name of the secret to delete.
         * @param {ApiV3SecretsRawSecretNameDeleteRequest} apiV3SecretsRawSecretNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsRawSecretNameDelete(secretName: string, apiV3SecretsRawSecretNameDeleteRequest: ApiV3SecretsRawSecretNameDeleteRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsRawSecretNameDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsRawSecretNameDelete(secretName, apiV3SecretsRawSecretNameDeleteRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsRawSecretNameDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a secret by name
         * @param {string} secretName The name of the secret to get.
         * @param {string} [workspaceId] The ID of the project to get the secret from.
         * @param {string} [workspaceSlug] The slug of the project to get the secret from.
         * @param {string} [environment] The slug of the environment to get the secret from.
         * @param {string} [secretPath] The path of the secret to get.
         * @param {number} [version] The version of the secret to get.
         * @param {ApiV3SecretsRawSecretNameGetTypeEnum} [type] The type of the secret to get.
         * @param {ApiV3SecretsRawSecretNameGetViewSecretValueEnum} [viewSecretValue] Whether or not to retrieve the secret value.
         * @param {ApiV3SecretsRawSecretNameGetExpandSecretReferencesEnum} [expandSecretReferences] Whether or not to expand secret references.
         * @param {ApiV3SecretsRawSecretNameGetIncludeImportsEnum} [includeImports] Weather to include imported secrets or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsRawSecretNameGet(secretName: string, workspaceId?: string, workspaceSlug?: string, environment?: string, secretPath?: string, version?: number, type?: ApiV3SecretsRawSecretNameGetTypeEnum, viewSecretValue?: ApiV3SecretsRawSecretNameGetViewSecretValueEnum, expandSecretReferences?: ApiV3SecretsRawSecretNameGetExpandSecretReferencesEnum, includeImports?: ApiV3SecretsRawSecretNameGetIncludeImportsEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsRawSecretNameGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsRawSecretNameGet(secretName, workspaceId, workspaceSlug, environment, secretPath, version, type, viewSecretValue, expandSecretReferences, includeImports, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsRawSecretNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update secret
         * @param {string} secretName The name of the secret to update.
         * @param {ApiV3SecretsRawSecretNamePatchRequest} apiV3SecretsRawSecretNamePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsRawSecretNamePatch(secretName: string, apiV3SecretsRawSecretNamePatchRequest: ApiV3SecretsRawSecretNamePatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsRawSecretNameDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsRawSecretNamePatch(secretName, apiV3SecretsRawSecretNamePatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsRawSecretNamePatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create secret
         * @param {string} secretName The name of the secret to create.
         * @param {ApiV3SecretsRawSecretNamePostRequest} apiV3SecretsRawSecretNamePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsRawSecretNamePost(secretName: string, apiV3SecretsRawSecretNamePostRequest: ApiV3SecretsRawSecretNamePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsRawSecretNamePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsRawSecretNamePost(secretName, apiV3SecretsRawSecretNamePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsRawSecretNamePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get secret reference tree
         * @param {string} workspaceId The ID of the project where the secret is located.
         * @param {string} environment The slug of the environment where the the secret is located.
         * @param {string} secretName The name of the secret to get the reference tree for.
         * @param {string} [secretPath] The folder path where the secret is located.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsRawSecretNameSecretReferenceTreeGet(workspaceId: string, environment: string, secretName: string, secretPath?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsRawSecretNameSecretReferenceTreeGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsRawSecretNameSecretReferenceTreeGet(workspaceId, environment, secretName, secretPath, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsRawSecretNameSecretReferenceTreeGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} secretName 
         * @param {ApiV3SecretsSecretNameDeleteRequest} apiV3SecretsSecretNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsSecretNameDelete(secretName: string, apiV3SecretsSecretNameDeleteRequest: ApiV3SecretsSecretNameDeleteRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsSecretNameDelete200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsSecretNameDelete(secretName, apiV3SecretsSecretNameDeleteRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsSecretNameDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} environment 
         * @param {string} secretName 
         * @param {string} [secretPath] 
         * @param {ApiV3SecretsSecretNameGetTypeEnum} [type] 
         * @param {number} [version] 
         * @param {ApiV3SecretsSecretNameGetIncludeImportsEnum} [includeImports] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsSecretNameGet(workspaceId: string, environment: string, secretName: string, secretPath?: string, type?: ApiV3SecretsSecretNameGetTypeEnum, version?: number, includeImports?: ApiV3SecretsSecretNameGetIncludeImportsEnum, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsSecretNameGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsSecretNameGet(workspaceId, environment, secretName, secretPath, type, version, includeImports, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsSecretNameGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} secretName 
         * @param {ApiV3SecretsSecretNamePatchRequest} apiV3SecretsSecretNamePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsSecretNamePatch(secretName: string, apiV3SecretsSecretNamePatchRequest: ApiV3SecretsSecretNamePatchRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsSecretNamePatch200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsSecretNamePatch(secretName, apiV3SecretsSecretNamePatchRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsSecretNamePatch&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} secretName 
         * @param {ApiV3SecretsSecretNamePostRequest} apiV3SecretsSecretNamePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsSecretNamePost(secretName: string, apiV3SecretsSecretNamePostRequest: ApiV3SecretsSecretNamePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsSecretNamePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsSecretNamePost(secretName, apiV3SecretsSecretNamePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsSecretNamePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Detach tags from a secret
         * @param {string} secretName The name of the secret to detach tags from.
         * @param {ApiV3SecretsTagsSecretNameDeleteRequest} apiV3SecretsTagsSecretNameDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsTagsSecretNameDelete(secretName: string, apiV3SecretsTagsSecretNameDeleteRequest: ApiV3SecretsTagsSecretNameDeleteRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsTagsSecretNamePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsTagsSecretNameDelete(secretName, apiV3SecretsTagsSecretNameDeleteRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsTagsSecretNameDelete&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach tags to a secret
         * @param {string} secretName The name of the secret to attach tags to.
         * @param {ApiV3SecretsTagsSecretNamePostRequest} apiV3SecretsTagsSecretNamePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SecretsTagsSecretNamePost(secretName: string, apiV3SecretsTagsSecretNamePostRequest: ApiV3SecretsTagsSecretNamePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SecretsTagsSecretNamePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SecretsTagsSecretNamePost(secretName, apiV3SecretsTagsSecretNamePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SecretsTagsSecretNamePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV3SignupCompleteAccountInvitePostRequest} apiV3SignupCompleteAccountInvitePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SignupCompleteAccountInvitePost(apiV3SignupCompleteAccountInvitePostRequest: ApiV3SignupCompleteAccountInvitePostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SignupCompleteAccountInvitePost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SignupCompleteAccountInvitePost(apiV3SignupCompleteAccountInvitePostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SignupCompleteAccountInvitePost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV3SignupCompleteAccountSignupPostRequest} apiV3SignupCompleteAccountSignupPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SignupCompleteAccountSignupPost(apiV3SignupCompleteAccountSignupPostRequest: ApiV3SignupCompleteAccountSignupPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SignupCompleteAccountSignupPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SignupCompleteAccountSignupPost(apiV3SignupCompleteAccountSignupPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SignupCompleteAccountSignupPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PasswordEmailPasswordResetPostRequest} apiV1PasswordEmailPasswordResetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SignupEmailSignupPost(apiV1PasswordEmailPasswordResetPostRequest: ApiV1PasswordEmailPasswordResetPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SignupEmailSignupPost(apiV1PasswordEmailPasswordResetPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SignupEmailSignupPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PasswordEmailPasswordResetVerifyPostRequest} apiV1PasswordEmailPasswordResetVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3SignupEmailVerifyPost(apiV1PasswordEmailPasswordResetVerifyPostRequest: ApiV1PasswordEmailPasswordResetVerifyPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3SignupEmailVerifyPost200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3SignupEmailVerifyPost(apiV1PasswordEmailPasswordResetVerifyPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3SignupEmailVerifyPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3UsersMeApiKeysGet(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3UsersMeApiKeysGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3UsersMeApiKeysGet(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3UsersMeApiKeysGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3WorkspacesProjectIdSecretsBlindIndexStatusGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;boolean&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3WorkspacesProjectIdSecretsBlindIndexStatusGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3WorkspacesProjectIdSecretsBlindIndexStatusGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3WorkspacesProjectIdSecretsGet(projectId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV3WorkspacesProjectIdSecretsGet200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3WorkspacesProjectIdSecretsGet(projectId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3WorkspacesProjectIdSecretsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {ApiV3WorkspacesProjectIdSecretsNamesPostRequest} apiV3WorkspacesProjectIdSecretsNamesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV3WorkspacesProjectIdSecretsNamesPost(projectId: string, apiV3WorkspacesProjectIdSecretsNamesPostRequest: ApiV3WorkspacesProjectIdSecretsNamesPostRequest, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.apiV3WorkspacesProjectIdSecretsNamesPost(projectId, apiV3WorkspacesProjectIdSecretsNamesPostRequest, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.apiV3WorkspacesProjectIdSecretsNamesPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssWebhookPost(options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;void&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.ssWebhookPost(options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.ssWebhookPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} certificateTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wellKnownEstCertificateTemplateIdCacertsGet(certificateTemplateId: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;string&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.wellKnownEstCertificateTemplateIdCacertsGet(certificateTemplateId, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.wellKnownEstCertificateTemplateIdCacertsGet&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} certificateTemplateId 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wellKnownEstCertificateTemplateIdSimpleenrollPost(certificateTemplateId: string, body?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;string&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.wellKnownEstCertificateTemplateIdSimpleenrollPost(certificateTemplateId, body, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.wellKnownEstCertificateTemplateIdSimpleenrollPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} certificateTemplateId 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wellKnownEstCertificateTemplateIdSimplereenrollPost(certificateTemplateId: string, body?: string, options?: RawAxiosRequestConfig): Promise&lt;(axios?: AxiosInstance, basePath?: string) &#x3D;&gt; AxiosPromise&lt;string&gt;&gt; {
            const localVarAxiosArgs &#x3D; await localVarAxiosParamCreator.wellKnownEstCertificateTemplateIdSimplereenrollPost(certificateTemplateId, body, options);
            const localVarOperationServerIndex &#x3D; configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath &#x3D; operationServerMap[&#x27;DefaultApi.wellKnownEstCertificateTemplateIdSimplereenrollPost&#x27;]?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) &#x3D;&gt; createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
}</code>
                    </td>
                </tr>

            <tr>
                <td class="col-md-4">
                    <div class="io-description"><p>DefaultApi - functional programming interface</p>
</div>
                </td>
            </tr>

        </tbody>
    </table>
</section>
    <h3>src/app.config.ts</h3>
    <section data-compodoc="block-properties">
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="appConfig"></a>
                    <span class="name">
                        <span ><b>appConfig</b></span>
                        <a href="#appConfig"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>new AppConfig()</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>
    <h3>src/features/infisical/generated/common.ts</h3>
    <section data-compodoc="block-properties">
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="assertParamExists"></a>
                    <span class="name">
                        <span ><b>assertParamExists</b></span>
                        <a href="#assertParamExists"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>function (functionName: string, paramName: string, paramValue: unknown) {
    if (paramValue &#x3D;&#x3D;&#x3D; null || paramValue &#x3D;&#x3D;&#x3D; undefined) {
        throw new RequiredError(paramName, &#x60;Required parameter ${paramName} was null or undefined when calling ${functionName}.&#x60;);
    }
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="createRequestFunction"></a>
                    <span class="name">
                        <span ><b>createRequestFunction</b></span>
                        <a href="#createRequestFunction"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>function (axiosArgs: RequestArgs, globalAxios: AxiosInstance, BASE_PATH: string, configuration?: Configuration) {
    return &lt;T &#x3D; unknown, R &#x3D; AxiosResponse&lt;T&gt;&gt;(axios: AxiosInstance &#x3D; globalAxios, basePath: string &#x3D; BASE_PATH) &#x3D;&gt; {
        const axiosRequestArgs &#x3D; {...axiosArgs.options, url: (axios.defaults.baseURL ? &#x27;&#x27; : configuration?.basePath ?? basePath) + axiosArgs.url};
        return axios.request&lt;T, R&gt;(axiosRequestArgs);
    };
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="DUMMY_BASE_URL"></a>
                    <span class="name">
                        <span ><b>DUMMY_BASE_URL</b></span>
                        <a href="#DUMMY_BASE_URL"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>&#x27;https://example.com&#x27;</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="serializeDataIfNeeded"></a>
                    <span class="name">
                        <span ><b>serializeDataIfNeeded</b></span>
                        <a href="#serializeDataIfNeeded"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>function (value: any, requestOptions: any, configuration?: Configuration) {
    const nonString &#x3D; typeof value !&#x3D;&#x3D; &#x27;string&#x27;;
    const needsSerialization &#x3D; nonString &amp;&amp; configuration &amp;&amp; configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers[&#x27;Content-Type&#x27;])
        : nonString;
    return needsSerialization
        ? JSON.stringify(value !&#x3D;&#x3D; undefined ? value : {})
        : (value || &quot;&quot;);
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setApiKeyToObject"></a>
                    <span class="name">
                        <span ><b>setApiKeyToObject</b></span>
                        <a href="#setApiKeyToObject"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>async function (object: any, keyParamName: string, configuration?: Configuration) {
    if (configuration &amp;&amp; configuration.apiKey) {
        const localVarApiKeyValue &#x3D; typeof configuration.apiKey &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
            ? await configuration.apiKey(keyParamName)
            : await configuration.apiKey;
        object[keyParamName] &#x3D; localVarApiKeyValue;
    }
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setBasicAuthToObject"></a>
                    <span class="name">
                        <span ><b>setBasicAuthToObject</b></span>
                        <a href="#setBasicAuthToObject"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>function (object: any, configuration?: Configuration) {
    if (configuration &amp;&amp; (configuration.username || configuration.password)) {
        object[&quot;auth&quot;] &#x3D; { username: configuration.username, password: configuration.password };
    }
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setBearerAuthToObject"></a>
                    <span class="name">
                        <span ><b>setBearerAuthToObject</b></span>
                        <a href="#setBearerAuthToObject"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>async function (object: any, configuration?: Configuration) {
    if (configuration &amp;&amp; configuration.accessToken) {
        const accessToken &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
            ? await configuration.accessToken()
            : await configuration.accessToken;
        object[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + accessToken;
    }
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setOAuthToObject"></a>
                    <span class="name">
                        <span ><b>setOAuthToObject</b></span>
                        <a href="#setOAuthToObject"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>async function (object: any, name: string, scopes: string[], configuration?: Configuration) {
    if (configuration &amp;&amp; configuration.accessToken) {
        const localVarAccessTokenValue &#x3D; typeof configuration.accessToken &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
            ? await configuration.accessToken(name, scopes)
            : await configuration.accessToken;
        object[&quot;Authorization&quot;] &#x3D; &quot;Bearer &quot; + localVarAccessTokenValue;
    }
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="setSearchParams"></a>
                    <span class="name">
                        <span ><b>setSearchParams</b></span>
                        <a href="#setSearchParams"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>function (url: URL, ...objects: any[]) {
    const searchParams &#x3D; new URLSearchParams(url.search);
    setFlattenedQueryParams(searchParams, objects);
    url.search &#x3D; searchParams.toString();
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="toPathString"></a>
                    <span class="name">
                        <span ><b>toPathString</b></span>
                        <a href="#toPathString"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>function (url: URL) {
    return url.pathname + url.search + url.hash
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>
    <h3>src/features/infisical/generated/base.ts</h3>
    <section data-compodoc="block-properties">
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="BASE_PATH"></a>
                    <span class="name">
                        <span ><b>BASE_PATH</b></span>
                        <a href="#BASE_PATH"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>&quot;https://us.infisical.com&quot;.replace(/\/+$/, &quot;&quot;)</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="COLLECTION_FORMATS"></a>
                    <span class="name">
                        <span ><b>COLLECTION_FORMATS</b></span>
                        <a href="#COLLECTION_FORMATS"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/object" target="_blank" >object</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
    csv: &quot;,&quot;,
    ssv: &quot; &quot;,
    tsv: &quot;\t&quot;,
    pipes: &quot;|&quot;,
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="operationServerMap"></a>
                    <span class="name">
                        <span ><b>operationServerMap</b></span>
                        <a href="#operationServerMap"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../interfaces/ServerMap.html" target="_self" >ServerMap</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>
    <h3>src/features/backup/backup.module.ts</h3>
    <section data-compodoc="block-properties">
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="controllers"></a>
                    <span class="name">
                        <span ><b>controllers</b></span>
                        <a href="#controllers"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>[
  appConfig.props.apiEnabled ? BackupController : undefined,
  appConfig.props.apiEnabled &amp;&amp; appConfig.props.nodeEnv &#x3D;&#x3D;&#x3D; &#x27;development&#x27;
    ? BackupScheduleController
    : undefined,
].filter((x) &#x3D;&gt; x !&#x3D;&#x3D; undefined)</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="providers"></a>
                    <span class="name">
                        <span ><b>providers</b></span>
                        <a href="#providers"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>[
  BackupService,
  appConfig.props.scheduleEnabled ? BackupSchedule : undefined,
].filter((x) &#x3D;&gt; x !&#x3D;&#x3D; undefined)</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>
    <h3>src/config/env-config.ts</h3>
    <section data-compodoc="block-properties">
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="envCfg"></a>
                    <span class="name">
                        <span ><b>envCfg</b></span>
                        <a href="#envCfg"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/object" target="_blank" >object</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>{
  API_ENABLED: cfg(&#x27;apiEnabled&#x27;, Joi.bool().optional().default(true)),
  BACKUP_MAX_NUM: cfg(
    &#x27;backupMaxNum&#x27;,
    Joi.number().optional().default(30).prefs({
      convert: true,
    }),
  ),
  BACKUP_PASSWORD: cfg(&#x27;backupPassword&#x27;, Joi.string().required()),
  DATA_DIR: cfg(&#x27;dataDir&#x27;, Joi.string().optional().default(&#x27;/ish/data&#x27;)),
  IP_BIND: cfg(&#x27;ipBind&#x27;, Joi.string().optional().ip().default(&#x27;0.0.0.0&#x27;)),
  INFISICAL_CLIENTID: cfg(&#x27;infisicalClientId&#x27;, Joi.string().required()),
  INFISICAL_CLIENTSECRET: cfg(&#x27;infisicalClientSecret&#x27;, Joi.string().required()),
  INFISICAL_SERVER_URL: cfg(
    &#x27;infisicalServerUrl&#x27;,
    Joi.string().uri().optional().default(&#x27;https://app.infisical.com&#x27;),
  ),
  LOG_LEVEL: cfg(
    &#x27;pinoLevel&#x27;,
    Joi.string()
      .allow(&#x27;trace&#x27;, &#x27;debug&#x27;, &#x27;info&#x27;, &#x27;warn&#x27;, &#x27;error&#x27;)
      .optional()
      .default(&#x27;info&#x27;),
  ),
  LOG_PRETTIFY: cfg(
    &#x27;pinoShouldPrettifyLogger&#x27;,
    Joi.bool().optional().default(true),
  ),
  NODE_ENV: cfg(&#x27;nodeEnv&#x27;, Joi.string().optional().default(&#x27;production&#x27;)),
  PORT: cfg(
    &#x27;port&#x27;,
    Joi.number().optional().default(3000).prefs({
      convert: true,
    }),
  ),
  SCHEDULE_ENABLED: cfg(
    &#x27;scheduleEnabled&#x27;,
    Joi.bool().optional().default(false),
  ),
  SCHEDULE_BACKUP_CRON: cfg(
    &#x27;scheduleBackupCron&#x27;,
    Joi.string().optional().default(&#x27;0 0 * * *&#x27;),
  ),
  SCHEDULE_BACKUP_WORKSPACE_IDS: cfg(
    &#x27;scheduleBackupWorkspaceIds&#x27;,
    Joi.commaSeparatedList().optional().prefs({ convert: true }),
  ),
  SWAGGER_ENABLED: cfg(&#x27;swaggerEnabled&#x27;, Joi.bool().optional().default(false)),
}</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="Joi"></a>
                    <span class="name">
                        <span ><b>Joi</b></span>
                        <a href="#Joi"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../miscellaneous/typealiases.html#JoiType" target="_self" >JoiType</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>OriginalJoi.extend((joi) &#x3D;&gt; ({
  base: joi.array&lt;string[]&gt;(),
  coerce(val, helpers) {
    return { value: val.split ? val.split(&#x27;,&#x27;) : val };
  },
  type: &#x27;commaSeparatedList&#x27;,
}))</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>
    <h3>src/main.ts</h3>
    <section data-compodoc="block-properties">
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="envFilePaths"></a>
                    <span class="name">
                        <span ><b>envFilePaths</b></span>
                        <a href="#envFilePaths"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>    <code>[]</code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>[&#x27;.env&#x27;]</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>
    <h3>src/app.module.ts</h3>
    <section data-compodoc="block-properties">
    <h3></h3>    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="filteredImports"></a>
                    <span class="name">
                        <span ><b>filteredImports</b></span>
                        <a href="#filteredImports"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>        <code><a href="../miscellaneous/typealiases.html#ModuleDef" target="_self" >ModuleDef[]</a></code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>imports.filter((x) &#x3D;&gt; !!x) as ModuleDef[]</code>
                    </td>
                </tr>


        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="imports"></a>
                    <span class="name">
                        <span ><b>imports</b></span>
                        <a href="#imports"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Type : </i>    <code>[]</code>

                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <i>Default value : </i><code>[
  LoggerModule.forRoot({
    pinoHttp: {
      level: appConfig.props.pinoLevel || &#x27;info&#x27;,
      transport: appConfig.props.pinoShouldPrettifyLogger
        ? {
            target: &#x27;pino-pretty&#x27;,
            options: { singleLine: true },
          }
        : undefined,
    },
    exclude: [&#x27;/healthcheck&#x27;],
  }),
  InfisicalModule,
  BackupModule,
  ScheduleModule.forRoot(),
  VersionModule,
]</code>
                    </td>
                </tr>


        </tbody>
    </table>
</section>



                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'miscellaneous-variables';
            var COMPODOC_CURRENT_PAGE_URL = 'variables.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
